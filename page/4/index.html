<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    JojoLegend
</title>
<link rel="shortcut icon" href="https://dzkjz.github.io//favicon.ico?v=1598896243067">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://dzkjz.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://dzkjz.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://dzkjz.github.io/">
                <img class="avatar" src="https://dzkjz.github.io//images/avatar.png?v=1598896243067" alt="">
            </a>
            <div class="site-title">
                <h1>
                    JojoLegend
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/vue" class="menu">
                                    Vue
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dzkjz.github.io/post/mysql-docker-rong-qi-guan-yu-ru-he-chu-li-down-hou-up-shu-ju-jiu-diu-shi-de-wen-ti-yi-ji-yuan-li/">
                        Mysql Docker容器关于如何处理down后up数据就丢失的问题以及原理
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-07-27</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Mysql Docker容器关于如何处理down后up数据就丢失的问题以及原理
[toc]
docker-compose 可以很方便的用于部署多容器环境。其中比较繁琐的就是做到多应用间数据分离。
容器随时我们可以关闭更新更换，但是要怎么做到数据的连续性就很关键了。
一、场景介绍
比较常见的情况，如果你运行起一个数据库容器，如果你删除了这个容器，那存在其中的数据也就丢失了。
特别是执行docker-compose down然后更新dockerfile和docker-compose.yml文件，再执行docker-compose up -d，你之前网站的数据就丢了。
二、原理以及原因

我们在有运行数据库容器的机器里面演示；

执行docker volume ls查看服务器里面的数据卷：

默认driver就是local ，我们配置的数据卷都在这里面了。
为了查看哪一个是数据库容器的数据卷，以及对应的详细信息
执行docker inspect 数据库容器名
然后找到 Mounts部分：

第一个我们配置的可以在docker-compose.prod.yml中找到：
  db:
    image: mysql:5.7
    container_name: ***api-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d

而第二个对应目标地址是/var/lib/mysql的，因为我没有配置，所以自动给了一个，正是这个没有配置，导致每次docker-compose up -d就生成一个新容器及对应的数据卷，然后之前的数据库数据就丢失了。
三、处理办法
如果你配置了比如
  db:
    ...
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
      - /data/mysql:/var/lib/mysql
   #   - /data/pgsql:/var/lib/postgresql
   #   - /data/maria:/var/lib/mariadb
   #   - /data/redis:/var/lib/redis
   #   - /data/memcached:/var/lib/memcached
   #   - /data/neo4j:/var/lib/neo4j/data
    networks:
      ...

配置了对应的本地[宿主机]数据卷位置，第一次docker-compose up -d的时候会直接关联起来，而下一次执行docker-compose up -d的时候，daemon执行到生成一个对应数据卷位置的时候，发现已经给了配置，那就跳过，使用先前的。
当然也可以这么配置：
volumes:
- db-data:/var/lib/mysql
volumes:
 db-data:
  driver: local


参考 Running PostgreSQL using Docker Compose
参考 Data is lost in Mysql docker container after comminting it to a new image?

I don&#39;t know which image you&#39;re using but I believe every Dockerfile of official mysql images has following command:
VOLUME /var/lib/mysql

which means all mysql data goes to volume. From docker volume docs they specially mentioned that:
&amp;gt; Changes to a data volume will not be included when you update an image.

And this is the root cause you loss your data in newly started container.
For your question:

How to achieve this?

You can use either mounted volumes, or create a data volume container, then run mysql container with option --volumes-from. The former links contain step-by-step guide of how to do it.

I don&#39;t want to use mounted volumes because i want to link this container with another container of my application so that it can inset and update into db

I don&#39;t know what other concerns you have about mounted volumes, but as far as I can tell, using mounted volumes does not prevent you to link containers.
Hope this helps you.


四、如果不慎丢失，怎么恢复
如果数据卷都删除了 docker rm 容器的时候 添加了 -v 或 -volume，那就拜拜，没有任何办法的。如果没有删除volume 参考：
Saving &#39;lost&#39; MYSQL database running in Docker
更多可以看官方文档

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dzkjz.github.io/post/mysql-docker-rong-qi-guan-yu-ru-he-chu-li-down-hou-up-shu-ju-jiu-diu-shi-de-wen-ti-yi-ji-yuan-li/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dzkjz.github.io/post/jie-jue-sitemap-robotstxt-yi-ji-ti-jiao-google-index/">
                         解决 sitemap robots.txt 以及提交google index
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-07-26</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Sitemap
在nuxt app里面执行
npm install @nuxtjs/sitemap

//nuxt.config.js
  modules: [
    // Doc: https://axios.nuxtjs.org/usage
    &#39;@nuxtjs/axios&#39;,
    &#39;@nuxtjs/auth&#39;,
    &#39;vue-social-sharing/nuxt&#39;,
    // Doc: https://github.com/nuxt-community/dotenv-module
    &#39;@nuxtjs/dotenv&#39;,
    &#39;cookie-universal-nuxt&#39;,//https://www.npmjs.com/package/cookie-universal-nuxt
    &#39;@nuxtjs/sitemap&#39;,
  ],

  sitemap: {
    //https://www.npmjs.com/package/@nuxtjs/sitemap
    hostname: &#39;https://&#39; + process.env.DOMAIN_NAME,
    gzip: true,
    exclude: [
      &#39;/verify/**&#39;,
      &#39;/verifynew/**&#39;,
      &#39;/password_reset/**&#39;,
      &#39;/dashboard_reset/**&#39;,
      &#39;/animals/create/**&#39;,
    ],

具体配置官方文档有讲。
默认情况下只有static页面会自动添加，对于动态的路由页面，parent/:children，这样的，参考 HOW TO: Include dynamic routes in sitemap with Nuxt.js
Robot.txt
npm install @nuxtjs/robots
//nuxt.config.js
  modules: [
    // Doc: https://axios.nuxtjs.org/usage
    &#39;@nuxtjs/axios&#39;,
    &#39;@nuxtjs/auth&#39;,
    &#39;vue-social-sharing/nuxt&#39;,
    // Doc: https://github.com/nuxt-community/dotenv-module
    &#39;@nuxtjs/dotenv&#39;,
    &#39;cookie-universal-nuxt&#39;,//https://www.npmjs.com/package/cookie-universal-nuxt
    &#39;@nuxtjs/sitemap&#39;,
    &#39;@nuxtjs/robots&#39;,
  ],
        robots: [ //https://www.npmjs.com/package/@nuxtjs/robots
    {
      // UserAgent: &#39;Googlebot&#39;,
      UserAgent: &#39;*&#39;,
      Disallow: () =&amp;gt; [
        &#39;/verify&#39;,
        &#39;/verify&#39;,
        &#39;/verifynew&#39;,
        &#39;/password_reset&#39;,
        &#39;/dashboard_reset&#39;,
        &#39;/animals/create&#39;,
      ], // accepts function
      Sitemap: &#39;https://&#39; + process.env.DOMAIN_NAME + &#39;/sitemap.xml&#39;,
    }
  ],

具体配置介绍参考官方文档。
Ask Google to recrawl your URLs
Submit a sitemap (many URLs at once)
A sitemap is an important way for Google to discover URLs on your site. A sitemap can also include additional metadata about alternate language versions and video-, image-, or news-specific pages. Learn how to create a sitemap.
If you have not changed your sitemap since the last time Google crawled it, resubmitting the sitemap won&#39;t have any additional benefit. If you have updated pages in the sitemap, mark them with &amp;lt;lastmod&amp;gt;.
Here are the different ways that you can alert Google about your sitemap:

Submit a sitemap using the sitemaps report.
Use the ping tool. Send a GET request in your browser or the command line to this address, specifying the full URL of the sitemap. Be sure that the sitemap file is accessible:
http://www.google.com/ping?sitemap=*&amp;lt;full_URL_of_sitemap&amp;gt;*
Example:
http://www.google.com/ping?sitemap=https://example.com/sitemap.xml
Insert the following line anywhere in your robots.txt file, specifying the path to your sitemap. We will find it the next time we crawl your site:
Sitemap: http://example.com/my_sitemap.xml

Nuxt页面跳转过度动效
/*assets/styles/main.css*/
/*@import &#39;@vue-cookie-accept-decline.css&#39;;*/

.page-enter-active, .page-leave-active {
  transition: opacity .5s;
}

.page-enter, .page-leave-to {
  opacity: 0;
}

//nuxt.config.js 
css: [
      ...
    &#39;@/assets/styles/main.css&#39;,
      ...
  ],

官方文档：
https://nuxtjs.org/api/configuration-loading
https://nuxtjs.org/api/pages-transition
//nuxt.config.js
loading: {
    color: &#39;orange&#39;,
    height: &#39;5px&#39;,
    failedColor: &#39;red&#39;,
    duration: 5000,
    continuous: true,
  },

自定义的可以参考 使用自定义的组件设置加载样式
改变Favicon
参考 https://github.com/nuxt/nuxt.js/issues/903
//nuxt.config.js
link: [
      {rel: &#39;icon&#39;, type: &#39;image/x-icon&#39;, href: &#39;/tiere_favi.png&#39;},
    ]

官方文档也可以看看

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dzkjz.github.io/post/jie-jue-sitemap-robotstxt-yi-ji-ti-jiao-google-index/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dzkjz.github.io/post/cai-keng-ji-lu-nuxtjs-and-ant-design-vue-pei-zhi/">
                        「踩坑记录」 Nuxt.js &amp; Ant-design-vue 配置
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-07-25</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Nuxt.js &amp;amp; ant-design-vue
最近开发一个带seo以及部分后台功能的项目，nuxt作为vue ssr框架可以非常好的完成这个需求，这里我选择了ant-design-vue作为UI组件库。
以下是踩坑的一些记录 ：
首先介绍一下项目情况和需求：

Nuxt.js是一个 Vue.js 通用框架，预设了使用 Vue.js开发SSR的各种配置。项目中使用的是SSR模式，因此首屏是由服务端完成渲染。
项目仅用到少数的UI组件，因此我们希望使用按需加载组件，以减少网络开销。

1. 按需加载引入组件
首先我们移除掉 nuxt.config.js 中
{   css: [&#39;ant-design-vue/dist/antd.css&#39;],   // 这里会全局引入所有样式，不是我们所希望的按需加载 }

参考官方文档antd-vue # 按需加载：
// 同时参考 Nuxt-cli 创建项目时 创建的 plugin/antd-ui.js 
import Vue from &#39;vue&#39; import Button from &#39;ant-design-vue/lib/button&#39;; 
import &#39;ant-design-vue/lib/button/style&#39;; // 或者 ant-design-vue/lib/button/style/css 加载 css 文件  
Vue.use(Button.name, Button)

编译未通过，提示错误：
// https://github.com/ant-design/ant-motion/issues/44 .bezierEasingMixin(); ^ Inline JavaScript is not enabled. Is it set in your options?

根据报错所提供的信息，less升级到3.0 后，需要 less-loader配置一个功能，才能正常使用：
// nuxt.config.js 
{  
    build: {   
        loaders: {    
            less: {     
                javascriptEnabled: true    
            }   
        }  
    } 
}

编译通过，打开页面，返回500，提示：

image.png
编译能通过，说明代码编译没有问题，但是server端执行时出现了错误。尝试注释掉plugin/antd-ui.js引入样式文件这行 import &#39;ant-design-vue/lib/button/style&#39;; ，server首屏渲染能够正常启动，但引入的button组件样式丢失。
打开 ant-design-vue/lib/button/style/index.js 查看：
&#39;use strict&#39;; 
require(&#39;../../style/index.less&#39;); 
require(&#39;./index.less&#39;);  
// ant-design-vue/es/button/style/index.js 
import &#39;../../style/index.less&#39;; 
import &#39;./index.less&#39;;

可以看到，antd-vue为生产环境提供了两种模块的代码。为了tree-shaking 我们优先选择 es 模块。

补充知识：现在的webpack@4+ 支持识别项目 packge.json module字段，使用ESModule的依赖更好的支持构建中的tree-shaking。

修改代码为 es/button/...，编译通过，但页面仍抛出一500服务端错误：

image.png
根据错误提示cannot use import statement和es包使用的ESModule语法，猜测服务端侧渲染页面时语法出错，Node.js 不能直接识别 .js文件内的ESModule语法。
// .nuxt.config.js 
{  
    plugins: 
    [   
        {    
            src: &#39;@/plugins/antd-ui&#39;,    
            mode: &#39;client&#39; // 仅 客户端使用plugin   
        }  
    ] 
}

页面正常加载，但Vue.js 给出了错误提示

image.png
此时，我们再将plugin代码替换回lib以及移除mode: &#39;client ，错误又回到了最开始的 invalid or unexpected token。
搜索Nuxt官方文档：

如果要使用Babel与特定的依赖关系进行转换，你可以在build.transpile中添加它们，transpile中的选项可以是字符串或正则表达式对象，用于匹配依赖项文件名。

添加配置：
{ // nuxt.config.js  
    build: {   
        transpile: [/ant-design-vue/]
    } 
}

终于，服务端渲染正常，样式也正常加载。接着引入 ant-design-vue官方推荐使用的插件babel-plugin-import
// nuxt.config.js 
{  
    build: {
        babel: {
            plugins: [
                [      
                    &#39;import&#39;,      
                    {       
                        libraryName: &#39;ant-design-vue&#39;,       
                        libraryDirectory: &#39;es&#39;,       
                        // 选择子目录 例如 es 表示 ant-design-vue/es/component       
                        // lib 表示 ant-design-vue/lib/component              
                        style: true       
                        // 默认不使用该选项，即不导入样式 , 注意 ant-design-vue 使用 js 文件引入样式       
                        // true 表示 import  &#39;ant-design-vue/es/component/style&#39;      
                        // &#39;css&#39; 表示 import &#39;ant-design-vue/es/component/style/css&#39;      
                    }     
                ]    
            ]   
        }  
    } 
}  // plugins/antd-ui.js 
import Vue from &#39;vue&#39; 
import { Button } from &#39;ant-dsign-vue&#39; // 这时，可以通过 简写的方式引入样式和组件  
Vue.use(Button)

2. pages目录内引入组件

flash.gif
上图是在pages/index.vue内引入组件，npm run build &amp;amp;&amp;amp; npm run start 执行后的线上环境，可以看到样式在刷新首屏时，会看到闪烁的现象，这里出现的问题在于入口文件并不包含组件，而是异步引入的，从编译结果上也可以看到 610kb 的包对应的chunk vendors.pages/index ，并不在entrypoint内，默认情况下Nuxt.js 路由页面已经被分配为dynamic import，同时style是通过js设置到style上的，而不是单独打包出来。经过测试，css单独打包后，UI组件仍是单独分包，即便是单独打包出来，依然会有按需加载的问题，首屏仍会闪烁。

build result
因此，如果组件被大多数页面使用，推荐在 plugin内注册，或者通过 nuxt.config.js的css相关文件直接引入对应的组件样式，同时关闭babel-import-plugin 的 style选项。 (吐槽一句，iView只能引入单一全局样式，不能按需加载样式，1.5m的大小非常恐怖)
除此以外，可以考虑配置webpack的splitchunks配置，实现自己的需求。
3. 解决antd-icon 过大（传统艺能
前面生产环境的包可以发现，只使用了一个Button，却打包了600kb的依赖，检查后发现是引入了@ant-design/icon 包。
参考： https://github.com/HeskeyBaozi/reduce-antd-icons-bundle-demo
{ // nuxt.config.js  
    build: 
    {   
        extend(config, ctx) {
            config.resolve.alias[&#39;@ant-design/icons/lib/dist$&#39;] = path.resolve(__dirname, &#39;./assets/icon/antd-icon.js&#39;) // 引入需要的  
        }  
    } 
}

题外话
“按需引入”

image.png
https://github.com/ant-design/babel-plugin-import/issues/347
reference
https://github.com/vueComponent/ant-design-vue/issues/234
https://www.zhihu.com/question/265227812

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dzkjz.github.io/post/cai-keng-ji-lu-nuxtjs-and-ant-design-vue-pei-zhi/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dzkjz.github.io/post/zong-jie-nuxt-laravel-nginx-mysql-docker-ubuntu-bu-shu-de-liu-cheng/">
                        总结nuxt laravel nginx mysql docker ubuntu部署的流程
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-07-19</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            一、Docker
什么是docker可以参考:什么是 Docker
在进行下面的操作之前，请先安装Docker 
针对这篇文章，我们需要的是：

一个容器运行nginx
一个容器运行php-fpm
一个容器运行mysql
一个容器运行node

四个容器：


nginx和mysql容器可以直接用官方的镜像。所以这两个容器不需要Dockerfile；


php-fpm容器 主要是运行 laravel；


另外需要一个临时容器给安装composer，安装完成后删除这个临时容器就行；


node容器用于运行nuxt。


php-fpm容器我们需要安装一些扩展包，执行composer安装，所以用Dockerfile配置：
更多Dockerfile配置的指令介绍参考：使用 Dockerfile 定制镜像
请注意教程中的

此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。
很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。

以及对路径上下文的解释

镜像构建上下文（Context）
这个也是很奇葩的，初学的时候，是单纯的认为 下面这个命令
COPY ./somefiles /var/www
就是复制Dockerfile所在的文件夹下somefiles文件夹及其内部文件到 此镜像构建的容器内的 /var/www目录里。
但是这么理解会出问题，首先，可以用~/sub/fab/docker/somotherfiles/ 这么指定宿主机文件夹路径吗？
答案是不行的。会报错找不到。
然后，那么可以用 ../this/somefiles/指定宿主机文件夹路径吗？
答案也是不行的，也是报错找不到。
具体涉及到的是 Docker 引擎，具体看教程解释，不过可以简单的这么说，就是构建的时候，只打包dockerfile文件路径下的所有内容传到docker引擎，所以是不包含外部的以及可以用~指定的路径下的。同时也要注意，这个dockerfile文件打包的所有内容如果你给的文件太大了，那传输起来就牛了，有的几十个GB 传输很头疼的，所以需要注意，dockerfile所在文件夹下的文件内容，只留下需要的。
还有上面是笼统的说成是dockerfile文件所在文件夹，其实也是不完全正确的。
因为可以 -f ../Dockerfilev3 这么指定需要的Dockerfile 首先路径在外面，然后名字也不同，不过一般情况不这么干。默认状态下前面说的不严谨但也可以是对的。还有其它 docker build 的用法。

app 容器 Dockerfile
FROM php:7.2.19-fpm #指定 基础镜像

# Arguments defined in docker-compose.yml
ARG user #定义参数
ARG uid  #定义参数

# Install system dependencies 安装系统依赖 #RUN 指令是用来执行命令行命令的
# Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip


# Clear cache 清理cache
RUN apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* #使用 &amp;amp;&amp;amp; 将各个所需命令串联起来

# Install PHP extensions 安装扩展
RUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd

# Get latest Composer 这里是把composer给复制到 本Dockerfile定义的容器的 /usr/bin/composer里
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Create system user to run Composer and Artisan Commands
# 创建系统用户用于执行 composer和 artisan 命令 实际是给权限。
RUN useradd -G www-data,root -u $uid -d /home/$user $user
RUN mkdir -p /home/$user/.composer &amp;amp;&amp;amp; \
    chown -R $user:$user /home/$user

# Set working directory 本容器的工作文件夹
WORKDIR /var/www

USER $user #设置容器的用户



需要了解更多指令可以参考：
COPY 复制文件
ADD 更高级的复制文件
[Dockerfile 最佳实践文档](Dockerfile 最佳实践文档)
CMD 容器启动命令
ENTRYPOINT 入口点
ENV 设置环境变量
ARG 构建参数
VOLUME 定义匿名卷 上面的dockerfile没有挂载数据卷到容器内，但是我们在docker-compose里挂载了，后面讲。
EXPOSE 暴露端口 EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务， 明确 -P随机映射端口时会映射到EXPOSE的端口，-p指定时，是按-p指定的来。
WORKDIR 指定工作目录
请注意Dockerfile 构建分层存储的概念。
每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。

RUN cd /app
RUN echo &amp;quot;hello&amp;quot; &amp;gt; world.txt

如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello
第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。

因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。
USER 指定当前用户

USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。
USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。

HEALTHCHECK 健康检查
ONBUILD 为他人作嫁衣裳

ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。

参考文档

laravel运行的php-fpm容器Dockerfile配置好之后，接下来是配置前端nuxt需要的node容器。
node容器Dockerfile
#使用node:12-alpine 作为基础进行构建
FROM node:12-alpine

#创建/app 目录作为部署目录,创建容器实例时,挂载此目录
RUN mkdir -p /app

#移动工作目录到 /app
WORKDIR /app

#安装 bash 和 busybox
RUN apk update \
        &amp;amp;&amp;amp; apk upgrade \
        &amp;amp;&amp;amp; apk add --no-cache bash \
        bash-doc \
        bash-completion \
        &amp;amp;&amp;amp; /bin/bash \
        &amp;amp;&amp;amp; apk add --no-cache busybox \
        &amp;amp;&amp;amp; rm -rf /var/cache/apk/*

#安装 git
RUN apk add git
		
#设置node环境变量为production
ENV NODE_ENV=production

# copy the app, note .dockerignore
COPY ./pets-client /app
RUN npm install

# build necessary, even if no static files are needed,
# since it builds the server as well
RUN npm run build
RUN npm cache clean --force

# set app serving to permissive / assigned
#ENV NUXT_HOST=0.0.0.0 已经在nuxt.config.js中设置了server block
# set app port
#ENV NUXT_PORT=5000 已经在nuxt.config.js中设置了server block

#设置容器启动时执行的命令
#ENTRYPOINT [ &amp;quot;npm&amp;quot;,&amp;quot;start&amp;quot; ]
CMD [&amp;quot;npm&amp;quot;,&amp;quot;start&amp;quot;]

Dockerfile部分到此就结束了，接下来，需要了解Docker-Compose
二、Docker-Compose
Docker-Compose 是用来管理你的容器的，有点像一个容器的管家，想象一下当你的Docker中有成百上千的容器需要启动，如果一个一个的启动那得多费时间。有了Docker-Compose你只需要编写一个文件，在这个文件里面声明好要启动的容器，配置一些参数，执行一下这个文件，Docker就会按照你声明的配置去把所有的容器启动起来，只需docker-compose up即可启动所有的容器，但是Docker-Compose只能管理当前主机上的Docker，也就是说不能去启动其他主机上的Docker容器。
补充

Docker Swarm
Docker Swarm 是一款用来管理多主机上的Docker容器的工具，可以负责帮你启动容器，监控容器状态，如果容器的状态不正常它会帮你重新帮你启动一个新的容器，来提供服务，同时也提供服务之间的负载均衡，而这些东西Docker-Compose 是做不到的
Kubernetes
Kubernetes它本身的角色定位是和Docker Swarm 是一样的，也就是说他们负责的工作在容器领域来说是相同的部分，都是一个跨主机的容器管理平台，当然也有自己一些不一样的特点，k8s是谷歌公司根据自身的多年的运维经验研发的一款容器管理平台。而Docker Swarm则是由Docker 公司研发的。现在常用Kubernetes

它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。
Compose 中有两个重要的概念：

服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。
项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。

Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。
本节的安装链接已经有安装教程，安装此处略
给出本次项目的完成版本docker-compose.prod.yml
完成版本docker-compose.prod.yml
version: &amp;quot;3.7&amp;quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin
  nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge

接下来细分拆解；
app部分：
app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin

这是定义的第一个服务，
app【php】的Dockerfile里，我们定义了两个参数 user 和 uid ，这里进行了赋值。
因为使用build指令，所以必须给到context 和 Dockerfile，这个context即已经在 前面提到过的镜像构建上下文。
build可以不给context 直接给路径如：build: ./dir 需要注意的格式是 build:[空格]./dir 空格不能少
image 是给这个生成的镜像的名字，如果没有build而是直接给image，docker会去dockerhub官方搜这个包，搜到了就给pull下来。
app 其运行起来的容器名叫petapi-app，这个名字很重要，nginx的conf里，我们会用到这个：

server {
listen 80;
   listen [::]:80;
   server_name api.example.com;
   return 301 https://$http_host$request_uri;
   #rewrite ^(.*)$ https://$host$1 permanent; we just replace request to https
}
server{
listen 443 ssl;
   listen [::]:443 ssl;
   server_name api.example.com;
   #ssl on; no need this anymore please change use listen 443 ssl only
   ssl_certificate /etc/nginx/certs/cert.pem;
   ssl_certificate_key /etc/nginx/certs/key.pem;
   #ssl_session_timeout 5m;
   #ssl_protocols read blow info please;
   # By default nginx uses “ssl_protocols TLSv1 TLSv1.1 TLSv1.2” and 
#“ssl_ciphers HIGH:!aNULL:!MD5”, so configuring them explicitly is 
#generally not needed.
   index index.php index.html;
   error_log /var/log/nginx/error.log;
   access_log /var/log/nginx/access.log;
   root /var/www/public;
   location ~ \.php$ {
           try_files $uri =404;
           fastcgi_split_path_info ^(.+\.php)(/.+)$;
           fastcgi_pass petapi-app:9000;
           fastcgi_index index.php;
           include fastcgi_params;
           fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
           fastcgi_param PATH_INFO $fastcgi_path_info;
           }
   location / {
            try_files $uri $uri/ /index.php?$query_string;
            gzip_static on;
            }
    }   


注意 fastcgi_pass petapi-app:9000; 我们用到了container_name 即这个app容器的名字。9000是默认php-fpm的端口。
其次，我们Dockerfile之前没有设置数据卷，这里设置了加载 docker-compose.prod.yml所在文件夹全部内容 到容器中
restart:  指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。
networks:  配置容器连接的网络。这个网络主要是给服务容器之间通信的，db我们用的mysql通过这个网络和app通信，nginx也通过这个网络和app通信。这三个公用的 petapin 这个网路，这个网络是在 外层 networks:中定义的。
一般来说，docker -compose 就是：
version: 
services:
networks:

这三个。networks 的 driver 可以参考 network_mode。  错啦！networks 应该参考 Network configuration reference
关于networks和links 请看 Networking in Compose

compose 默认会提供一个network ，每个服务都会加入这个network，且默认互通，它们之间以一个基于容器名生成的名作区分。
一般来说网络名基于项目名【项目基于存放其的文件夹名】
比如说, 假设你的app存放于一个叫myapp的文件夹里, 你的 docker-compose.yml 配置如下:
version: &amp;quot;3&amp;quot;
services:
web:
build: .
ports:
    - &amp;quot;8000:8000&amp;quot;
db:
  image: postgres
  ports:
    - &amp;quot;8001:5432&amp;quot;

当你执行 docker-compose up,的时候 ，会有如下流程:

一个名叫myapp_default的网络被创建 。
使用 web配置创建一个容器. 该容器加入 myapp_default 网络并且赋予一个标识名 web.
使用 db配置创建一个容器.  该容器加入 myapp_default 网络并且赋予一个标识名 db.

每一个容器都可以通过标识名web,db查询到这两容器，并获得这两容器的ip地址，比如，web容器里的程序代码可以通过postgres:5342链接到db容器，就可以使用postgres数据库啦。
It is important to note the distinction between HOST_PORT and CONTAINER_PORT. In the above example, for db, the HOST_PORT is 8001 and the container port is 5432 (postgres default). Networked service-to-service communication use the CONTAINER_PORT. When HOST_PORT is defined, the service is accessible outside the swarm as well.
Within the web container, your connection string to db would look like postgres://db:5432, and from the host machine, the connection string would look like postgres://{DOCKER_IP}:8001.
Links了解就行
这个参考 links将会在今后被移除，后期这个没有了，现在了解就行，不推荐使用。
Links allow you to define extra aliases by which a service is reachable from another service. They are not required to enable services to communicate - by default, any service can reach any other service at that service’s name. In the following example, db is reachable from web at the hostnames db and database:
version: &amp;quot;3&amp;quot;
services:

web:
  build: .
  links:
    - &amp;quot;db:database&amp;quot;
db:
  image: postgres

See the links reference for more information.
NETWORKS
我们这里用的就是这个。

更多的指令参考 docker compose 指令
frontapp配置参考上面的自己理解，
db部分：
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin

数据库在这个项目中，存在一个导入的操作，如果以后网站主机迁移，同样也可以打包导入，教程在cnblog有。
数据库部分其余的都没啥好说的，主要是environment里的配置，一般情况下使用的是
environment:
  RACK_ENV: development
  SHOW: &#39;true&#39;
  SESSION_SECRET:
environment:
  - RACK_ENV=development
  - SHOW=true
  - SESSION_SECRET

这种赋值格式。
但是${...} 怎么理解？

You can use environment variables in configuration values with a Bash-like ${VARIABLE} syntax - see variable substitution for full details.
就是说，${...}是可以读取设置在.env文件中的值的，但是必须在执行 docker-compose up的时候，如果在执行的时候另行赋值 --name=...会覆盖.env中的值。.env文件中配置的值只在 docker-compose up执行的时候起作用，docker stack deploy不起作用。
其他用法： ${VARIABLE:-default}及${VARIABLE-default} 及${VARIABLE:?err}及${VARIABLE?err}

也就是说，上面配置db容器的值，在docker-compose up的时候，读取同目录下.env文件中配置的值。
nginx部分
nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn

nginx配置中我们使用了两个conf，petapi.conf及 petclient.conf存放于 ./docker-compose/nginx目录下。通过volumes配置，加载到了nginx容器内的/etc/nginx/conf.d文件夹中。
然后是ssl的key.pem和cert.pem文件存放在./docker-compose/nginx/certs文件夹下。通过volumes配置，加载到了nginx容器内的/etc/nginx/certs文件夹内。
为什么配置 ./加载到/var/www文件夹中呢？
我们看看petapi.conf:
server {
   listen 80;
        略...
     }
server{
   listen 443 ssl;
        listen [::]:443 ssl;
        server_name api.example.com;
        ssl_certificate /etc/nginx/certs/cert.pem;
        ssl_certificate_key /etc/nginx/certs/key.pem;
        index index.php index.html;
        error_log /var/log/nginx/error.log;
        access_log /var/log/nginx/access.log;
        root /var/www/public;
        location ~ \.php$ {
                try_files $uri =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass petapi-app:9000;
                fastcgi_index index.php;
                }
        location / {
                 try_files $uri $uri/ /index.php?$query_string;
                 gzip_static on;
                 }
         }

再看目录结构
drwxrwxr-x 16 ***** *****     4096 Jul 18 15:05 ./
drwxrwxr-x  4 ***** *****      4096 Jul 13 07:09 ../
drwxrwxr-x 11 ***** *****      4096 Jul 12 17:00 app/
-rw-rw-r--  1 ***** *****      1686 Jul 12 17:00 artisan
drwxrwxr-x  3 ***** *****      4096 Jul 12 17:00 bootstrap/ 
-rw-rw-r--  1 ***** *****      1660 Jul 12 17:00 composer.json
-rw-rw-r--  1 ***** *****    208927 Jul 12 17:00 composer.lock
drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 config/
drwxrwxr-x  5 ***** *****      4096 Jul 12 17:00 database/
drwxrwxr-x  4 ***** *****      4096 Jul 16 06:15 docker-compose/
-rw-rw-r--  1 ***** *****      1806 Jul 18 13:06 docker-compose.prod.yml
-rw-rw-r--  1 ***** *****       741 Jul 12 17:12 Dockerfile
drwxrwxr-x  3 ***** *****      4096 Jul 15 18:07 dockerfiles/
-rw-rw-r--  1 ***** *****       220 Jul 12 17:00 .editorconfig
-rw-rw-r--  1 ***** *****       844 Jul 12 18:37 .env
-rw-rw-r--  1 ***** *****       778 Jul 12 17:00 .env.example
drwxrwxr-x  8 ***** *****      4096 Jul 12 17:00 .git/
-rw-rw-r--  1 ***** *****       111 Jul 12 17:00 .gitattributes
-rw-rw-r--  1 ***** *****       163 Jul 12 17:00 .gitignore
drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 .idea/
-rw-rw-r--  1 ***** *****      1013 Jul 12 17:00 package.json
-rw-rw-r--  1 ***** *****    462139 Jul 12 17:00 package-lock.json
-rw-rw-r--  1 ***** *****      1197 Jul 12 17:00 phpunit.xml
drwxrwxr-x  2 ***** *****      4096 Jul 13 14:46 public/
-rw-rw-r--  1 ***** *****      4497 Jul 12 17:00 README.md
drwxrwxr-x  6 ***** *****      4096 Jul 12 17:00 resources/
drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 routes/
-rw-rw-r--  1 ***** *****       563 Jul 12 17:00 server.php
drwxrwxr-x  5 ***** ********   4096 Jul 12 17:00 storage/
-rw-rw-r--  1 ***** *****       174 Jul 12 17:00 .styleci.yml
drwxrwxr-x  4 ***** *****      4096 Jul 12 17:00 tests/
drwxr-xr-x 48 ***** *****      4096 Jul 12 18:28 vendor/
-rw-rw-r--  1 ***** *****       538 Jul 12 17:00 webpack.mix.js

nginx在 api.example.com:80或443请求的时候，80强制转443，然后看443中处理逻辑。
容器中的root /var/www/public/对应的就是宿主机 public文件夹。
location / {
	try_files $uri $uri/ /index.php?$query_string;
	gzip_static on;
	}

访问的时候，尝试的是比如	http://api.exampl.com/api/pigs/all/1会解析出uri api/pigs/all/1，这个uri文件在public目录中是没有的。
public目录：
drwxrwxr-x  2 ***** ***** 4096 Jul 13 14:46 ./
drwxrwxr-x 16 ***** ***** 4096 Jul 18 15:05 ../
-rw-rw-r--  1 ***** *****    0 Jul 12 17:00 favicon.ico
-rw-rw-r--  1 ***** *****  603 Jul 12 17:00 .htaccess
-rw-rw-r--  1 ***** ***** 1823 Jul 12 17:00 index.php
-rw-rw-r--  1 ***** *****   24 Jul 12 17:00 robots.txt
lrwxrwxrwx  1 ***** *****   27 Jul 13 14:46 storage -&amp;gt; /var/www/storage/app/public
-rw-rw-r--  1 ***** ***** 1194 Jul 12 17:00 web.config

所以直接跳解析/index.php?$query_string; 然后$query_string就是api/pigs/all/1，然后就是laravel工作逻辑了。解析出request，parameters...
所以这个加载到nginx中是必要的，如果不用try_files呢【没试过】？那应该就app容器开一个端口[比如12343]，然后nginx使用proxy_pass petapi-app:开的端口号[12343] ，这样就ok了吧。
接下来看看ssl配置，前面说到

ssl的key.pem和cert.pem文件存放在./docker-compose/nginx/certs文件夹下。通过volumes配置，加载到了nginx容器内的/etc/nginx/certs文件夹内。

所以ssl部分的配置有：
ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;

同样的来看看
frontapp部分的conf配置：
server {
listen 80;
listen [::]:80;
server_name example.com www.example.com;
return 301 https://$http_host$request_uri;
#rewrite ^(.*)$ https://$host$1 permanent; we just replace request to https
}
server{
listen 443 ssl;
listen [::]:443 ssl;
server_name example.com www.example.com;
#ssl on; no need this anymore please change use listen 443 ssl only
ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;
#ssl_session_timeout 5m;
#ssl_protocols read blow info please;
# By default nginx uses “ssl_protocols TLSv1 TLSv1.1 TLSv1.2” and 
#“ssl_ciphers HIGH:!aNULL:!MD5”, so configuring them explicitly is generally 
#not needed.
index index.php index.html;
error_log /var/log/nginx/error.log;
access_log /var/log/nginx/access.log;
root /var/www/public;
location ~ \.php$ {
try_files $uri =404;
fastcgi_split_path_info ^(.+\.php)(/.+)$;
fastcgi_pass frontapp:9000;
fastcgi_index index.php;
include fastcgi_params;
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
fastcgi_param PATH_INFO $fastcgi_path_info;
}
location / {
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host  $http_host;
proxy_set_header X-Nginx-Proxy true;
proxy_set_header Connection &amp;quot;&amp;quot;;
proxy_pass http://frontapp:8000; #因为在nuxt中 server配置就这个
gzip_static on;
}
}

与petapi.conf不同的就是
location / {
                proxy_set_header X-Real-IP $remote_addr;
				proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
				proxy_set_header Host  $http_host;
				proxy_set_header X-Nginx-Proxy true;
				proxy_set_header Connection &amp;quot;&amp;quot;;
				proxy_pass http://frontapp:8000; #因为在nuxt中 server配置就这个
                gzip_static on;
                }

proxy_pass一定是 http://开头+ip+:+端口，
ip用了容器参数，这也是为啥nginx容器的depends_on设置了app和frontapp两个容器，因为要用啊。
端口设置为8000是因为nuxt中nuxt.config.js值为：
  server: {
    port: 8000, // default: 3000
    host: &#39;0.0.0.0&#39;, // default: localhost,
    timing: false
    // timing: {
    //   total: true
    // }
  },

端口给设置了8000，node的Dockerfile我们也就没有开端口了。
如果给docker-compose.prod.yml加一个
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    ports:
     - 800:8000
    networks:
      - petclientn

注意其中
    ports:
     - 800:8000

加上了就可以通过宿主机ip[当前环境下就是服务器ip]:8000直接访问nuxt应用。我们这里不用，只是说原理如此。但是如果你给开个443端口访问这个8000端口，会不行，会报端口已经被(就是nginx容器)占用。
docker-compose.prod.yml配置完了，然后执行 docker-compose -f docker-compose.prod.yml build app frontapp给爷生成这两容器的镜像出来。生成完了 执行 docker-compose -f docker-compose.prod.yml up -d就可以跑起来了。执行命令切换到 docker-compose.prod.yml文件的目录下，这样-f指定免得给一串长的地址。
三、laravel发布需要准备的文件和生产环境要做的一些操作
laravel的代码，我是直接git clone 下来然后进到app容器里
执行
cp .env.example .env .env文件。
特别注意
APP_ENV=production
APP_DEBUG=false
APP_URL

php artisan key:generate 生成key
然后自己配置.env文件中的值，mail啊 jwt啊 mysql之类的。
php artisan migrate 数据库
然后就是进入db数据库容器，检查用户，表，导入打包的数据库。
接着就是把storage里的文件用rsync给传到服务器[宿主机]的laravel存放文件夹里的storage对应的文件夹里。
再在app容器执行
php artisan storage:link
然后就可以用了。
php artisan optimize
至于邮件，需要开启queue，以及supervisor。【暂缺】【不用supervisor也可以开启queue并确保不service down 参考更新部分 】
四、nuxt遇到的坑
如果有代码用到了
target: (process.env.NODE_ENV === &amp;quot;production&amp;quot;) ? process.env.API_URL : &amp;quot;http://petapi.test/api&amp;quot;,
这样的，那env文件必须要有。否则必然报target null 类型错误。
还要安装dotenv ,且配置如下：
require(&#39;dotenv&#39;).config(); //https://github.com/nuxt-community/proxy-module/issues/3


export default{
    ...
    modules: [
   ...
    // Doc: https://github.com/nuxt-community/dotenv-module
    &#39;@nuxtjs/dotenv&#39;,
    ...
  ],
        ...
}


我这个直接用的ssr，目前还是有个问题就是js包太大，要精简一下。虽然nuxt可以直接搞ssl不用nginx，但是这里443端口被nginx占用了，另外nginx还是比node要强。node+nginx推荐。
也是参考的 https://jonathanmh.com/deploying-a-nuxt-js-app-with-docker/
先直接git clone代码，然后COPY到frontapp容器，然后npm install，build，start【Dockerfile里有配置】。
这里其实可以用volume加载到容器的，我是COPY，反正前端也没啥变化，变化了就又要install build一套，volume问题不大。
因为nuxt开发的.gitignore没有添加static文件夹，所以git clone的时候就有了static文件夹里的文件，就不rsync上传了。
记得nano .env添加 .env文件并配置需要的值。
我配置的就有：
API_URL=&amp;quot;https://api.example.com/api&amp;quot;
NODE_ENV=&amp;quot;production&amp;quot;
AUTH_URL=&amp;quot;https://api.example.com/api/auth&amp;quot;

五、mysql
执行docker cp ./****.sql ***api-db:/tmp/copy到mysql里；
这个容器用的默认的没有bash，只有sh。
一些常用的命令。
mysql -uroot -p
show databases;
use databaseA;
show datatables;
selecr * from datatableA1;
source 打包的地址.sql 【这个用来导入的】
exit
六、nginx
上面提到的petapi.conf和petclient.conf是怎么加载进nginx的呢？
首先这两个通过docker-compose.prod.yml 加载进了容器的 /etc/nginx/conf.d文件夹里，然后
看看nginx.conf文件：
执行docker exec -it pet-nginx sh进到nginx容器，因为没有安装bash所以用sh。
找到nginx.conf打开：
user  nginx;
worker_processes  auto;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
events {
	worker_connections  1024;
}
http {
	include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                      &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                      &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}

注意就是最后一行include /etc/nginx/conf.d/*.conf;引入了这两个conf文件。
同时我们注意权限：
drwxr-xr-x    1 root     root          4096 Jul 18 15:11 ..
drwxrwxr-x    2 1000     1000          4096 Jul 15 16:54 certs
drwxrwxr-x    3 1000     1000          4096 Jul 19 18:06 conf.d
-rw-r--r--    1 root     root          1077 Jul  7 16:14 fastcgi.conf
-rw-r--r--    1 root     root          1007 Jul  7 16:14 fastcgi_params
-rw-r--r--    1 root     root          2837 Jul  7 16:14 koi-utf
-rw-r--r--    1 root     root          2223 Jul  7 16:14 koi-win
-rw-r--r--    1 root     root          5231 Jul  7 16:14 mime.types
lrwxrwxrwx    1 root     root            22 Jul 10 20:27 modules -&amp;gt; /usr/lib/nginx/modules
-rw-r--r--    1 root     root           646 Jul  7 16:14 nginx.conf
-rw-r--r--    1 root     root           636 Jul  7 16:14 scgi_params
-rw-r--r--    1 root     root           664 Jul  7 16:14 uwsgi_params
-rw-r--r--    1 root     root          3610 Jul  7 16:14 win-utf

这里面certs和conf.d文件夹的owner和组都是1000，就是app容器里的用户。里面的文件也是这样的。
drwxr-xr-x    1 root     root          4096 Jul 18 15:11 ..
drwxrwxr-x    2 1000     1000          4096 Jul 15 16:54 certs
-rw-rw-r--    1 1000     1000          1465 Jul 19 18:06 petapi.conf
-rw-rw-r--    1 1000     1000          1709 Jul 18 15:07 petclient.conf

注意这是在nginx容器里了。
对比一看 certs文件夹好像重复了。可以改，这样 注释掉- ./docker-compose/nginx/certs:/etc/nginx/certs
然后把petapi.conf和petclient.conf里加载ssl文件的路径由：
ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;

改为：
ssl_certificate /etc/nginx/conf.d/certs/cert.pem;
ssl_certificate_key /etc/nginx/conf.d/certs/key.pem;

nginx解析代理配置，比如：
location /some/path/ {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://localhost:8000;
}

参考：NGINX Reverse Proxy
还有个Upstream 参考 Securing HTTP Traffic to Upstream Servers
以及 Use NGINX As A Reverse Proxy To Your Containerized Docker Applications
以及 How to set up an easy and secure reverse proxy with Docker, Nginx &amp;amp; Letsencrypt
目前存在的bug：
网站标题没有
privacy没有【已添加页面】，contact么有【不要】，footer没有【已添加】，邮件 【后期申请了服务后更新env文件即可】jwt没配置【已配置】，没开queue【见下方】，recaptcha没配置【已经设置为由env文件配置】。
至于queue，原本打算使用supervisord，但是参考：
[Advice] Best approach to getting Supervisor setup with a docker compose setup?

​	There is no need for supervisor, just add another php service to your file (same volumes) and add a command line with your queue cmd.
php-queue:
 restart: always
 image: php:7.2-fpm
 command: php artisan queue:work
 volumes:
        - ./www:/var/www

这里面restart always就能保证重启维护了。
If I wanted to have multiple works would I just setup multiple php-queue containers? Would I need to be concerned about running to many PHP containers on one server?

If you mean multiple queues then i think that queue:work has a --queue argument so you can specify multiple queues.
If you mean multiple processes then you can use the scale argument in docker-compose, something like:
docker-compose up -d --scale php-queue=3

For Swarm mode you can use the replicas option.
Option --scale webserver=3 will create 3 instances of webserver service (you can choose any number of instances you like)

That is an interesting approach. How would you handle reboots and auto running the command?

Thats what restart: always does, it will restart the container if it crashes and autostarts them on boot. If you are using Swarm then you should use restart-policy instead.

I would spin up an new container for supervisor Just use the same app path
Remember you need an redis also

如果确实需要supervisord可以参考How to keep Laravel Queue system running on server ，也可以考虑使用bash脚本：
Running the Laravel Scheduler and Queue with Docker
所以最后完成版本的docker-composer.prod.yml如下：
七、更新
Updated docker-compose-prod.yml
version: &amp;quot;3.7&amp;quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  php-queue:
    image: php:7.2.19-fpm
    container_name: petapi-app-queue
    command: php artisan queue:work
    working_dir: /var/www/
    restart: always
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin
  nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge

由于进行了一些源代码的更新，特别是前端的代码，所以这里顺带讲解一下以后也可以参考，如何进行更新。
请开始前参考 [Updated docker-compose-prod.yml](#Updated docker-compose-prod.yml) 把docker-compose-prod.yml 更改完毕。
七、（一） SQL数据库迁移
首先是后端api，如果需要大更新特别是涉及到数据库的，sql数据库备份很重要。
两种方式:
第一种，手动【为了走一遍流程】
执行docker exec -it petapi-db bash进入db容器

执行mysql -uroot -p 并输入密码，登录数据库

登录后执行show databases;检查数据库，然后确认我们要备份的数据库

接下来执行exit退出数据库登录，
在db容器shell执行mysqldump -uroot -p ***api &amp;gt; backup.sql 就可以了，格式参考How To Import and Export Databases in MySQL or MariaDB with Docker为：
mysqldump -u username -p database_name &amp;gt; dump.sql  


可以执行head -n 5 backup.sql 检查结果；5不够可以设置20

由于我们的db容器把数据卷设置在了docker-entrypoint-initdb.d文件夹里，所以最好是备份到这文件夹里。这样宿主机备份后，宿主机可以直接拿到，这里我就直接给mv到文件夹里去了。
exit退出容器，然后就可以在宿主机 docker-compose.prod.yml的上下文./docker-compose/mysql文件夹路径里看到我们刚dump打包的数据库备份文件了。

接下来就是参考之前的导入方法导入到新数据库即可。
第二种，使用databack/mysql-backup
建议使用这种方式，因为可以自动执行备份。即使不迁移，平时的运维也应该这么做好备份比较安全。备份完成之后，建议直接发送或上传到库。
七、（二）pull 更新后的laravel api后端代码
其实就是重复操作 三、laravel发布需要准备的文件和生产环境要做的一些操作
七、（三） 前端部分
整体来说可以参考四、nuxt遇到的坑 ，这里当然详细讲解一下。
首先是把代码更新到github。
执行 ssh user_name@server_ip_address登录到服务器。
node的Dockerfile不需要更新了。
我们直接切到 node容器Dockerfile 上下文的路径 ./pet-client下，参考 [docker-compose.prod.yml](#Updated docker-compose-prod.yml)中frontapp部分定义的context:context: ~/petclient/dockerfiles/node/ ，即切换到的路径是~/petclient/dockerfiles/node/pet-client 这里面就是我们前端代码存放的位置了。
在 ~/petclient/dockerfiles/node/这个路径下执行：rm -rf pets-client/删除掉前端代码，因为我们的容器镜像，打包的时候是直接COPY到容器内的。更新的时候，删除这个文件夹，然后稍后删除镜像，重新打包启动即可。
然后执行 git clone https://github.com/****/******.git 把代码拉到宿主机内。如果已经clone过的 可以git pull https://github.com/****/******.git进行update。
然后切换到docker-compose.prod.yml所在文件夹路径下执行: docker-compose -f docker-compose.prod.yml down关闭所有服务。


这个警告是因为我们编辑过docker-compose.prod.yml，但是运行的服务并不是这个编辑过的。以后最好是全部停了之后，再编辑。

接下来执行 docker ps -a查看容器，移除掉旧版本的容器。
接下来执行 docker images查看镜像，然后执行docker rmi 镜像名的方式移除掉node，frontapp镜像，
然后执行docker-compose -f docker-compose.prod.yml build frontapp 构建frontapp的镜像。
构建完成 执行 docker-compose -f docker-compose.prod.yml up -d即可。
容器完全构建好了并启动之后，继续下面的操作。
七、（四）配置.env文件

如果docker-compose.yml文件和Dockerfile提前需要.env文件中设置的值，那此步骤需要在build前操作。
因为后端api是数据卷挂载到容器内的，所以.env文件可以宿主机里编辑。
frontapp是COPY到容器内的，所以需要切换到容器内，或者在build前建立好，build执行的时候直接COPY到容器内了，建议提前在petclient被clone到本地后就编辑好。
如果是需要容器内修改，
执行docker exec -it petclient-frontapp bash进入容器内。
执行 vi .env 然后编辑然后保存退出。

完成。
补充，最好精简一下css 及 js代码。
七、（五）参考Mysql Docker容器关于如何处理down后up数据就丢失的问题以及原理 防止每次重新配置数据库
docker-compose.prod.yml更新为：
version: &amp;quot;3.7&amp;quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  php-queue:
    restart: always
    container_name: petapi-app-queue
    working_dir: /var/www/
    image: php:7.2.19-fpm
    command: php artisan queue:work
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    env_file:
      - ~/petapi/pets-api/.env
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
      - ./docker-compose/mysql/data:/var/lib/mysql
    networks:
      - petapin
  nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge

八、ssl cronJob 与 supervisor介绍

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dzkjz.github.io/post/zong-jie-nuxt-laravel-nginx-mysql-docker-ubuntu-bu-shu-de-liu-cheng/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
    <div class="pagination-container">
        
            <a href="https://dzkjz.github.io/page/3/" class="page-btn btn">上一页</a>
            
                
    </div>
    
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://dzkjz.github.io//images/avatar.png?v=1598896243067)">
        </div>
        <h1 class="id_card-title">
            JojoLegend
        </h1>
        <h2 class="id_card-description">
            Something for age
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://dzkjz.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>