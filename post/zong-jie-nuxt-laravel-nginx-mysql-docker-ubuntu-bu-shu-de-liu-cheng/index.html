<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    总结nuxt laravel nginx mysql docker ubuntu部署的流程 | JojoLegend
</title>
<link rel="shortcut icon" href="https://dzkjz.github.io//favicon.ico?v=1597153927008">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://dzkjz.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://dzkjz.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
            
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
                

                    
                            
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://dzkjz.github.io/">
                <img class="avatar" src="https://dzkjz.github.io//images/avatar.png?v=1597153927008" alt="">
            </a>
            <div class="site-title">
                <h1>
                    JojoLegend
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/vue" class="menu">
                                    Vue
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            总结nuxt laravel nginx mysql docker ubuntu部署的流程
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-07-19</time>
                            
                        </div>
                        
                                <div class="post-content">
                                    <h2 id="一-docker">一、Docker</h2>
<p>什么是docker可以参考:<a href="https://yeasy.gitbook.io/docker_practice/introduction/what">什么是 Docker</a></p>
<p>在进行下面的操作之前，请先<a href="https://yeasy.gitbook.io/docker_practice/install">安装Docker </a></p>
<p>针对这篇文章，我们需要的是：</p>
<ol>
<li>一个容器运行nginx</li>
<li>一个容器运行php-fpm</li>
<li>一个容器运行mysql</li>
<li>一个容器运行node</li>
</ol>
<p>四个容器：</p>
<ul>
<li>
<p>nginx和mysql容器可以直接用官方的镜像。<em>所以这两个容器不需要Dockerfile</em>；</p>
</li>
<li>
<p>php-fpm容器 主要是运行 laravel；</p>
</li>
<li>
<p>另外需要一个临时容器给安装composer，安装完成后删除这个临时容器就行；</p>
</li>
<li>
<p>node容器用于运行nuxt。</p>
</li>
</ul>
<p>php-fpm容器我们需要安装一些扩展包，执行composer安装，所以用Dockerfile配置：</p>
<p>更多Dockerfile配置的指令介绍参考：<a href="https://yeasy.gitbook.io/docker_practice/image/build">使用 Dockerfile 定制镜像</a></p>
<p>请注意教程中的</p>
<blockquote>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p><strong>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</strong></p>
</blockquote>
<p>以及对路径上下文的解释</p>
<blockquote>
<h3 id="镜像构建上下文context"><a href="https://yeasy.gitbook.io/docker_practice/image/build#jing-xiang-gou-jian-shang-xia-wen-context">镜像构建上下文（Context）</a></h3>
<p>这个也是很奇葩的，初学的时候，是单纯的认为 下面这个命令</p>
<p>COPY ./somefiles /var/www</p>
<p>就是复制Dockerfile所在的文件夹下somefiles文件夹及其内部文件到 此镜像构建的容器内的 /var/www目录里。</p>
<p>但是这么理解会出问题，首先，可以用~/sub/fab/docker/somotherfiles/ 这么指定宿主机文件夹路径吗？</p>
<p>答案是不行的。会报错找不到。</p>
<p>然后，那么可以用 ../this/somefiles/指定宿主机文件夹路径吗？</p>
<p>答案也是不行的，也是报错找不到。</p>
<p>具体涉及到的是 Docker 引擎，具体看教程解释，不过可以简单的这么说，就是构建的时候，只打包dockerfile文件路径下的<strong>所有内容</strong>传到docker引擎，所以是不包含外部的以及可以用~指定的路径下的。同时也要注意，这个dockerfile文件打包的所有内容如果你给的文件太大了，那传输起来就牛了，有的几十个GB 传输很头疼的，所以需要注意，dockerfile所在文件夹下的文件内容，只留下需要的。</p>
<p>还有上面是笼统的说成是dockerfile文件所在文件夹，其实也是不完全正确的。</p>
<p>因为可以 -f ../Dockerfilev3 这么指定需要的Dockerfile 首先路径在外面，然后名字也不同，不过一般情况不这么干。默认状态下前面说的不严谨但也可以是对的。还有<a href="https://yeasy.gitbook.io/docker_practice/image/build#qi-ta-docker-build-de-yong-fa">其它 <code>docker build</code> 的用法。</a></p>
</blockquote>
<h5 id="app-容器-dockerfile">app 容器 Dockerfile</h5>
<pre><code class="language-yml">FROM php:7.2.19-fpm #指定 基础镜像

# Arguments defined in docker-compose.yml
ARG user #定义参数
ARG uid  #定义参数

# Install system dependencies 安装系统依赖 #RUN 指令是用来执行命令行命令的
# Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式
RUN apt-get update &amp;&amp; apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip


# Clear cache 清理cache
RUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* #使用 &amp;&amp; 将各个所需命令串联起来

# Install PHP extensions 安装扩展
RUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd

# Get latest Composer 这里是把composer给复制到 本Dockerfile定义的容器的 /usr/bin/composer里
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Create system user to run Composer and Artisan Commands
# 创建系统用户用于执行 composer和 artisan 命令 实际是给权限。
RUN useradd -G www-data,root -u $uid -d /home/$user $user
RUN mkdir -p /home/$user/.composer &amp;&amp; \
    chown -R $user:$user /home/$user

# Set working directory 本容器的工作文件夹
WORKDIR /var/www

USER $user #设置容器的用户

</code></pre>
<blockquote>
<p>需要了解更多指令可以参考：</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy">COPY 复制文件</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/add">ADD 更高级的复制文件</a></p>
<p>[Dockerfile 最佳实践文档](Dockerfile 最佳实践文档)</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/cmd">CMD 容器启动命令</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint">ENTRYPOINT 入口点</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/env">ENV 设置环境变量</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/arg">ARG 构建参数</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/volume">VOLUME 定义匿名卷</a> 上面的dockerfile没有挂载数据卷到容器内，但是我们在docker-compose里挂载了，后面讲。</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/expose">EXPOSE 暴露端口</a> <code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务， 明确 -P随机映射端口时会映射到EXPOSE的端口，-p指定时，是按-p指定的来。</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/workdir">WORKDIR 指定工作目录</a></p>
<p><strong>请注意<code>Dockerfile</code> 构建分层存储的概念。</strong></p>
<p>每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。</p>
<blockquote>
<pre><code class="language-yml">RUN cd /app
RUN echo &quot;hello&quot; &gt; world.txt
</code></pre>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code></p>
<p>第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
</blockquote>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/user">USER 指定当前用户</a></p>
<blockquote>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p><code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
</blockquote>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/healthcheck">HEALTHCHECK 健康检查</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/onbuild">ONBUILD 为他人作嫁衣裳</a></p>
<blockquote>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
</blockquote>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/references">参考文档</a></p>
</blockquote>
<p>laravel运行的php-fpm容器Dockerfile配置好之后，接下来是配置前端nuxt需要的node容器。</p>
<h5 id="node容器dockerfile">node容器Dockerfile</h5>
<pre><code class="language-yml">#使用node:12-alpine 作为基础进行构建
FROM node:12-alpine

#创建/app 目录作为部署目录,创建容器实例时,挂载此目录
RUN mkdir -p /app

#移动工作目录到 /app
WORKDIR /app

#安装 bash 和 busybox
RUN apk update \
        &amp;&amp; apk upgrade \
        &amp;&amp; apk add --no-cache bash \
        bash-doc \
        bash-completion \
        &amp;&amp; /bin/bash \
        &amp;&amp; apk add --no-cache busybox \
        &amp;&amp; rm -rf /var/cache/apk/*

#安装 git
RUN apk add git
		
#设置node环境变量为production
ENV NODE_ENV=production

# copy the app, note .dockerignore
COPY ./pets-client /app
RUN npm install

# build necessary, even if no static files are needed,
# since it builds the server as well
RUN npm run build
RUN npm cache clean --force

# set app serving to permissive / assigned
#ENV NUXT_HOST=0.0.0.0 已经在nuxt.config.js中设置了server block
# set app port
#ENV NUXT_PORT=5000 已经在nuxt.config.js中设置了server block

#设置容器启动时执行的命令
#ENTRYPOINT [ &quot;npm&quot;,&quot;start&quot; ]
CMD [&quot;npm&quot;,&quot;start&quot;]
</code></pre>
<p>Dockerfile部分到此就结束了，接下来，需要了解Docker-Compose</p>
<h2 id="二-docker-compose">二、<a href="https://yeasy.gitbook.io/docker_practice/compose">Docker-Compose</a></h2>
<p>Docker-Compose 是用来管理你的容器的，有点像一个容器的管家，想象一下当你的Docker中有成百上千的容器需要启动，如果一个一个的启动那得多费时间。有了Docker-Compose你只需要编写一个文件，在这个文件里面声明好要启动的容器，配置一些参数，执行一下这个文件，Docker就会按照你声明的配置去把所有的容器启动起来，只需docker-compose up即可启动所有的容器，但是Docker-Compose只能管理当前主机上的Docker，也就是说不能去启动其他主机上的Docker容器。</p>
<p>补充</p>
<blockquote>
<p>Docker Swarm<br>
Docker Swarm 是一款用来管理多主机上的Docker容器的工具，可以负责帮你启动容器，监控容器状态，如果容器的状态不正常它会帮你重新帮你启动一个新的容器，来提供服务，同时也提供服务之间的负载均衡，而这些东西Docker-Compose 是做不到的</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/kubernetes/intro">Kubernetes</a><br>
Kubernetes它本身的角色定位是和Docker Swarm 是一样的，也就是说他们负责的工作在容器领域来说是相同的部分，都是一个跨主机的容器管理平台，当然也有自己一些不一样的特点，k8s是谷歌公司根据自身的多年的运维经验研发的一款容器管理平台。而Docker Swarm则是由Docker 公司研发的。<strong>现在常用Kubernetes</strong></p>
</blockquote>
<p>它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p>本节的安装链接已经有安装教程，安装此处略</p>
<p>给出本次项目的完成版本<code>docker-compose.prod.yml</code></p>
<h4 id="完成版本docker-composeprodyml">完成版本<code>docker-compose.prod.yml</code></h4>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin
  nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge
</code></pre>
<p>接下来细分拆解；</p>
<h3 id="app部分">app部分：</h3>
<pre><code class="language-yml">app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
</code></pre>
<p>这是定义的第一个服务，</p>
<p>app【php】的Dockerfile里，我们定义了两个参数 user 和 uid ，这里进行了赋值。</p>
<p>因为使用build指令，所以必须给到context 和 Dockerfile，这个context即已经在 <a href="#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Context%EF%BC%89">前面提到过的镜像构建上下文。</a></p>
<p>build可以不给context 直接给路径如：<code>build: ./dir</code> 需要注意的格式是 <code>build:[空格]./dir</code> <strong>空格不能少</strong></p>
<p>image 是给这个生成的镜像的名字，如果没有build而是直接给image，docker会去dockerhub官方搜这个包，搜到了就给pull下来。</p>
<p>app 其运行起来的容器名叫petapi-app，这个名字很重要，nginx的conf里，我们会用到这个：</p>
<blockquote>
<pre><code class="language-conf">server {
listen 80;
   listen [::]:80;
   server_name api.example.com;
   return 301 https://$http_host$request_uri;
   #rewrite ^(.*)$ https://$host$1 permanent; we just replace request to https
}
server{
listen 443 ssl;
   listen [::]:443 ssl;
   server_name api.example.com;
   #ssl on; no need this anymore please change use listen 443 ssl only
   ssl_certificate /etc/nginx/certs/cert.pem;
   ssl_certificate_key /etc/nginx/certs/key.pem;
   #ssl_session_timeout 5m;
   #ssl_protocols read blow info please;
   # By default nginx uses “ssl_protocols TLSv1 TLSv1.1 TLSv1.2” and 
#“ssl_ciphers HIGH:!aNULL:!MD5”, so configuring them explicitly is 
#generally not needed.
   index index.php index.html;
   error_log /var/log/nginx/error.log;
   access_log /var/log/nginx/access.log;
   root /var/www/public;
   location ~ \.php$ {
           try_files $uri =404;
           fastcgi_split_path_info ^(.+\.php)(/.+)$;
           fastcgi_pass petapi-app:9000;
           fastcgi_index index.php;
           include fastcgi_params;
           fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
           fastcgi_param PATH_INFO $fastcgi_path_info;
           }
   location / {
            try_files $uri $uri/ /index.php?$query_string;
            gzip_static on;
            }
    }   
</code></pre>
</blockquote>
<p>注意 <code>fastcgi_pass petapi-app:9000;</code> 我们用到了container_name 即这个app容器的名字。9000是默认php-fpm的端口。</p>
<p>其次，我们Dockerfile之前没有设置数据卷，这里设置了加载 <code>docker-compose.prod.yml</code>所在文件夹全部内容 到容器中</p>
<p>restart:  指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p>
<p>networks:  配置容器连接的网络。这个网络主要是给服务容器之间通信的，db我们用的mysql通过这个网络和app通信，nginx也通过这个网络和app通信。这三个公用的 petapin 这个网路，这个网络是在 外层 networks:中定义的。</p>
<p>一般来说，docker -compose 就是：</p>
<pre><code class="language-yml">version: 
services:
networks:
</code></pre>
<p>这三个。<s>networks 的 driver 可以参考 network_mode。</s>  <strong>错啦！networks 应该参考 <a href="https://docs.docker.com/compose/compose-file/#network-configuration-reference">Network configuration reference</a></strong></p>
<p>关于networks和links 请看 <a href="https://docs.docker.com/compose/networking/">Networking in Compose</a></p>
<blockquote>
<p>compose 默认会提供一个network ，每个服务都会加入这个network，且默认互通，它们之间以一个基于容器名生成的名作区分。</p>
<p>一般来说网络名基于项目名【项目基于存放其的文件夹名】</p>
<p>比如说, 假设你的app存放于一个叫<code>myapp</code>的文件夹里, 你的 <code>docker-compose.yml</code> 配置如下:</p>
<pre><code>version: &quot;3&quot;
services:
web:
build: .
ports:
    - &quot;8000:8000&quot;
db:
  image: postgres
  ports:
    - &quot;8001:5432&quot;
</code></pre>
<p>当你执行 <code>docker-compose up</code>,的时候 ，会有如下流程:</p>
<ol>
<li>一个名叫<code>myapp_default</code>的网络被创建 。</li>
<li>使用 <code>web</code>配置创建一个容器. 该容器加入 <code>myapp_default</code> 网络并且赋予一个标识名 <code>web</code>.</li>
<li>使用 <code>db</code>配置创建一个容器.  该容器加入 <code>myapp_default</code> 网络并且赋予一个标识名 db.</li>
</ol>
<p>每一个容器都可以通过标识名<code>web</code>,<code>db</code>查询到这两容器，并获得这两容器的ip地址，比如，web容器里的程序代码可以通过<code>postgres:5342</code>链接到<code>db</code>容器，就可以使用postgres数据库啦。</p>
<p>It is important to note the distinction between <code>HOST_PORT</code> and <code>CONTAINER_PORT</code>. In the above example, for <code>db</code>, the <code>HOST_PORT</code> is <code>8001</code> and the container port is <code>5432</code> (postgres default). Networked service-to-service communication use the <code>CONTAINER_PORT</code>. When <code>HOST_PORT</code> is defined, the service is accessible outside the swarm as well.</p>
<p>Within the <code>web</code> container, your connection string to <code>db</code> would look like <code>postgres://db:5432</code>, and from the host machine, the connection string would look like <code>postgres://{DOCKER_IP}:8001</code>.</p>
<h2 id="links了解就行"><a href="https://docs.docker.com/compose/networking/#links">Links了解就行</a></h2>
<p>这个参考 <a href="https://docs.docker.com/compose/compose-file/#links"><strong>links将会在今后被移除</strong></a>，后期这个没有了，现在了解就行，不推荐使用。</p>
<p>Links allow you to define extra aliases by which a service is reachable from another service. They are not required to enable services to communicate - by default, any service can reach any other service at that service’s name. In the following example, <code>db</code> is reachable from <code>web</code> at the hostnames <code>db</code> and <code>database</code>:</p>
<pre><code>version: &quot;3&quot;
services:

web:
  build: .
  links:
    - &quot;db:database&quot;
db:
  image: postgres
</code></pre>
<p>See the <a href="https://docs.docker.com/compose/compose-file/compose-file-v2/#links">links reference</a> for more information.</p>
<h2 id="networks"><a href="https://docs.docker.com/compose/compose-file/#networks">NETWORKS</a></h2>
<p>我们这里用的就是这个。</p>
</blockquote>
<p>更多的指令参考 <a href="https://yeasy.gitbook.io/docker_practice/compose/compose_file">docker compose 指令</a></p>
<p>frontapp配置参考上面的自己理解，</p>
<h3 id="db部分">db部分：</h3>
<pre><code class="language-yml">  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin
</code></pre>
<p>数据库在这个项目中，存在一个导入的操作，如果以后网站主机迁移，同样也可以打包导入，教程在cnblog有。</p>
<p>数据库部分其余的都没啥好说的，主要是environment里的配置，一般情况下使用的是</p>
<pre><code class="language-yml">environment:
  RACK_ENV: development
  SHOW: 'true'
  SESSION_SECRET:
environment:
  - RACK_ENV=development
  - SHOW=true
  - SESSION_SECRET
</code></pre>
<p>这种赋值格式。</p>
<p>但是<code>${...}</code> 怎么理解？</p>
<blockquote>
<p>You can use environment variables in configuration values with a Bash-like <code>${VARIABLE}</code> syntax - see <a href="https://docs.docker.com/compose/compose-file/#variable-substitution">variable substitution</a> for full details.</p>
<p>就是说，<code>${...}</code>是可以读取设置在<code>.env</code>文件中的值的，但是必须在执行 <code>docker-compose up</code>的时候，如果在执行的时候另行赋值 <code>--name=...</code>会覆盖<code>.env</code>中的值。<code>.env</code>文件中配置的值只在 <code>docker-compose up</code>执行的时候起作用，<code>docker stack deploy</code>不起作用。</p>
<p>其他用法： <code>${VARIABLE:-default}</code>及<code>${VARIABLE-default}</code> 及<code>${VARIABLE:?err}</code>及<code>${VARIABLE?err}</code></p>
</blockquote>
<p>也就是说，上面配置db容器的值，在docker-compose up的时候，读取同目录下.env文件中配置的值。</p>
<h3 id="nginx部分">nginx部分</h3>
<pre><code class="language-yml">nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
</code></pre>
<p>nginx配置中我们使用了两个conf，petapi.conf及 petclient.conf存放于 ./docker-compose/nginx目录下。通过volumes配置，加载到了nginx容器内的/etc/nginx/conf.d文件夹中。</p>
<p>然后是ssl的key.pem和cert.pem文件存放在./docker-compose/nginx/certs文件夹下。通过volumes配置，加载到了nginx容器内的/etc/nginx/certs文件夹内。</p>
<p>为什么配置 ./加载到/var/www文件夹中呢？</p>
<p>我们看看petapi.conf:</p>
<pre><code class="language-conf">server {
   listen 80;
        略...
     }
server{
   listen 443 ssl;
        listen [::]:443 ssl;
        server_name api.example.com;
        ssl_certificate /etc/nginx/certs/cert.pem;
        ssl_certificate_key /etc/nginx/certs/key.pem;
        index index.php index.html;
        error_log /var/log/nginx/error.log;
        access_log /var/log/nginx/access.log;
        root /var/www/public;
        location ~ \.php$ {
                try_files $uri =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass petapi-app:9000;
                fastcgi_index index.php;
                }
        location / {
                 try_files $uri $uri/ /index.php?$query_string;
                 gzip_static on;
                 }
         }
</code></pre>
<p>再看目录结构</p>
<pre><code>drwxrwxr-x 16 ***** *****     4096 Jul 18 15:05 ./
drwxrwxr-x  4 ***** *****      4096 Jul 13 07:09 ../
drwxrwxr-x 11 ***** *****      4096 Jul 12 17:00 app/
-rw-rw-r--  1 ***** *****      1686 Jul 12 17:00 artisan
drwxrwxr-x  3 ***** *****      4096 Jul 12 17:00 bootstrap/ 
-rw-rw-r--  1 ***** *****      1660 Jul 12 17:00 composer.json
-rw-rw-r--  1 ***** *****    208927 Jul 12 17:00 composer.lock
drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 config/
drwxrwxr-x  5 ***** *****      4096 Jul 12 17:00 database/
drwxrwxr-x  4 ***** *****      4096 Jul 16 06:15 docker-compose/
-rw-rw-r--  1 ***** *****      1806 Jul 18 13:06 docker-compose.prod.yml
-rw-rw-r--  1 ***** *****       741 Jul 12 17:12 Dockerfile
drwxrwxr-x  3 ***** *****      4096 Jul 15 18:07 dockerfiles/
-rw-rw-r--  1 ***** *****       220 Jul 12 17:00 .editorconfig
-rw-rw-r--  1 ***** *****       844 Jul 12 18:37 .env
-rw-rw-r--  1 ***** *****       778 Jul 12 17:00 .env.example
drwxrwxr-x  8 ***** *****      4096 Jul 12 17:00 .git/
-rw-rw-r--  1 ***** *****       111 Jul 12 17:00 .gitattributes
-rw-rw-r--  1 ***** *****       163 Jul 12 17:00 .gitignore
drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 .idea/
-rw-rw-r--  1 ***** *****      1013 Jul 12 17:00 package.json
-rw-rw-r--  1 ***** *****    462139 Jul 12 17:00 package-lock.json
-rw-rw-r--  1 ***** *****      1197 Jul 12 17:00 phpunit.xml
drwxrwxr-x  2 ***** *****      4096 Jul 13 14:46 public/
-rw-rw-r--  1 ***** *****      4497 Jul 12 17:00 README.md
drwxrwxr-x  6 ***** *****      4096 Jul 12 17:00 resources/
drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 routes/
-rw-rw-r--  1 ***** *****       563 Jul 12 17:00 server.php
drwxrwxr-x  5 ***** ********   4096 Jul 12 17:00 storage/
-rw-rw-r--  1 ***** *****       174 Jul 12 17:00 .styleci.yml
drwxrwxr-x  4 ***** *****      4096 Jul 12 17:00 tests/
drwxr-xr-x 48 ***** *****      4096 Jul 12 18:28 vendor/
-rw-rw-r--  1 ***** *****       538 Jul 12 17:00 webpack.mix.js
</code></pre>
<p>nginx在 api.example.com:80或443请求的时候，80强制转443，然后看443中处理逻辑。</p>
<p>容器中的<code>root /var/www/public/</code>对应的就是宿主机 public文件夹。</p>
<pre><code>location / {
	try_files $uri $uri/ /index.php?$query_string;
	gzip_static on;
	}
</code></pre>
<p>访问的时候，尝试的是比如	<code>http://api.exampl.com/api/pigs/all/1</code>会解析出uri <code>api/pigs/all/1</code>，这个uri文件在public目录中是没有的。</p>
<p>public目录：</p>
<pre><code>drwxrwxr-x  2 ***** ***** 4096 Jul 13 14:46 ./
drwxrwxr-x 16 ***** ***** 4096 Jul 18 15:05 ../
-rw-rw-r--  1 ***** *****    0 Jul 12 17:00 favicon.ico
-rw-rw-r--  1 ***** *****  603 Jul 12 17:00 .htaccess
-rw-rw-r--  1 ***** ***** 1823 Jul 12 17:00 index.php
-rw-rw-r--  1 ***** *****   24 Jul 12 17:00 robots.txt
lrwxrwxrwx  1 ***** *****   27 Jul 13 14:46 storage -&gt; /var/www/storage/app/public
-rw-rw-r--  1 ***** ***** 1194 Jul 12 17:00 web.config
</code></pre>
<p>所以直接跳解析<code>/index.php?$query_string;</code> 然后$query_string就是<code>api/pigs/all/1</code>，然后就是laravel工作逻辑了。解析出request，parameters...</p>
<p>所以这个加载到nginx中是必要的，如果不用try_files呢【没试过】？那应该就app容器开一个端口[比如12343]，然后nginx使用proxy_pass petapi-app:开的端口号[12343] ，这样就ok了吧。</p>
<p>接下来看看ssl配置，前面说到</p>
<blockquote>
<p>ssl的key.pem和cert.pem文件存放在./docker-compose/nginx/certs文件夹下。通过volumes配置，加载到了nginx容器内的/etc/nginx/certs文件夹内。</p>
</blockquote>
<p>所以ssl部分的配置有：</p>
<pre><code>ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;
</code></pre>
<p>同样的来看看</p>
<p>frontapp部分的conf配置：</p>
<pre><code>server {
listen 80;
listen [::]:80;
server_name example.com www.example.com;
return 301 https://$http_host$request_uri;
#rewrite ^(.*)$ https://$host$1 permanent; we just replace request to https
}
server{
listen 443 ssl;
listen [::]:443 ssl;
server_name example.com www.example.com;
#ssl on; no need this anymore please change use listen 443 ssl only
ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;
#ssl_session_timeout 5m;
#ssl_protocols read blow info please;
# By default nginx uses “ssl_protocols TLSv1 TLSv1.1 TLSv1.2” and 
#“ssl_ciphers HIGH:!aNULL:!MD5”, so configuring them explicitly is generally 
#not needed.
index index.php index.html;
error_log /var/log/nginx/error.log;
access_log /var/log/nginx/access.log;
root /var/www/public;
location ~ \.php$ {
try_files $uri =404;
fastcgi_split_path_info ^(.+\.php)(/.+)$;
fastcgi_pass frontapp:9000;
fastcgi_index index.php;
include fastcgi_params;
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
fastcgi_param PATH_INFO $fastcgi_path_info;
}
location / {
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host  $http_host;
proxy_set_header X-Nginx-Proxy true;
proxy_set_header Connection &quot;&quot;;
proxy_pass http://frontapp:8000; #因为在nuxt中 server配置就这个
gzip_static on;
}
}
</code></pre>
<p>与petapi.conf不同的就是</p>
<pre><code>location / {
                proxy_set_header X-Real-IP $remote_addr;
				proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
				proxy_set_header Host  $http_host;
				proxy_set_header X-Nginx-Proxy true;
				proxy_set_header Connection &quot;&quot;;
				proxy_pass http://frontapp:8000; #因为在nuxt中 server配置就这个
                gzip_static on;
                }
</code></pre>
<p>proxy_pass一定是 http://开头+ip+:+端口，</p>
<p>ip用了容器参数，这也是为啥nginx容器的depends_on设置了app和frontapp两个容器，因为要用啊。</p>
<p>端口设置为8000是因为nuxt中<code>nuxt.config.js</code>值为：</p>
<pre><code class="language-js">  server: {
    port: 8000, // default: 3000
    host: '0.0.0.0', // default: localhost,
    timing: false
    // timing: {
    //   total: true
    // }
  },
</code></pre>
<p>端口给设置了8000，node的<a href="#node%E5%AE%B9%E5%99%A8Dockerfile">Dockerfile</a>我们也就没有开端口了。</p>
<p>如果给docker-compose.prod.yml加一个</p>
<pre><code class="language-yml">  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    ports:
     - 800:8000
    networks:
      - petclientn
</code></pre>
<p>注意其中</p>
<pre><code class="language-yml">    ports:
     - 800:8000
</code></pre>
<p>加上了就可以通过宿主机ip[当前环境下就是服务器ip]:8000直接访问nuxt应用。我们这里不用，只是说原理如此。但是如果你给开个443端口访问这个8000端口，会不行，会报端口已经被(就是nginx容器)占用。</p>
<p>docker-compose.prod.yml配置完了，然后执行 <code>docker-compose -f docker-compose.prod.yml build app frontapp</code>给爷生成这两容器的镜像出来。生成完了 执行 <code>docker-compose -f docker-compose.prod.yml up -d</code>就可以跑起来了。执行命令切换到 docker-compose.prod.yml文件的目录下，这样-f指定免得给一串长的地址。</p>
<h2 id="三-laravel发布需要准备的文件和生产环境要做的一些操作">三、laravel发布需要准备的文件和生产环境要做的一些操作</h2>
<p>laravel的代码，我是直接git clone 下来然后进到app容器里</p>
<p>执行</p>
<p><code>cp .env.example .env</code> .env文件。</p>
<p>特别注意</p>
<pre><code>APP_ENV=production
APP_DEBUG=false
APP_URL
</code></pre>
<p><code>php artisan key:generate</code> 生成key</p>
<p>然后自己配置.env文件中的值，mail啊 jwt啊 mysql之类的。</p>
<p><code>php artisan migrate</code> 数据库</p>
<p>然后就是进入db数据库容器，检查用户，表，导入打包的数据库。</p>
<p>接着就是把storage里的文件用rsync给传到服务器[宿主机]的laravel存放文件夹里的storage对应的文件夹里。</p>
<p>再在app容器执行</p>
<p><code>php artisan storage:link</code></p>
<p>然后就可以用了。</p>
<p><code>php artisan optimize</code></p>
<p>至于邮件，需要开启queue，以及<a href="https://medium.com/@ahmeeddhon/laravel-docker-using-alpine-1f80fab7359b">supervisor</a>。【暂缺】【不用supervisor也可以开启queue并确保不service down 参考<a href="#%E4%B8%83%E3%80%81%E6%9B%B4%E6%96%B0">更新部分</a> 】</p>
<h2 id="四-nuxt遇到的坑">四、nuxt遇到的坑</h2>
<p>如果有代码用到了</p>
<p><code>target: (process.env.NODE_ENV === &quot;production&quot;) ? process.env.API_URL : &quot;http://petapi.test/api&quot;,</code></p>
<p>这样的，那env文件必须要有。否则必然报target null 类型错误。</p>
<p>还要安装<a href="https://github.com/nuxt-community/dotenv-module">dotenv</a> ,且配置如下：</p>
<pre><code class="language-js">require('dotenv').config(); //https://github.com/nuxt-community/proxy-module/issues/3


export default{
    ...
    modules: [
   ...
    // Doc: https://github.com/nuxt-community/dotenv-module
    '@nuxtjs/dotenv',
    ...
  ],
        ...
}

</code></pre>
<p>我这个直接用的ssr，目前还是有个问题就是js包太大，要精简一下。虽然nuxt可以直接搞ssl不用nginx，但是这里443端口被nginx占用了，另外nginx还是比node要强。node+nginx推荐。</p>
<p>也是参考的 https://jonathanmh.com/deploying-a-nuxt-js-app-with-docker/</p>
<p>先直接git clone代码，然后COPY到frontapp容器，然后npm install，build，start【<a href="#node%E5%AE%B9%E5%99%A8Dockerfile">Dockerfile里有配置</a>】。</p>
<p>这里其实可以用volume加载到容器的，我是COPY，反正前端也没啥变化，变化了就又要install build一套，volume问题不大。</p>
<p>因为nuxt开发的.gitignore没有添加static文件夹，所以git clone的时候就有了static文件夹里的文件，就不rsync上传了。</p>
<p>记得nano .env添加 .env文件并配置需要的值。</p>
<p>我配置的就有：</p>
<pre><code class="language-env">API_URL=&quot;https://api.example.com/api&quot;
NODE_ENV=&quot;production&quot;
AUTH_URL=&quot;https://api.example.com/api/auth&quot;
</code></pre>
<h2 id="五-mysql">五、mysql</h2>
<p>执行<code>docker cp ./****.sql ***api-db:/tmp/</code>copy到mysql里；</p>
<p>这个容器用的默认的没有bash，只有sh。</p>
<p>一些常用的命令。</p>
<p>mysql -uroot -p</p>
<p>show databases;</p>
<p>use databaseA;</p>
<p>show datatables;</p>
<p>selecr * from datatableA1;</p>
<p>source 打包的地址.sql 【这个用来导入的】</p>
<p>exit</p>
<h2 id="六-nginx">六、nginx</h2>
<p>上面提到的petapi.conf和petclient.conf是怎么加载进nginx的呢？</p>
<p>首先这两个通过<a href="#%E5%AE%8C%E6%88%90%E7%89%88%E6%9C%AC%60docker-compose.prod.yml%60">docker-compose.prod.yml</a> 加载进了容器的 /etc/nginx/conf.d文件夹里，然后</p>
<p>看看nginx.conf文件：</p>
<p>执行<code>docker exec -it pet-nginx sh</code>进到nginx容器，因为没有安装bash所以用sh。</p>
<p>找到nginx.conf打开：</p>
<pre><code class="language-conf">user  nginx;
worker_processes  auto;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
events {
	worker_connections  1024;
}
http {
	include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
</code></pre>
<p>注意就是最后一行<code>include /etc/nginx/conf.d/*.conf;</code>引入了这两个conf文件。</p>
<p>同时我们注意权限：</p>
<pre><code class="language-drwxr-xr-x">drwxr-xr-x    1 root     root          4096 Jul 18 15:11 ..
drwxrwxr-x    2 1000     1000          4096 Jul 15 16:54 certs
drwxrwxr-x    3 1000     1000          4096 Jul 19 18:06 conf.d
-rw-r--r--    1 root     root          1077 Jul  7 16:14 fastcgi.conf
-rw-r--r--    1 root     root          1007 Jul  7 16:14 fastcgi_params
-rw-r--r--    1 root     root          2837 Jul  7 16:14 koi-utf
-rw-r--r--    1 root     root          2223 Jul  7 16:14 koi-win
-rw-r--r--    1 root     root          5231 Jul  7 16:14 mime.types
lrwxrwxrwx    1 root     root            22 Jul 10 20:27 modules -&gt; /usr/lib/nginx/modules
-rw-r--r--    1 root     root           646 Jul  7 16:14 nginx.conf
-rw-r--r--    1 root     root           636 Jul  7 16:14 scgi_params
-rw-r--r--    1 root     root           664 Jul  7 16:14 uwsgi_params
-rw-r--r--    1 root     root          3610 Jul  7 16:14 win-utf
</code></pre>
<p>这里面certs和conf.d文件夹的owner和组都是1000，就是app容器里的用户。里面的文件也是这样的。</p>
<pre><code class="language-drwxrwxr-x">drwxr-xr-x    1 root     root          4096 Jul 18 15:11 ..
drwxrwxr-x    2 1000     1000          4096 Jul 15 16:54 certs
-rw-rw-r--    1 1000     1000          1465 Jul 19 18:06 petapi.conf
-rw-rw-r--    1 1000     1000          1709 Jul 18 15:07 petclient.conf
</code></pre>
<p><strong>注意这是在nginx容器里了。</strong></p>
<p>对比一看 certs文件夹好像重复了。可以改，这样 注释掉<code>- ./docker-compose/nginx/certs:/etc/nginx/certs</code></p>
<p>然后把petapi.conf和petclient.conf里加载ssl文件的路径由：</p>
<pre><code class="language-conf">ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;
</code></pre>
<p>改为：</p>
<pre><code class="language-yml">ssl_certificate /etc/nginx/conf.d/certs/cert.pem;
ssl_certificate_key /etc/nginx/conf.d/certs/key.pem;
</code></pre>
<p>nginx解析代理配置，比如：</p>
<pre><code class="language-conf">location /some/path/ {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://localhost:8000;
}
</code></pre>
<p>参考：<a href="https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/">NGINX Reverse Proxy</a></p>
<p>还有个Upstream 参考 <a href="https://docs.nginx.com/nginx/admin-guide/security-controls/securing-http-traffic-upstream/">Securing HTTP Traffic to Upstream Servers</a></p>
<p>以及 <a href="https://www.thepolyglotdeveloper.com/2017/03/nginx-reverse-proxy-containerized-docker-applications/">Use NGINX As A Reverse Proxy To Your Containerized Docker Applications</a></p>
<p>以及 <a href="https://www.freecodecamp.org/news/docker-nginx-letsencrypt-easy-secure-reverse-proxy-40165ba3aee2/">How to set up an easy and secure reverse proxy with Docker, Nginx &amp; Letsencrypt</a></p>
<h4 id="目前存在的bug">目前存在的bug：</h4>
<p>网站标题没有<img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/%E6%89%B9%E6%B3%A8%202020-07-20%20141957.png" alt="批注 2020-07-20 141957" loading="lazy"></p>
<p>privacy没有【已添加页面】，contact么有【不要】，footer没有【已添加】，邮件 【后期申请了服务后更新env文件即可】jwt没配置【已配置】，没开queue【见下方】，recaptcha没配置【已经设置为由env文件配置】。</p>
<p>至于queue，原本打算使用supervisord，但是参考：</p>
<p><a href="https://www.reddit.com/r/docker/comments/8zlakh/advice_best_approach_to_getting_supervisor_setup/">[Advice] Best approach to getting Supervisor setup with a docker compose setup?</a></p>
<blockquote>
<p>​	There is no need for supervisor, just add another php service to your file (same volumes) and add a command line with your queue cmd.</p>
<pre><code class="language-yml">php-queue:
 restart: always
 image: php:7.2-fpm
 command: php artisan queue:work
 volumes:
        - ./www:/var/www
</code></pre>
<p>这里面restart always就能保证重启维护了。</p>
<p>If I wanted to have multiple works would I just setup multiple <code>php-queue</code> containers? Would I need to be concerned about running to many PHP containers on one server?</p>
<blockquote>
<p>If you mean multiple queues then i think that queue:work has a --queue argument so you can specify multiple queues.</p>
<p>If you mean multiple processes then you can use the <code>scale</code> argument in docker-compose, something like:</p>
<pre><code>docker-compose up -d --scale php-queue=3
</code></pre>
<p>For Swarm mode you can use the <a href="https://docs.docker.com/compose/compose-file/#replicas"><code>replicas</code></a> option.</p>
<p><a href="https://github.com/maitrungduc1410/docker-laravel-horizon-load-balancing">Option --scale webserver=3 will create 3 instances of <code>webserver</code> service (you can choose any number of instances you like)</a></p>
</blockquote>
<p>That is an interesting approach. How would you handle reboots and auto running the command?</p>
<blockquote>
<p>Thats what <a href="https://docs.docker.com/compose/compose-file/#restart"><code>restart: always</code></a> does, it will restart the container if it crashes and autostarts them on boot. If you are using Swarm then you should use <a href="https://docs.docker.com/compose/compose-file/#restart_policy">restart-policy</a> instead.</p>
</blockquote>
<p>I would spin up an new container for supervisor Just use the same app path</p>
<p>Remember you need an redis also</p>
</blockquote>
<p>如果确实需要supervisord可以参考<a href="https://stackoverflow.com/a/57353086">How to keep Laravel Queue system running on server</a> ，也可以考虑使用bash脚本：<br>
<a href="https://laravel-news.com/laravel-scheduler-queue-docker">Running the Laravel Scheduler and Queue with Docker</a></p>
<p>所以最后完成版本的docker-composer.prod.yml如下：</p>
<h2 id="七-更新">七、更新</h2>
<h3 id="updated-docker-compose-prodyml">Updated docker-compose-prod.yml</h3>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  php-queue:
    image: php:7.2.19-fpm
    container_name: petapi-app-queue
    command: php artisan queue:work
    working_dir: /var/www/
    restart: always
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin
  nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge
</code></pre>
<p>由于进行了一些源代码的更新，特别是前端的代码，所以这里顺带讲解一下以后也可以参考，如何进行更新。</p>
<p>请开始前参考 [Updated docker-compose-prod.yml](#Updated docker-compose-prod.yml) 把<code>docker-compose-prod.yml</code> 更改完毕。</p>
<h3 id="七-一-sql数据库迁移">七、（一） SQL数据库迁移</h3>
<p>首先是后端api，如果需要大更新特别是涉及到数据库的，sql数据库备份很重要。</p>
<p>两种方式:</p>
<h5 id="第一种手动为了走一遍流程">第一种，手动【为了走一遍流程】</h5>
<p>执行<code>docker exec -it petapi-db bash</code>进入db容器</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724023050297.png" alt="image-20200724023050297" loading="lazy"></figure>
<p>执行<code>mysql -uroot -p</code> 并输入密码，登录数据库</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724023113362.png" alt="" loading="lazy"></figure>
<p>登录后执行<code>show databases;</code>检查数据库，然后确认我们要备份的数据库</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724023211774.png" alt="" loading="lazy"></figure>
<p>接下来执行<code>exit</code>退出数据库登录，</p>
<p>在db容器shell执行<code>mysqldump -uroot -p ***api &gt; backup.sql</code> 就可以了，格式参考<a href="https://blog.shanelee.name/2017/04/09/how-to-import-and-export-databases-in-mysql-or-mariadb-with-docker/">How To Import and Export Databases in MySQL or MariaDB with Docker</a>为：</p>
<pre><code class="language-bash">mysqldump -u username -p database_name &gt; dump.sql  
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724023446387.png" alt="" loading="lazy"></figure>
<p>可以执行<code>head -n 5 backup.sql</code> 检查结果；<code>5</code>不够可以设置<code>20</code></p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724023737718.png" alt="" loading="lazy"></figure>
<p>由于我们的db容器把数据卷设置在了<code>docker-entrypoint-initdb.d</code>文件夹里，所以最好是备份到这文件夹里。这样宿主机备份后，宿主机可以直接拿到，这里我就直接给mv到文件夹里去了。</p>
<p><code>exit</code>退出容器，然后就可以在宿主机 <code>docker-compose.prod.yml</code>的上下文<code>./docker-compose/mysql</code>文件夹路径里看到我们刚dump打包的数据库备份文件了。</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724024534310.png" alt="" loading="lazy"></figure>
<p>接下来就是<a href="#%E4%BA%94%E3%80%81mysql">参考之前的导入方法</a>导入到新数据库即可。</p>
<h5 id="第二种使用databackmysql-backup">第二种，使用<a href="https://hub.docker.com/r/databack/mysql-backup">databack/mysql-backup</a></h5>
<p>建议使用这种方式，因为可以自动执行备份。即使不迁移，平时的运维也应该这么做好备份比较安全。备份完成之后，建议直接发送或上传到库。</p>
<h3 id="七-二pull-更新后的laravel-api后端代码">七、（二）pull 更新后的laravel api后端代码</h3>
<p>其实就是重复操作 <a href="#%E4%B8%89%E3%80%81laravel%E5%8F%91%E5%B8%83%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%A6%81%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C">三、laravel发布需要准备的文件和生产环境要做的一些操作</a></p>
<h3 id="七-三-前端部分">七、（三） 前端部分</h3>
<p>整体来说可以参考<a href="#%E5%9B%9B%E3%80%81nuxt%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91">四、nuxt遇到的坑</a> ，这里当然详细讲解一下。</p>
<p>首先是把代码更新到github。</p>
<p>执行 <code>ssh user_name@server_ip_address</code>登录到服务器。</p>
<p>node的Dockerfile不需要更新了。</p>
<p>我们直接切到 <a href="#node%E5%AE%B9%E5%99%A8Dockerfile">node容器Dockerfile</a> 上下文的路径 <code>./pet-client</code>下，参考 [<code>docker-compose.prod.yml</code>](#Updated docker-compose-prod.yml)中frontapp部分定义的context:<code>context: ~/petclient/dockerfiles/node/</code> ，即切换到的路径是<code>~/petclient/dockerfiles/node/pet-client</code> 这里面就是我们前端代码存放的位置了。</p>
<p>在 <code>~/petclient/dockerfiles/node/</code>这个路径下执行：<code>rm -rf pets-client/</code>删除掉前端代码，因为我们的容器镜像，打包的时候是直接COPY到容器内的。更新的时候，删除这个文件夹，然后稍后删除镜像，重新打包启动即可。</p>
<p>然后执行 <code>git clone https://github.com/****/******.git</code> 把代码拉到宿主机内。如果已经clone过的 可以<code>git pull https://github.com/****/******.git</code>进行update。</p>
<p>然后切换到<code>docker-compose.prod.yml</code>所在文件夹路径下执行: <code>docker-compose -f docker-compose.prod.yml down</code>关闭所有服务。</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724141740430.png" alt="" loading="lazy"></figure>
<blockquote>
<p>这个警告是因为我们编辑过<code>docker-compose.prod.yml</code>，但是运行的服务并不是这个编辑过的。以后最好是全部停了之后，再编辑。</p>
</blockquote>
<p>接下来执行 <code>docker ps -a</code>查看容器，移除掉旧版本的容器。</p>
<p>接下来执行 <code>docker images</code>查看镜像，然后执行<code>docker rmi 镜像名</code>的方式移除掉node，frontapp镜像，</p>
<p>然后执行<code>docker-compose -f docker-compose.prod.yml build frontapp</code> 构建frontapp的镜像。</p>
<p>构建完成 执行 <code>docker-compose -f docker-compose.prod.yml up -d</code>即可。</p>
<p>容器完全构建好了并启动之后，继续下面的操作。</p>
<h3 id="七-四配置env文件">七、（四）配置.env文件</h3>
<blockquote>
<p><strong>如果docker-compose.yml文件和Dockerfile提前需要.env文件中设置的值，那此步骤需要在build前操作。</strong></p>
<p>因为后端api是数据卷挂载到容器内的，所以.env文件可以宿主机里编辑。</p>
<p>frontapp是COPY到容器内的，所以需要切换到容器内，或者<strong>在build前建立好，build执行的时候直接COPY到容器内了</strong>，建议提前在petclient被clone到本地后就编辑好。</p>
<p>如果是需要容器内修改，</p>
<p>执行<code>docker exec -it petclient-frontapp bash</code>进入容器内。</p>
<p>执行 vi .env 然后编辑然后保存退出。</p>
</blockquote>
<p>完成。</p>
<p>补充，最好精简一下css 及 js代码。</p>
<h3 id="七-五参考mysql-docker容器关于如何处理down后up数据就丢失的问题以及原理-防止每次重新配置数据库">七、（五）参考<a href="https://dzkjz.github.io/post/mysql-docker-rong-qi-guan-yu-ru-he-chu-li-down-hou-up-shu-ju-jiu-diu-shi-de-wen-ti-yi-ji-yuan-li/">Mysql Docker容器关于如何处理down后up数据就丢失的问题以及原理</a> 防止每次重新配置数据库</h3>
<p><code>docker-compose.prod.yml</code>更新为：</p>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  php-queue:
    restart: always
    container_name: petapi-app-queue
    working_dir: /var/www/
    image: php:7.2.19-fpm
    command: php artisan queue:work
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    env_file:
      - ~/petapi/pets-api/.env
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
      - ./docker-compose/mysql/data:/var/lib/mysql
    networks:
      - petapin
  nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge
</code></pre>
<h2 id="八-ssl-cronjob-与-supervisor介绍">八、ssl cronJob 与 supervisor介绍</h2>

                                </div>
                    </article>
                    <!--  -->
                    
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-docker">一、Docker</a>
<ul>
<li><a href="#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87context">镜像构建上下文（Context）</a><br>
*
<ul>
<li><a href="#app-%E5%AE%B9%E5%99%A8-dockerfile">app 容器 Dockerfile</a></li>
<li><a href="#node%E5%AE%B9%E5%99%A8dockerfile">node容器Dockerfile</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C-docker-compose">二、Docker-Compose</a><br>
*
<ul>
<li><a href="#%E5%AE%8C%E6%88%90%E7%89%88%E6%9C%ACdocker-composeprodyml">完成版本<code>docker-compose.prod.yml</code></a></li>
<li><a href="#app%E9%83%A8%E5%88%86">app部分：</a></li>
</ul>
</li>
<li><a href="#links%E4%BA%86%E8%A7%A3%E5%B0%B1%E8%A1%8C">Links了解就行</a></li>
<li><a href="#networks">NETWORKS</a>
<ul>
<li><a href="#db%E9%83%A8%E5%88%86">db部分：</a></li>
<li><a href="#nginx%E9%83%A8%E5%88%86">nginx部分</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-laravel%E5%8F%91%E5%B8%83%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%A6%81%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C">三、laravel发布需要准备的文件和生产环境要做的一些操作</a></li>
<li><a href="#%E5%9B%9B-nuxt%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91">四、nuxt遇到的坑</a></li>
<li><a href="#%E4%BA%94-mysql">五、mysql</a></li>
<li><a href="#%E5%85%AD-nginx">六、nginx</a><br>
*
<ul>
<li><a href="#%E7%9B%AE%E5%89%8D%E5%AD%98%E5%9C%A8%E7%9A%84bug">目前存在的bug：</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E6%9B%B4%E6%96%B0">七、更新</a>
<ul>
<li><a href="#updated-docker-compose-prodyml">Updated docker-compose-prod.yml</a></li>
<li><a href="#%E4%B8%83-%E4%B8%80-sql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB">七、（一） SQL数据库迁移</a><br>
*
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%89%8B%E5%8A%A8%E4%B8%BA%E4%BA%86%E8%B5%B0%E4%B8%80%E9%81%8D%E6%B5%81%E7%A8%8B">第一种，手动【为了走一遍流程】</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E4%BD%BF%E7%94%A8databackmysql-backup">第二种，使用databack/mysql-backup</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E4%BA%8Cpull-%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84laravel-api%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81">七、（二）pull 更新后的laravel api后端代码</a></li>
<li><a href="#%E4%B8%83-%E4%B8%89-%E5%89%8D%E7%AB%AF%E9%83%A8%E5%88%86">七、（三） 前端部分</a></li>
<li><a href="#%E4%B8%83-%E5%9B%9B%E9%85%8D%E7%BD%AEenv%E6%96%87%E4%BB%B6">七、（四）配置.env文件</a></li>
<li><a href="#%E4%B8%83-%E4%BA%94%E5%8F%82%E8%80%83mysql-docker%E5%AE%B9%E5%99%A8%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86down%E5%90%8Eup%E6%95%B0%E6%8D%AE%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86-%E9%98%B2%E6%AD%A2%E6%AF%8F%E6%AC%A1%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93">七、（五）参考Mysql Docker容器关于如何处理down后up数据就丢失的问题以及原理 防止每次重新配置数据库</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-ssl-cronjob-%E4%B8%8E-supervisor%E4%BB%8B%E7%BB%8D">八、ssl cronJob 与 supervisor介绍</a></li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://dzkjz.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
        
            <script>
    window.onload = function() {
        var gitalk = new Gitalk({
            clientID: 'b067c4f3d31f7962c097',
            clientSecret: '3c8e8557b958738414c4edabfec529ca9c29bfe9',
            repo: 'https://dzkjz.github.io/',
            owner: 'dzkjz',
            admin: ['dzkjz'],
            id: (location.pathname).substring(0, 49), // Ensure uniqueness and length less than 50
            distractionFreeMode: false // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    }
</script>
                

                    
                                
</body>

</html>