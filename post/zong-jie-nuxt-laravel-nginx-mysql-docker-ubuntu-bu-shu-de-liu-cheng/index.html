<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>总结nuxt laravel nginx mysql docker ubuntu部署的流程 | JojoLegend</title>
<link rel="shortcut icon" href="https://dzkjz.github.io//favicon.ico?v=1595226593977">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://dzkjz.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="总结nuxt laravel nginx mysql docker ubuntu部署的流程 | JojoLegend - Atom Feed" href="https://dzkjz.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="总结分为几个部分：


docker


docker-compose


注意事项


laravel发布需要准备的文件和生产环境要做的一些操作


nuxt遇到的坑


mysql


nginx


一、Docker
什么是docke..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dzkjz.github.io/">
  <img class="avatar" src="https://dzkjz.github.io//images/avatar.png?v=1595226593977" alt="">
  </a>
  <h1 class="site-title">
    JojoLegend
  </h1>
  <p class="site-description">
    Something for age
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              总结nuxt laravel nginx mysql docker ubuntu部署的流程
            </h2>
            <div class="post-info">
              <span>
                2020-07-19
              </span>
              <span>
                30 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>总结分为几个部分：</p>
<ol>
<li>
<p>docker</p>
</li>
<li>
<p>docker-compose</p>
</li>
<li>
<p>注意事项</p>
</li>
<li>
<p>laravel发布需要准备的文件和生产环境要做的一些操作</p>
</li>
<li>
<p>nuxt遇到的坑</p>
</li>
<li>
<p>mysql</p>
</li>
<li>
<p>nginx</p>
</li>
</ol>
<h2 id="一-docker">一、Docker</h2>
<p>什么是docker可以参考:<a href="https://yeasy.gitbook.io/docker_practice/introduction/what">什么是 Docker</a></p>
<p>在进行下面的操作之前，请先<a href="https://yeasy.gitbook.io/docker_practice/install">安装Docker </a></p>
<p>针对这篇文章，我们需要的是：</p>
<ol>
<li>一个容器运行nginx</li>
<li>一个容器运行php-fpm</li>
<li>一个容器运行mysql</li>
<li>一个容器运行node</li>
</ol>
<p>四个容器：</p>
<ul>
<li>
<p>nginx和mysql容器可以直接用官方的镜像。<em>所以这两个容器不需要Dockerfile</em>；</p>
</li>
<li>
<p>php-fpm容器 主要是运行 laravel；</p>
</li>
<li>
<p>另外需要一个临时容器给安装composer，安装完成后删除这个临时容器就行；</p>
</li>
<li>
<p>node容器用于运行nuxt。</p>
</li>
</ul>
<p>php-fpm容器我们需要安装一些扩展包，执行composer安装，所以用Dockerfile配置：</p>
<p>更多Dockerfile配置的指令介绍参考：<a href="https://yeasy.gitbook.io/docker_practice/image/build">使用 Dockerfile 定制镜像</a></p>
<p>请注意教程中的</p>
<blockquote>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p><strong>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</strong></p>
</blockquote>
<p>以及对路径上下文的解释</p>
<blockquote>
<h3 id="镜像构建上下文context"><a href="https://yeasy.gitbook.io/docker_practice/image/build#jing-xiang-gou-jian-shang-xia-wen-context">镜像构建上下文（Context）</a></h3>
<p>这个也是很奇葩的，初学的时候，是单纯的认为 下面这个命令</p>
<p>COPY ./somefiles /var/www</p>
<p>就是复制Dockerfile所在的文件夹下somefiles文件夹及其内部文件到 此镜像构建的容器内的 /var/www目录里。</p>
<p>但是这么理解会出问题，首先，可以用~/sub/fab/docker/somotherfiles/ 这么指定宿主机文件夹路径吗？</p>
<p>答案是不行的。会报错找不到。</p>
<p>然后，那么可以用 ../this/somefiles/指定宿主机文件夹路径吗？</p>
<p>答案也是不行的，也是报错找不到。</p>
<p>具体涉及到的是 Docker 引擎，具体看教程解释，不过可以简单的这么说，就是构建的时候，只打包dockerfile文件路径下的<strong>所有内容</strong>传到docker引擎，所以是不包含外部的以及可以用~指定的路径下的。同时也要注意，这个dockerfile文件打包的所有内容如果你给的文件太大了，那传输起来就牛了，有的几十个GB 传输很头疼的，所以需要注意，dockerfile所在文件夹下的文件内容，只留下需要的。</p>
<p>还有上面是笼统的说成是dockerfile文件所在文件夹，其实也是不完全正确的。</p>
<p>因为可以 -f ../Dockerfilev3 这么指定需要的Dockerfile 首先路径在外面，然后名字也不同，不过一般情况不这么干。默认状态下前面说的不严谨但也可以是对的。还有<a href="https://yeasy.gitbook.io/docker_practice/image/build#qi-ta-docker-build-de-yong-fa">其它 <code>docker build</code> 的用法。</a></p>
</blockquote>
<pre><code class="language-yml">FROM php:7.2.19-fpm #指定 基础镜像

# Arguments defined in docker-compose.yml
ARG user #定义参数
ARG uid  #定义参数

# Install system dependencies 安装系统依赖 #RUN 指令是用来执行命令行命令的
# Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式
RUN apt-get update &amp;&amp; apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip


# Clear cache 清理cache
RUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* #使用 &amp;&amp; 将各个所需命令串联起来

# Install PHP extensions 安装扩展
RUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd

# Get latest Composer 这里是把composer给复制到 本Dockerfile定义的容器的 /usr/bin/composer里
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Create system user to run Composer and Artisan Commands
# 创建系统用户用于执行 composer和 artisan 命令 实际是给权限。
RUN useradd -G www-data,root -u $uid -d /home/$user $user
RUN mkdir -p /home/$user/.composer &amp;&amp; \
    chown -R $user:$user /home/$user

# Set working directory 本容器的工作文件夹
WORKDIR /var/www

USER $user #设置容器的用户

</code></pre>
<blockquote>
<p>需要了解更多指令可以参考：</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy">COPY 复制文件</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/add">ADD 更高级的复制文件</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">Dockerfile 最佳实践文档</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/cmd">CMD 容器启动命令</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint">ENTRYPOINT 入口点</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/env">ENV 设置环境变量</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/arg">ARG 构建参数</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/volume">VOLUME 定义匿名卷</a> 上面的dockerfile没有挂载数据卷到容器内，但是我们在docker-compose里挂载了，后面讲。</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/expose">EXPOSE 暴露端口</a> <code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务， 明确 -P随机映射端口时会映射到EXPOSE的端口，-p指定时，是按-p指定的来。</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/workdir">WORKDIR 指定工作目录</a></p>
<p><strong>请注意<code>Dockerfile</code> 构建分层存储的概念。</strong></p>
<p>每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。</p>
<blockquote>
<pre><code class="language-yml">RUN cd /app
RUN echo &quot;hello&quot; &gt; world.txt
</code></pre>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code></p>
<p>第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
</blockquote>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/user">USER 指定当前用户</a></p>
<blockquote>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p><code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
</blockquote>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/healthcheck">HEALTHCHECK 健康检查</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/onbuild">ONBUILD 为他人作嫁衣裳</a></p>
<blockquote>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
</blockquote>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/references">参考文档</a></p>
</blockquote>
<p>laravel运行的php-fpm容器Dockerfile配置好之后，接下来是配置前端nuxt需要的node容器。</p>
<h5 id="node容器dockerfile">node容器Dockerfile</h5>
<pre><code class="language-yml">#使用node:12-alpine 作为基础进行构建
FROM node:12-alpine

#创建/app 目录作为部署目录,创建容器实例时,挂载此目录
RUN mkdir -p /app

#移动工作目录到 /app
WORKDIR /app

#安装 bash 和 busybox
RUN apk update \
        &amp;&amp; apk upgrade \
        &amp;&amp; apk add --no-cache bash \
        bash-doc \
        bash-completion \
        &amp;&amp; /bin/bash \
        &amp;&amp; apk add --no-cache busybox \
        &amp;&amp; rm -rf /var/cache/apk/*

#安装 git
RUN apk add git
		
#设置node环境变量为production
ENV NODE_ENV=production

# copy the app, note .dockerignore
COPY ./pets-client /app
RUN npm install

# build necessary, even if no static files are needed,
# since it builds the server as well
RUN npm run build
RUN npm cache clean --force

# set app serving to permissive / assigned
#ENV NUXT_HOST=0.0.0.0 已经在nuxt.config.js中设置了server block
# set app port
#ENV NUXT_PORT=5000 已经在nuxt.config.js中设置了server block

#设置容器启动时执行的命令
#ENTRYPOINT [ &quot;npm&quot;,&quot;start&quot; ]
CMD [&quot;npm&quot;,&quot;start&quot;]
</code></pre>
<p>Dockerfile部分到此就结束了，接下来，需要了解Docker-Compose</p>
<h2 id="二-docker-compose">二、<a href="https://yeasy.gitbook.io/docker_practice/compose">Docker-Compose</a></h2>
<p>Docker-Compose 是用来管理你的容器的，有点像一个容器的管家，想象一下当你的Docker中有成百上千的容器需要启动，如果一个一个的启动那得多费时间。有了Docker-Compose你只需要编写一个文件，在这个文件里面声明好要启动的容器，配置一些参数，执行一下这个文件，Docker就会按照你声明的配置去把所有的容器启动起来，只需docker-compose up即可启动所有的容器，但是Docker-Compose只能管理当前主机上的Docker，也就是说不能去启动其他主机上的Docker容器。</p>
<p>补充</p>
<blockquote>
<p>Docker Swarm<br>
Docker Swarm 是一款用来管理多主机上的Docker容器的工具，可以负责帮你启动容器，监控容器状态，如果容器的状态不正常它会帮你重新帮你启动一个新的容器，来提供服务，同时也提供服务之间的负载均衡，而这些东西Docker-Compose 是做不到的</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/kubernetes/intro">Kubernetes</a><br>
Kubernetes它本身的角色定位是和Docker Swarm 是一样的，也就是说他们负责的工作在容器领域来说是相同的部分，都是一个跨主机的容器管理平台，当然也有自己一些不一样的特点，k8s是谷歌公司根据自身的多年的运维经验研发的一款容器管理平台。而Docker Swarm则是由Docker 公司研发的。<strong>现在常用Kubernetes</strong></p>
</blockquote>
<p>它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p>本节的安装链接已经有安装教程，安装此处略</p>
<p>给出本次项目的完成版本<code>docker-compose.prod.yml</code></p>
<h4 id="完成版本docker-composeprodyml">完成版本<code>docker-compose.prod.yml</code></h4>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin
  nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge
</code></pre>
<p>接下来细分拆解；</p>
<h3 id="app部分">app部分：</h3>
<pre><code class="language-yml">app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
</code></pre>
<p>这是定义的第一个服务，</p>
<p>app【php】的Dockerfile里，我们定义了两个参数 user 和 uid ，这里进行了赋值。</p>
<p>因为使用build指令，所以必须给到context 和 Dockerfile，这个context即已经在 <a href="#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Context%EF%BC%89">前面提到过的镜像构建上下文。</a></p>
<p>build可以不给context 直接给路径如：<code>build: ./dir</code> 需要注意的格式是 <code>build:[空格]./dir</code> <strong>空格不能少</strong></p>
<p>image 是给这个生成的镜像的名字，如果没有build而是直接给image，docker会去dockerhub官方搜这个包，搜到了就给pull下来。</p>
<p>app 其运行起来的容器名叫petapi-app，这个名字很重要，nginx的conf里，我们会用到这个：</p>
<blockquote>
<pre><code class="language-conf">server {
listen 80;
   listen [::]:80;
   server_name api.example.com;
   return 301 https://$http_host$request_uri;
   #rewrite ^(.*)$ https://$host$1 permanent; we just replace request to https
}
server{
listen 443 ssl;
   listen [::]:443 ssl;
   server_name api.example.com;
   #ssl on; no need this anymore please change use listen 443 ssl only
   ssl_certificate /etc/nginx/certs/cert.pem;
   ssl_certificate_key /etc/nginx/certs/key.pem;
   #ssl_session_timeout 5m;
   #ssl_protocols read blow info please;
   # By default nginx uses “ssl_protocols TLSv1 TLSv1.1 TLSv1.2” and “ssl_ciphers HIGH:!aNULL:!MD5”, so configuring them explicitly is generally not needed.
   index index.php index.html;
   error_log /var/log/nginx/error.log;
   access_log /var/log/nginx/access.log;
   root /var/www/public;
   location ~ \.php$ {
           try_files $uri =404;
           fastcgi_split_path_info ^(.+\.php)(/.+)$;
           fastcgi_pass petapi-app:9000;
           fastcgi_index index.php;
           include fastcgi_params;
           fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
           fastcgi_param PATH_INFO $fastcgi_path_info;
           }
   location / {
            try_files $uri $uri/ /index.php?$query_string;
            gzip_static on;
            }
    }   
</code></pre>
</blockquote>
<pre><code> 注意 `fastcgi_pass petapi-app:9000;` 我们用到了container_name 即这个app容器的名字。9000是默认php-fpm的端口。
</code></pre>
<p>其次，我们Dockerfile之前没有设置数据卷，这里设置了加载 <code>docker-compose.prod.yml</code>所在文件夹全部内容 到容器中</p>
<p>restart:  指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p>
<p>networks:  配置容器连接的网络。这个网络主要是给服务容器之间通信的，db我们用的mysql通过这个网络和app通信，nginx也通过这个网络和app通信。这三个公用的 petapin 这个网路，这个网络是在 外层 networks:中定义的。</p>
<p>一般来说，docker -compose 就是：</p>
<pre><code class="language-yml">version: 
services:
networks:
</code></pre>
<p>这三个。<s>networks 的 driver 可以参考 network_mode。</s>  <strong>错啦！networks 应该参考 <a href="https://docs.docker.com/compose/compose-file/#network-configuration-reference">Network configuration reference</a></strong></p>
<p>关于networks和links 请看 <a href="https://docs.docker.com/compose/networking/">Networking in Compose</a></p>
<blockquote>
<p>compose 默认会提供一个network ，每个服务都会加入这个network，且默认互通，它们之间以一个基于容器名生成的名作区分。</p>
<p>一般来说网络名基于项目名【项目基于存放其的文件夹名】</p>
<p>比如说, 假设你的app存放于一个叫<code>myapp</code>的文件夹里, 你的 <code>docker-compose.yml</code> 配置如下:</p>
<pre><code>version: &quot;3&quot;
services:
web:
build: .
ports:
    - &quot;8000:8000&quot;
db:
  image: postgres
  ports:
    - &quot;8001:5432&quot;
</code></pre>
<p>当你执行 <code>docker-compose up</code>,的时候 ，会有如下流程:</p>
<ol>
<li>一个名叫<code>myapp_default</code>的网络被创建 。</li>
<li>使用 <code>web</code>配置创建一个容器. 该容器加入 <code>myapp_default</code> 网络并且赋予一个标识名 <code>web</code>.</li>
<li>使用 <code>db</code>配置创建一个容器.  该容器加入 <code>myapp_default</code> 网络并且赋予一个标识名 db.</li>
</ol>
<p>每一个容器都可以通过标识名<code>web</code>,<code>db</code>查询到这两容器，并获得这两容器的ip地址，比如，web容器里的程序代码可以通过<code>postgres:5342</code>链接到<code>db</code>容器，就可以使用postgres数据库啦。</p>
<p>It is important to note the distinction between <code>HOST_PORT</code> and <code>CONTAINER_PORT</code>. In the above example, for <code>db</code>, the <code>HOST_PORT</code> is <code>8001</code> and the container port is <code>5432</code> (postgres default). Networked service-to-service communication use the <code>CONTAINER_PORT</code>. When <code>HOST_PORT</code> is defined, the service is accessible outside the swarm as well.</p>
<p>Within the <code>web</code> container, your connection string to <code>db</code> would look like <code>postgres://db:5432</code>, and from the host machine, the connection string would look like <code>postgres://{DOCKER_IP}:8001</code>.</p>
<h2 id="links了解就行"><a href="https://docs.docker.com/compose/networking/#links">Links了解就行</a></h2>
<p>这个参考 <a href="https://docs.docker.com/compose/compose-file/#links"><strong>links将会在今后被移除</strong></a>，后期这个没有了，现在了解就行，不推荐使用。</p>
<p>Links allow you to define extra aliases by which a service is reachable from another service. They are not required to enable services to communicate - by default, any service can reach any other service at that service’s name. In the following example, <code>db</code> is reachable from <code>web</code> at the hostnames <code>db</code> and <code>database</code>:</p>
<pre><code>version: &quot;3&quot;
services:

web:
  build: .
  links:
    - &quot;db:database&quot;
db:
  image: postgres
</code></pre>
<p>See the <a href="https://docs.docker.com/compose/compose-file/compose-file-v2/#links">links reference</a> for more information.</p>
<h2 id="networks"><a href="https://docs.docker.com/compose/compose-file/#networks">NETWORKS</a></h2>
<p>我们这里用的就是这个。</p>
</blockquote>
<p>更多的指令参考 <a href="https://yeasy.gitbook.io/docker_practice/compose/compose_file">docker compose 指令</a></p>
<p>frontapp配置参考上面的自己理解，</p>
<h3 id="db部分">db部分：</h3>
<pre><code class="language-yml">  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin
</code></pre>
<p>数据库在这个项目中，存在一个导入的操作，如果以后网站主机迁移，同样也可以打包导入，教程在cnblog有。</p>
<p>数据库部分其余的都没啥好说的，主要是environment里的配置，一般情况下使用的是</p>
<pre><code class="language-yml">environment:
  RACK_ENV: development
  SHOW: 'true'
  SESSION_SECRET:
environment:
  - RACK_ENV=development
  - SHOW=true
  - SESSION_SECRET
</code></pre>
<p>这种赋值格式。</p>
<p>但是<code>${...}</code> 怎么理解？</p>
<blockquote>
<p>You can use environment variables in configuration values with a Bash-like <code>${VARIABLE}</code> syntax - see <a href="https://docs.docker.com/compose/compose-file/#variable-substitution">variable substitution</a> for full details.</p>
<p>就是说，<code>${...}</code>是可以读取设置在<code>.env</code>文件中的值的，但是必须在执行 <code>docker-compose up</code>的时候，如果在执行的时候另行赋值 <code>--name=...</code>会覆盖<code>.env</code>中的值。<code>.env</code>文件中配置的值只在 <code>docker-compose up</code>执行的时候起作用，<code>docker stack deploy</code>不起作用。</p>
<p>其他用法： <code>${VARIABLE:-default}</code>及<code>${VARIABLE-default}</code> 及<code>${VARIABLE:?err}</code>及<code>${VARIABLE?err}</code></p>
</blockquote>
<p>也就是说，上面配置db容器的值，在docker-compose up的时候，读取同目录下.env文件中配置的值。</p>
<h3 id="nginx部分">nginx部分</h3>
<pre><code class="language-yml">nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
</code></pre>
<p>nginx配置中我们使用了两个conf，petapi.conf及 petclient.conf存放于 ./docker-compose/nginx目录下。通过volumes配置，加载到了nginx容器内的/etc/nginx/conf.d文件夹中。</p>
<p>然后是ssl的key.pem和cert.pem文件存放在./docker-compose/nginx/certs文件夹下。通过volumes配置，加载到了nginx容器内的/etc/nginx/certs文件夹内。</p>
<p>为什么配置 ./加载到/var/www文件夹中呢？</p>
<p>我们看看petapi.conf:</p>
<pre><code class="language-conf">server {
   listen 80;
        略...
     }
server{
   listen 443 ssl;
        listen [::]:443 ssl;
        server_name api.example.com;
        ssl_certificate /etc/nginx/certs/cert.pem;
        ssl_certificate_key /etc/nginx/certs/key.pem;
        index index.php index.html;
        error_log /var/log/nginx/error.log;
        access_log /var/log/nginx/access.log;
        root /var/www/public;
        location ~ \.php$ {
                try_files $uri =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass petapi-app:9000;
                fastcgi_index index.php;
                }
        location / {
                 try_files $uri $uri/ /index.php?$query_string;
                 gzip_static on;
                 }
         }
</code></pre>
<p>再看目录结构</p>
<pre><code>drwxrwxr-x 16 ***** *****     4096 Jul 18 15:05 ./                                         drwxrwxr-x  4 ***** *****      4096 Jul 13 07:09 ../                                         drwxrwxr-x 11 ***** *****      4096 Jul 12 17:00 app/                                       -rw-rw-r--  1 ***** *****      1686 Jul 12 17:00 artisan                                     drwxrwxr-x  3 ***** *****      4096 Jul 12 17:00 bootstrap/                                 -rw-rw-r--  1 ***** *****      1660 Jul 12 17:00 composer.json                               -rw-rw-r--  1 ***** *****    208927 Jul 12 17:00 composer.lock                               drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 config/                                     drwxrwxr-x  5 ***** *****      4096 Jul 12 17:00 database/                                   drwxrwxr-x  4 ***** *****      4096 Jul 16 06:15 docker-compose/                             -rw-rw-r--  1 ***** *****      1806 Jul 18 13:06 docker-compose.prod.yml                     -rw-rw-r--  1 ***** *****       741 Jul 12 17:12 Dockerfile                                 drwxrwxr-x  3 ***** *****      4096 Jul 15 18:07 dockerfiles/                               -rw-rw-r--  1 ***** *****       220 Jul 12 17:00 .editorconfig                               -rw-rw-r--  1 ***** *****       844 Jul 12 18:37 .env                                       -rw-rw-r--  1 ***** *****       778 Jul 12 17:00 .env.example                               drwxrwxr-x  8 ***** *****      4096 Jul 12 17:00 .git/                                       -rw-rw-r--  1 ***** *****       111 Jul 12 17:00 .gitattributes                             -rw-rw-r--  1 ***** *****       163 Jul 12 17:00 .gitignore                                 drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 .idea/                                     -rw-rw-r--  1 ***** *****      1013 Jul 12 17:00 package.json                               -rw-rw-r--  1 ***** *****    462139 Jul 12 17:00 package-lock.json                           -rw-rw-r--  1 ***** *****      1197 Jul 12 17:00 phpunit.xml                                 drwxrwxr-x  2 ***** *****      4096 Jul 13 14:46 public/
-rw-rw-r--  1 ***** *****      4497 Jul 12 17:00 README.md
drwxrwxr-x  6 ***** *****      4096 Jul 12 17:00 resources/
drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 routes/
-rw-rw-r--  1 ***** *****       563 Jul 12 17:00 server.php
drwxrwxr-x  5 ***** ********   4096 Jul 12 17:00 storage/
-rw-rw-r--  1 ***** *****       174 Jul 12 17:00 .styleci.yml
drwxrwxr-x  4 ***** *****      4096 Jul 12 17:00 tests/
drwxr-xr-x 48 ***** *****      4096 Jul 12 18:28 vendor/
-rw-rw-r--  1 ***** *****       538 Jul 12 17:00 webpack.mix.js
</code></pre>
<p>nginx在 api.example.com:80或443请求的时候，80强制转443，然后看443中处理逻辑。</p>
<p>容器中的<code>root /var/www/public/</code>对应的就是宿主机 public文件夹。</p>
<pre><code>location / {
                 try_files $uri $uri/ /index.php?$query_string;
                 gzip_static on;
                 }
         }
</code></pre>
<p>访问的时候，尝试的是比如	<code>http://api.exampl.com/api/pigs/all/1</code>会解析出uri <code>api/pigs/all/1</code>，这个uri文件在public目录中是没有的。</p>
<p>public目录：</p>
<pre><code>drwxrwxr-x  2 ***** ***** 4096 Jul 13 14:46 ./                                               drwxrwxr-x 16 ***** ***** 4096 Jul 18 15:05 ../                                             -rw-rw-r--  1 ***** *****    0 Jul 12 17:00 favicon.ico                                     -rw-rw-r--  1 ***** *****  603 Jul 12 17:00 .htaccess
-rw-rw-r--  1 ***** ***** 1823 Jul 12 17:00 index.php
-rw-rw-r--  1 ***** *****   24 Jul 12 17:00 robots.txt
lrwxrwxrwx  1 ***** *****   27 Jul 13 14:46 storage -&gt; /var/www/storage/app/public
-rw-rw-r--  1 ***** ***** 1194 Jul 12 17:00 web.config
</code></pre>
<p>所以直接跳解析<code>/index.php?$query_string;</code> 然后$query_string就是<code>api/pigs/all/1</code>，然后就是laravel工作逻辑了。解析出request，parameters...</p>
<p>所以这个加载到nginx中是必要的，如果不用try_files呢【没试过】？那应该就app容器开一个端口[比如12343]，然后nginx使用proxy_pass petapi-app:开的端口号[12343] ，这样就ok了吧。</p>
<p>接下来看看ssl配置，前面说到</p>
<blockquote>
<p>ssl的key.pem和cert.pem文件存放在./docker-compose/nginx/certs文件夹下。通过volumes配置，加载到了nginx容器内的/etc/nginx/certs文件夹内。</p>
</blockquote>
<p>所以ssl部分的配置有：</p>
<pre><code>ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;
</code></pre>
<p>同样的来看看</p>
<p>frontapp部分的conf配置：</p>
<pre><code>server {
        listen 80;
        listen [::]:80;
        server_name example.com www.example.com;
        return 301 https://$http_host$request_uri;
        #rewrite ^(.*)$ https://$host$1 permanent; we just replace request to https
}
server{
        listen 443 ssl;
        listen [::]:443 ssl;
        server_name example.com www.example.com;
        #ssl on; no need this anymore please change use listen 443 ssl only
        ssl_certificate /etc/nginx/certs/cert.pem;
        ssl_certificate_key /etc/nginx/certs/key.pem;
        #ssl_session_timeout 5m;
        #ssl_protocols read blow info please;
        # By default nginx uses “ssl_protocols TLSv1 TLSv1.1 TLSv1.2” and “ssl_ciphers HIGH:!aNULL:!MD5”, so configuring them explicitly is generally not needed.
        index index.php index.html;
        error_log /var/log/nginx/error.log;
        access_log /var/log/nginx/access.log;
        root /var/www/public;
        location ~ \.php$ {
                try_files $uri =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass frontapp:9000;
                fastcgi_index index.php;
                include fastcgi_params;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_path_info;
                }

        location / {
                proxy_set_header X-Real-IP $remote_addr;
				proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
				proxy_set_header Host  $http_host;
				proxy_set_header X-Nginx-Proxy true;
				proxy_set_header Connection &quot;&quot;;
				proxy_pass http://frontapp:8000; #因为在nuxt中 server配置就这个
                gzip_static on;
                }
        }
</code></pre>
<p>与petapi.conf不同的就是</p>
<pre><code>location / {
                proxy_set_header X-Real-IP $remote_addr;
				proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
				proxy_set_header Host  $http_host;
				proxy_set_header X-Nginx-Proxy true;
				proxy_set_header Connection &quot;&quot;;
				proxy_pass http://frontapp:8000; #因为在nuxt中 server配置就这个
                gzip_static on;
                }
</code></pre>
<p>proxy_pass一定是 http://开头+ip+:+端口，</p>
<p>ip用了容器参数，这也是为啥nginx容器的depends_on设置了app和frontapp两个容器，因为要用啊。</p>
<p>端口设置为8000是因为nuxt中<code>nuxt.config.js</code>值为：</p>
<pre><code class="language-js">  server: {
    port: 8000, // default: 3000
    host: '0.0.0.0', // default: localhost,
    timing: false
    // timing: {
    //   total: true
    // }
  },
</code></pre>
<p>端口给设置了8000，node的<a href="#node%E5%AE%B9%E5%99%A8Dockerfile">Dockerfile</a>我们也就没有开端口了。</p>
<p>如果给docker-compose.prod.yml加一个</p>
<pre><code class="language-yml">  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    ports:
     - 800:8000
    networks:
      - petclientn
</code></pre>
<p>注意其中</p>
<pre><code class="language-yml">    ports:
     - 800:8000
</code></pre>
<p>加上了就可以通过宿主机ip[当前环境下就是服务器ip]:8000直接访问nuxt应用。我们这里不用，只是说原理如此。但是如果你给开个443端口访问这个8000端口，会不行，会报端口已经被(就是nginx容器)占用。</p>
<p>docker-compose.prod.yml配置完了，然后执行 <code>docker-compose -f docker-compose.prod.yml build app frontapp</code>给爷生成这两容器的镜像出来。生成完了 执行 <code>docker-compose -f docker-compose.prod.yml up -d</code>就可以跑起来了。执行命令切换到 docker-compose.prod.yml文件的目录下，这样-f指定免得给一串长的地址。</p>
<h2 id="三-laravel发布需要准备的文件和生产环境要做的一些操作">三、laravel发布需要准备的文件和生产环境要做的一些操作</h2>
<p>laravel的代码，我是直接git clone 下来然后进到app容器里</p>
<p>执行</p>
<p><code>cp .env.example .env</code> .env文件。</p>
<p><code>php artisan key:generate</code> 生成key</p>
<p>然后自己配置.env文件中的值，mail啊 jwt啊 mysql之类的。</p>
<p><code>php artisan migrate</code> 数据库</p>
<p>然后就是进入db数据库容器，检查用户，表，导入打包的数据库。</p>
<p>接着就是把storage里的文件用rsync给传到服务器[宿主机]的laravel存放文件夹里的storage对应的文件夹里。</p>
<p>再在app容器执行</p>
<p><code>php artisan storage:link</code></p>
<p>然后就可以用了。</p>
<p>至于邮件，需要开启queue，以及supervisor。【暂缺】</p>
<h2 id="四-nuxt遇到的坑">四、nuxt遇到的坑</h2>
<p>如果有代码用到了</p>
<pre><code class="language-js"> target: (process.env.NODE_ENV === &quot;production&quot;) ? process.env.API_URL : &quot;http://petapi.test/api&quot;,
</code></pre>
<p>这样的，那env文件必须要有。否则必然报target null 类型错误。</p>
<p>还要安装<a href="https://github.com/nuxt-community/dotenv-module">dotenv</a> ,且配置如下：</p>
<pre><code class="language-js">require('dotenv').config(); //https://github.com/nuxt-community/proxy-module/issues/3


export default{
    ...
    modules: [
   ...
    // Doc: https://github.com/nuxt-community/dotenv-module
    '@nuxtjs/dotenv',
    ...
  ],
        ...
}

</code></pre>
<p>我这个直接用的ssr，目前还是有个问题就是js包太大，要精简一下。虽然nuxt可以直接搞ssl不用nginx，但是这里443端口被nginx占用了，另外nginx还是比node要强。node+nginx推荐。</p>
<p>也是参考的 https://jonathanmh.com/deploying-a-nuxt-js-app-with-docker/</p>
<p>先直接git clone代码，然后COPY到frontapp容器，然后npm install，build，start【<a href="#node%E5%AE%B9%E5%99%A8Dockerfile">Dockerfile里有配置</a>】。</p>
<p>这里其实可以用volume加载到容器的，我是COPY，反正前端也没啥变化，变化了就又要install build一套，volume问题不大。</p>
<p>因为nuxt开发的.gitignore没有添加static文件夹，所以git clone的时候就有了static文件夹里的文件，就不rsync上传了。</p>
<p>记得nano .env添加 .env文件并配置需要的值。</p>
<p>我配置的就有：</p>
<pre><code class="language-env">API_URL=&quot;https://api.example.com/api&quot;
NODE_ENV=&quot;production&quot;
AUTH_URL=&quot;https://api.example.com/api/auth&quot;
</code></pre>
<h2 id="五-mysql">五、mysql</h2>
<p>这个容器用的默认的没有bash，只有sh。</p>
<p>一些常用的命令。</p>
<p>mysql -uroot -p</p>
<p>show databases;</p>
<p>use databaseA;</p>
<p>show datatables;</p>
<p>selecr * from datatableA1;</p>
<p>source 打包的地址.sql 【这个用来导入的】</p>
<p>exit</p>
<h2 id="六-nginx">六、nginx</h2>
<p>上面提到的petapi.conf和petclient.conf是怎么加载进nginx的呢？</p>
<p>首先这两个通过<a href="#%E5%AE%8C%E6%88%90%E7%89%88%E6%9C%AC%60docker-compose.prod.yml%60">docker-compose.prod.yml</a> 加载进了容器的 /etc/nginx/conf.d文件夹里，然后</p>
<p>看看nginx.conf文件：</p>
<p>执行<code>docker exec -it pet-nginx sh</code>进到nginx容器，因为没有安装bash所以用sh。</p>
<p>找到nginx.conf打开：</p>
<pre><code class="language-conf">user  nginx;                                                                                 worker_processes  auto;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
events {
	worker_connections  1024;
}
http {
	include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
</code></pre>
<p>注意就是最后一行<code>include /etc/nginx/conf.d/*.conf;</code>引入了这两个conf文件。</p>
<p>同时我们注意权限：</p>
<pre><code class="language-drwxr-xr-x">drwxr-xr-x    1 root     root          4096 Jul 18 15:11 ..
drwxrwxr-x    2 1000     1000          4096 Jul 15 16:54 certs
drwxrwxr-x    3 1000     1000          4096 Jul 19 18:06 conf.d
-rw-r--r--    1 root     root          1077 Jul  7 16:14 fastcgi.conf
-rw-r--r--    1 root     root          1007 Jul  7 16:14 fastcgi_params
-rw-r--r--    1 root     root          2837 Jul  7 16:14 koi-utf
-rw-r--r--    1 root     root          2223 Jul  7 16:14 koi-win
-rw-r--r--    1 root     root          5231 Jul  7 16:14 mime.types
lrwxrwxrwx    1 root     root            22 Jul 10 20:27 modules -&gt; /usr/lib/nginx/modules
-rw-r--r--    1 root     root           646 Jul  7 16:14 nginx.conf
-rw-r--r--    1 root     root           636 Jul  7 16:14 scgi_params
-rw-r--r--    1 root     root           664 Jul  7 16:14 uwsgi_params
-rw-r--r--    1 root     root          3610 Jul  7 16:14 win-utf
</code></pre>
<p>这里面certs和conf.d文件夹的owner和组都是1000，就是app容器里的用户。里面的文件也是这样的。</p>
<pre><code class="language-drwxrwxr-x">drwxr-xr-x    1 root     root          4096 Jul 18 15:11 ..
drwxrwxr-x    2 1000     1000          4096 Jul 15 16:54 certs
-rw-rw-r--    1 1000     1000          1465 Jul 19 18:06 petapi.conf
-rw-rw-r--    1 1000     1000          1709 Jul 18 15:07 petclient.conf
</code></pre>
<p><strong>注意这是在nginx容器里了。</strong></p>
<p>对比一看 certs文件夹好像重复了。可以改，这样 注释掉<code>- ./docker-compose/nginx/certs:/etc/nginx/certs</code></p>
<p>然后把petapi.conf和petclient.conf里加载ssl文件的路径由：</p>
<pre><code class="language-conf">ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;
</code></pre>
<p>改为：</p>
<pre><code class="language-yml">ssl_certificate /etc/nginx/conf.d/certs/cert.pem;
ssl_certificate_key /etc/nginx/conf.d/certs/key.pem;
</code></pre>
<p>nginx解析代理配置，比如：</p>
<pre><code class="language-conf">location /some/path/ {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://localhost:8000;
}
</code></pre>
<p>参考：<a href="https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/">NGINX Reverse Proxy</a></p>
<p>还有个Upstream 参考 <a href="https://docs.nginx.com/nginx/admin-guide/security-controls/securing-http-traffic-upstream/">Securing HTTP Traffic to Upstream Servers</a></p>
<p>以及 <a href="https://www.thepolyglotdeveloper.com/2017/03/nginx-reverse-proxy-containerized-docker-applications/">Use NGINX As A Reverse Proxy To Your Containerized Docker Applications</a></p>
<p>以及 <a href="https://www.freecodecamp.org/news/docker-nginx-letsencrypt-easy-secure-reverse-proxy-40165ba3aee2/">How to set up an easy and secure reverse proxy with Docker, Nginx &amp; Letsencrypt</a></p>
<h2 id="最后目前存在的bug">最后，目前存在的bug：</h2>
<p>网站标题没有<img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/%E6%89%B9%E6%B3%A8%202020-07-20%20141957.png" alt="批注 2020-07-20 141957" loading="lazy"></p>
<p>privacy没有，contact么有，footer没有，邮件 jwt没配置，没开queue，recaptcha没配置。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-docker">一、Docker</a>
<ul>
<li><a href="#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87context">镜像构建上下文（Context）</a><br>
*
<ul>
<li><a href="#node%E5%AE%B9%E5%99%A8dockerfile">node容器Dockerfile</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C-docker-compose">二、Docker-Compose</a><br>
*
<ul>
<li><a href="#%E5%AE%8C%E6%88%90%E7%89%88%E6%9C%ACdocker-composeprodyml">完成版本<code>docker-compose.prod.yml</code></a></li>
<li><a href="#app%E9%83%A8%E5%88%86">app部分：</a></li>
</ul>
</li>
<li><a href="#links%E4%BA%86%E8%A7%A3%E5%B0%B1%E8%A1%8C">Links了解就行</a></li>
<li><a href="#networks">NETWORKS</a>
<ul>
<li><a href="#db%E9%83%A8%E5%88%86">db部分：</a></li>
<li><a href="#nginx%E9%83%A8%E5%88%86">nginx部分</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-laravel%E5%8F%91%E5%B8%83%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%A6%81%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C">三、laravel发布需要准备的文件和生产环境要做的一些操作</a></li>
<li><a href="#%E5%9B%9B-nuxt%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91">四、nuxt遇到的坑</a></li>
<li><a href="#%E4%BA%94-mysql">五、mysql</a></li>
<li><a href="#%E5%85%AD-nginx">六、nginx</a></li>
<li><a href="#%E6%9C%80%E5%90%8E%E7%9B%AE%E5%89%8D%E5%AD%98%E5%9C%A8%E7%9A%84bug">最后，目前存在的bug：</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dzkjz.github.io/post/hello-gridea/">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'b067c4f3d31f7962c097',
    clientSecret: '3c8e8557b958738414c4edabfec529ca9c29bfe9',
    repo: 'https://dzkjz.github.io/',
    owner: 'dzkjz',
    admin: ['dzkjz'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://dzkjz.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
