<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dzkjz.github.io/</id>
    <title>JojoLegend</title>
    <updated>2020-08-31T07:44:14.640Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dzkjz.github.io/"/>
    <link rel="self" href="https://dzkjz.github.io/atom.xml"/>
    <subtitle>Something for age</subtitle>
    <logo>https://dzkjz.github.io/images/avatar.png</logo>
    <icon>https://dzkjz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JojoLegend</rights>
    <entry>
        <title type="html"><![CDATA[Laravel Collection 学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-collection-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-collection-xue-xi-ti-gang/">
        </link>
        <updated>2020-08-31T07:43:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学习，文档上介绍的功能在什么时候可以用？用来做什么？具体的用法请查看官方文档</strong></p>
</blockquote>
<ol>
<li>
<p>Collection主要是用来提供更方便的方法处理array数据的；</p>
</li>
<li>
<p>并且collection里方法都是返回一个新的collection实例，意味着可以写出面条代码，而原来的底层数据就不会被修改，就会完整的保留下来。</p>
</li>
<li>
<p>Eloquent查询的结果基本上也是返回的collection实例。</p>
</li>
</ol>
<blockquote>
<p>Collection有很多的方法，查看官方文档<a href="https://laravel.com/docs/7.x/collections#available-methods">Available Methods</a></p>
</blockquote>
<h3 id="higher-order-messages">Higher Order Messages</h3>
<blockquote>
<p>平时的方法：</p>
<pre><code class="language-php">$users = User::where('votes', '&gt;', 500)-&gt;get();

$users-&gt;each(function($item,$key){
    $item-&gt;markAsVip();
});
</code></pre>
<p>如each：</p>
<pre><code class="language-php">$users = User::where('votes', '&gt;', 500)-&gt;get();

$users-&gt;each-&gt;markAsVip();
</code></pre>
</blockquote>
<h3 id="lazycollection">LazyCollection</h3>
<p>对于需要读取大文件，数据量比较大的数据【10万条Eloquent模型数据】到collection里面，可以用LazyCollection，底层主要是PHP yield，这样不用一次性读取完到内存，而是一次一取一读。</p>
<blockquote>
<p>如果10万条数据一次用这种方式读取，那内存占用太大了：</p>
<pre><code class="language-php">$users = App\User::all()-&gt;filter(function ($user) {
 return $user-&gt;id &gt; 500;
});
</code></pre>
<p>Eloquent有一个cursor方法返回的是LazyCollection实例，一次读取一条，这样内存不会卡爆：</p>
<blockquote>
<pre><code class="language-php">$users = App\User::cursor()-&gt;filter(function ($user) {
return $user-&gt;id &gt; 500;
});

foreach ($users as $user) {
echo $user-&gt;id;
}
</code></pre>
</blockquote>
<p>当然，filter方法并不会在foreach之前就执行，而是在foreach中每次迭代的时候执行。</p>
</blockquote>
<p>LazyCollection 有2个与Collection不同的方法可以看下官方文档<a href="https://laravel.com/docs/7.x/collections#lazy-collection-methods">Lazy Collection Methods</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Cache学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-cache-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-cache-xue-xi-ti-gang/">
        </link>
        <updated>2020-08-30T14:47:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学：文档上介绍的功能在什么情况下使用，有什么作用？</strong></p>
</blockquote>
<blockquote>
<p>一般建议使用<code>Memcached</code>或者<code>Redis</code>。</p>
</blockquote>
<h3 id="cache使用方法">Cache使用方法</h3>
<blockquote>
<p>Cache的增删改查具体使用方法，请查看官方文档。</p>
<p>利用Mock方式进行Cache测试的时候，需要调用<code>Cache::shouldReceive</code>方法提供值。</p>
</blockquote>
<h3 id="cache-tags">Cache Tags</h3>
<p>给一堆的Cache值分组打标签需用到<code>Cache Tags</code>。</p>
<blockquote>
<p>Cache Tags 不被<code>file</code> 、<code>dynamodb</code>及 <code>database</code>驱动所支持，特别是如果需要使用多Tags的永久存储，memcached驱动时最优选择，性能最好，并自动清楚陈旧记录值。</p>
</blockquote>
<blockquote>
<p>Cache Tags的增删改读请查看<a href="https://laravel.com/docs/7.x/cache#cache-tags">官方文档</a></p>
</blockquote>
<h3 id="原子锁">原子锁</h3>
<p>原子锁只有在<code>memcached</code>,<code>dynamodb</code>,<code>redis</code>,<code>database</code>,<code>array</code>作为cache驱动的时候才能被使用。而且所有的servers【从属服务器】都必须与相同的中央cache server【主服务器】通信。</p>
<blockquote>
<p>每个类型的驱动如何配置，原子锁的具体使用，方法调用请查看<a href="https://laravel.com/docs/7.x/cache#atomic-locks">官方文档</a></p>
</blockquote>
<blockquote>
<p>跨进程管理原子锁，比如http请求的时候加锁，但是解锁是放在queue job或者某个事件触发逻辑之后。具体请查看<a href="https://laravel.com/docs/7.x/cache#managing-locks-across-processes">官方文档</a></p>
</blockquote>
<h3 id="添加自定义cache驱动">添加自定义Cache驱动</h3>
<blockquote>
<p>参考 <a href="https://laravel.com/docs/7.x/cache#adding-custom-cache-drivers">Adding Custom Cache Drivers</a></p>
</blockquote>
<h3 id="事件">事件</h3>
<blockquote>
<p>Cache的操作会触发事件，如果有需要监听这些事件做响应的操作，可以设置监听器，设置在EventServiceProvider类中，具体参考<a href="https://laravel.com/docs/7.x/cache#events">Events</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Broadcasting 学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-broadcasting-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-broadcasting-xue-xi-ti-gang/">
        </link>
        <updated>2020-08-30T12:17:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1思考每一个模块功能有什么用什么时候可以用到">1.思考每一个模块，功能有什么用，什么时候可以用到？</h2>
<p>主要就是通过利用WebSocket技术实现服务端对用户端的信息更新推送。</p>
<p><em>提前需要知道Event【事件】和Listeners 【监听器】如何用。</em></p>
<blockquote>
<p>详细一点，就是利用Pusher和Redis作为驱动，log一般是测试的时候用，自己可以参考 <a href="https://github.com/beyondcode/laravel-websockets">laravel-websockets</a>实现一个，通过WebSocket，实现Laravel服务端把事件广播到客户端的JavaScript应用上。</p>
<p>事件广播用到的信道，具体分公共和私有信道，公共的信道，任何用户可以不经授权和认证就可以订阅接受，私有的就必须认证和授权了。</p>
</blockquote>
<p>使用举例：</p>
<ol>
<li>
<p>假定有一个给用户查看订单发货状态的页面；</p>
</li>
<li>
<p>订单运输状态发生改变就会触发一个ShippingStatusUpdated事件。</p>
</li>
</ol>
<blockquote>
<pre><code class="language-php">event(new ShippingStatusUpdated($update));
</code></pre>
<p>当用户挂在这个页面，即使不需要刷新。也可以在运单状态改变的时候通过广播到应用的方式进行运单状态的更新。</p>
<blockquote>
<p>只需要实现<code>ShouldBroadcast</code>接口即可；具体实现看官方文档。</p>
</blockquote>
</blockquote>
<p>对于需要私有信道的，可以看<a href="https://laravel.com/docs/7.x/broadcasting#authorizing-channels">Authorizing Channels</a>。就是JS应用向后端发送HTTP请求，后端鉴权搞定就可以了，使用Laravel Echo的话，这些都是默认实现好了的。不过，需要定义相应的routes来响应这些请求。</p>
<blockquote>
<p>路由及其他的配置见官方文档。</p>
</blockquote>
<p>如果你的应用在routes/channels.php中配置有太多的channel，会非常的臃肿，这个时候，就建议执行<code>php artisan make:channel OrderChannel</code>这个artisan命令添加channel类【位于App\Broadcasting文件夹】，其实就很类似于http请求的routes了；把channels.php文件里面的闭包就换成类名<code>Broadcast::channel('order.{order}', OrderChannel::class);</code>具体代码就在channel类的join方法里面处理。</p>
<blockquote>
<p>更多的参考官方文档</p>
</blockquote>
<p>对于一个事件广播需要排除当前用户【客户端】的，一般是使用toOthers()方法，事件类需要使用<code>Illuminate\Broadcasting\InteractsWithSockets</code>trait来调用toOthers()方法。</p>
<blockquote>
<p>​	However, remember that we also broadcast the task's creation. If your JavaScript application is listening for this event in order to add tasks to the task list, you will have duplicate tasks in your list: one from the end-point and one from the broadcast. You may solve this by using the <code>toOthers</code> method to instruct the broadcaster to not broadcast the event to the current user.</p>
<blockquote>
<p>场景就是，用户发布了一个任务，然后axios的response获取到该任务更新，同时这个任务更新被事件广播出去，前端代码通过事件广播将用户们的任务列表+1，其他用户接收到了，本用户也接受到了，相当于当前用户收到了两次响应，这样就重复了，使用<code>toOthers</code>方法就可以不通知当前用户，这样就不会重复。</p>
</blockquote>
<blockquote>
<p>默认情况下，Vue+Axios已经实现了客户端的处理逻辑，也可以自定义，具体的看官方文档：<a href="https://laravel.com/docs/7.x/broadcasting#only-to-others">Only To Others</a>。</p>
</blockquote>
</blockquote>
<p>在线状态频道【我愿称之为局域网】，可以实现比如bilibili在线观看人数实时变动的功能。用户多一个，大家的在线观看人数都显示+1，当然更精细的可以做到，谁加入了直播间这种提示。<em>肯定也就是private信道，而且用户还必须过channel鉴权，不然怎么统计用户信息？</em></p>
<blockquote>
<p>也因此，鉴权的回调函数不是返回true值，而是一个包含用户数据的array，这个数据会被其他事件广播监听的用户所使用，如果没有被授权或授权失败，返回false或者null。</p>
</blockquote>
<blockquote>
<p>如果需要做聊天室类的应用或者功能可以参考官方文档。</p>
</blockquote>
<p>如果需要一个比如“正在输入”的状态提示给其他用户，而不用通知到后端，只需要一个很轻量简洁的功能，触发方使用Echo的<code>whisper</code>方法，接收方使用<code>listenForWhisper</code>即可。</p>
<blockquote>
<p>具体参考官方文档</p>
</blockquote>
<p>需要Notification也使用BroadCasting服务，不需要刷新就可以通知到前端，</p>
<p>请先参考<a href="https://laravel.com/docs/7.x/notifications#broadcast-notifications">the broadcast notification channel</a>配置Notification，然后前端参考<a href="https://laravel.com/docs/7.x/broadcasting#notifications">官方文档</a>进行Notification广播的监听即可。</p>
<h2 id="2具体用法只需要了解不使用的时候是记不住的具体要用再查官方文档">2.具体用法只需要了解【不使用的时候是记不住的】，具体要用再查官方文档。</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laradock Win10 ]]></title>
        <id>https://dzkjz.github.io/post/laradock-win10/</id>
        <link href="https://dzkjz.github.io/post/laradock-win10/">
        </link>
        <updated>2020-08-15T13:31:39.000Z</updated>
        <content type="html"><![CDATA[<p>参考官方的<a href="https://laradock.io/">文档</a> 以及<a href="https://xueyuanjun.com/post/9608">在 Mac/Windows 系统中使用 Laradock 搭建基于 Docker 的 Laravel 开发环境</a>安装</p>
<p>给👴一直报错。</p>
<blockquote>
<pre><code class="language-powershell">ERROR: for postgres  Cannot create container for service postgres: status code not OK but 500: {&quot;Message&quot;:&quot;Unhandled exception: Filesharing has been cancelled&quot;,&quot;StackTrace&quot;:&quot;   at Docker.ApiServices.Mounting.FileSharing.&lt;**DoShareAsync**&gt;d__6.MoveNext() in C:\workspaces\stable-2.3.x\src\github.com\docker\pinata\win\src\Docker.ApiServices\Mounting\FileSharing.cs:line 0\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Docker.ApiServices.Mounting.FileSharing.&lt;**ShareAsync**&gt;d__4.MoveNext() in C:\workspaces\stable-2.3.x\src\github.com\docker\pinata\win\src\Docker.ApiServices\Mounting\FileSharing.cs:line 47\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Docker.HttpApi.Controllers.FilesharingController.&lt;**ShareDirectory**&gt;d__2.MoveNext() in C:\workspaces\stable-2.3.x\src\github.com\docker\pinata\win\src\Docker.HttpApi\Controllers\FilesharingController.cs:line 21\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Threading.Tasks.TaskHelpersExtensions.&lt;**CastToObject**&gt;d__1`1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;**InvokeActionAsyncCore**&gt;d__1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ActionFilterResult.&lt;**ExecuteAsync**&gt;d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Dispatcher.HttpControllerDispatcher.&lt;**SendAsync**&gt;d__15.MoveNext()&quot;}	
</code></pre>
</blockquote>
<p>反正就是这类，没截完，</p>
<p>根据</p>
<p>https://github.com/docker/for-win/issues/5456</p>
<p>https://stackoverflow.com/questions/59942110/docker-drive-has-not-been-shared</p>
<p>https://forums.docker.com/t/cannot-share-drive-in-windows-10/28798</p>
<p>以及</p>
<blockquote>
<p><a href="http://www.karlxu.com/article/details/24">Laradock遇到的坑</a></p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200815212846.png" alt="" loading="lazy"></figure>
</blockquote>
<p>就是设置FILESHARING 里添加需要sharing的<strong>C盘和D盘</strong>就ok了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue之inheritAttrs]]></title>
        <id>https://dzkjz.github.io/post/vue-zhi-inheritattrshttpscnvuejsorgv2apiinheritattrs/</id>
        <link href="https://dzkjz.github.io/post/vue-zhi-inheritattrshttpscnvuejsorgv2apiinheritattrs/">
        </link>
        <updated>2020-08-13T05:48:34.000Z</updated>
        <content type="html"><![CDATA[<p>参考<a href="https://stackoverflow.com/questions/56224091/what-are-inheritattrsfalse-and-attrs-used-for-in-vue">what are inheritAttrs:false and $attrs used for in vue?</a>：</p>
<blockquote>
<pre><code>// Component
Vue.component('base-input', {
 inheritAttrs: false,
 props: ['label', 'value'],
 template: `
   &lt;label&gt;
     {{ label }}
     &lt;input
       v-bind=&quot;$attrs&quot;
       v-bind:value=&quot;value&quot;
       v-on:input=&quot;$emit('input', $event.target.value)&quot;
     &gt;
   &lt;/label&gt;
 `
})

// Usage
&lt;base-input
 v-model=&quot;username&quot;
 required
 placeholder=&quot;Enter your username&quot;
/&gt;
</code></pre>
<p>The <code>required</code> and <code>placeholder</code> attributes are then set on the <code>input</code> instead of the wrapping <code>label</code>.</p>
<p>It doesn't really have anything to do with children of children of components but it can be used in such a hierarchy.</p>
<p>I hope that clears things up for you.</p>
<p>上面的示例代码来自 <a href="https://vuejs.org/v2/guide/components-props.html#Disabling-Attribute-Inheritance">Disabling Attribute Inheritance</a>官方文档。</p>
<p>其实就是 <code>inheritAttrs</code>设置为<code>false</code>值之后，</p>
<p>使用的</p>
<pre><code>&lt;base-input
 v-model=&quot;username&quot;
 required
 placeholder=&quot;Enter your username&quot;
</code></pre>
<p>这里面设置的 <code>required</code> 和 <code>placeholder</code>就不在模板根元素<code>label</code>上，而是在指定了<code>$attrs</code>的</p>
<pre><code>&lt;input
       v-bind=&quot;$attrs&quot;
</code></pre>
<p><code>input</code>标签上。参考这个，以后要用的就是你想设置到哪里，就设置<code>$attrs</code>到哪里，一般这个用在自定义基础组件<a href="https://vuejs.org/v2/style-guide/#Base-component-names-strongly-recommended">base components</a>的上面。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 之 作用域插槽]]></title>
        <id>https://dzkjz.github.io/post/vue-zhi-zuo-yong-yu-cha-cao/</id>
        <link href="https://dzkjz.github.io/post/vue-zhi-zuo-yong-yu-cha-cao/">
        </link>
        <updated>2020-08-11T18:53:34.000Z</updated>
        <content type="html"><![CDATA[<p>参考<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%85%B6%E5%AE%83%E7%A4%BA%E4%BE%8B">其他示例</a><br>
其实</p>
<pre><code> &lt;slot name=&quot;todo&quot; v-bind:todo=&quot;todo&quot;&gt;
      &lt;!-- 后备内容 --&gt;
      {{ todo.text }}
    &lt;/slot&gt;
</code></pre>
<p>就是把子组件中的 todo 暴露给外层组件</p>
<p>然后外层组件就可以通过</p>
<pre><code> &lt;template v-slot:todo=&quot;{ todo }&quot;&gt;
    &lt;span v-if=&quot;todo.isComplete&quot;&gt;✓&lt;/span&gt;
    {{ todo.text }}
  &lt;/template&gt;
</code></pre>
<p>这里面用了{todo}解构出上面slot的<code>:todo</code>其值为上面那个组件中的<code>todo</code>值，<br>
暴露出来在外层组件的template里面，就可以访问了：<code>todo.isComplete</code>及<code>{{ todo.text }}</code>就是从外层访问的子组件中的值。<br>
slot只能通过这种方式由内而外，被外层访问到。<br>
需要注意的是，之前版本是<code>slot-scope=&quot;slotProps&quot;</code>这种方式访问的，但是已经被<strong>废弃了</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义组件的 v-model]]></title>
        <id>https://dzkjz.github.io/post/zi-ding-yi-zu-jian-de-v-model/</id>
        <link href="https://dzkjz.github.io/post/zi-ding-yi-zu-jian-de-v-model/">
        </link>
        <updated>2020-08-11T15:45:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="自定义组件的"><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model">自定义组件的 <code>v-model</code></a></h1>
<p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突：</p>
<pre><code>Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    &lt;input
      type=&quot;checkbox&quot;
      v-bind:checked=&quot;checked&quot;
      v-on:change=&quot;$emit('change', $event.target.checked)&quot;
    &gt;
  `
})
</code></pre>
<p>现在在这个组件上使用 <code>v-model</code> 的时候：</p>
<pre><code>&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;
</code></pre>
<p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p>
<p>注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p>
<p>就是说：</p>
<p>默认情况下：</p>
<p><code>&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</code></p>
<p>lovingVue会对应到<code>base-checkbox</code>里面的value值，但是如果外层component需要的是使用这个<code>base-checkbox</code>component的其他属性，那就用</p>
<pre><code>  model: {
    prop: 'checked',
    event: 'change'
  },
</code></pre>
<p>这种方式；</p>
<p><code>v-model=&quot;lovingVue&quot;</code>对应到的就是<code>base-checkbox</code>component里面的<code>checked</code>属性，这个属性必须在该组件props里声明，</p>
<p>且</p>
<pre><code>v-on:change=&quot;$emit('change', $event.target.checked)&quot;
</code></pre>
<p>以及</p>
<pre><code> model: {
    prop: 'checked',
    event: 'change'
  },
</code></pre>
<p>中的<code>event: 'change'</code>都不可省略，还必须对应，抛出的事件和model里的事件必须一样。</p>
<p>拓展分析：</p>
<p>有这样一个组件</p>
<pre><code class="language-vue">//BaseInput.vue
&lt;template&gt;
    &lt;label class=&quot;inner base&quot;&gt;
        {{ label }} : {{value}}
        &lt;input :placeholder=&quot;$attrs['placej']&quot;
               :value=&quot;value&quot;
               @input=&quot;$emit('inputa', $event.target.value)&quot;&gt;
    &lt;/label&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name: &quot;BaseInput&quot;,
        inheritAttrs: false,
        props: ['label', 'value'],
        model: {
            prop: 'label',
            event: 'inputa'
        }
    }
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>外层组件</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;div &gt;
        &lt;BaseInput class=&quot;outter home&quot; placej=&quot;aj&quot; v-model=&quot;bi&quot;&gt;&lt;/BaseInput&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name: 'Home',
        data() {
            return {
                bi: '',
            }
        },
    }
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;

</code></pre>
<p>流程分析：</p>
<p>首先<code>BaseInput.vue</code>中两个属性<code>props: ['label', 'value']</code>是空值。接下来，当输入的时候，input事件触发，在<code>BaseInput.vue</code>中</p>
<p><code>@input=&quot;$emit('inputa', $event.target.value)&quot;</code>，抛出<code>inputa</code>事件，值为input更加底层的value即<code>$event.target.value</code>抛出；</p>
<p>然后由于</p>
<pre><code> model: {
            prop: 'label',
            event: 'inputa'
        }
</code></pre>
<p>所以，label值被设置为这个<code>$event.target.value</code>的值，并<code>v-model=&quot;bi&quot;</code>设置到外层组件的<code>bi</code>值，同时，value值因为<code>:value=&quot;value&quot;</code>而该组件中value为空，则一旦触发<code>input</code>事件，这个<code>:value</code>又被重置为空，输入框值也就被清空。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 之 $attrs]]></title>
        <id>https://dzkjz.github.io/post/vue-zhi-dollarattrs/</id>
        <link href="https://dzkjz.github.io/post/vue-zhi-dollarattrs/">
        </link>
        <updated>2020-08-11T13:41:46.000Z</updated>
        <content type="html"><![CDATA[<p>参考<a href="https://medium.com/@filip.stepien/using-v-model-attrs-on-vue-components-7fc44a315270">Using v-model + $attrs on Vue Components</a>：</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;div&gt;
    &lt;label for=&quot;name&quot; :class=&quot;label_cls&quot;&gt;Name&lt;/label&gt;
    &lt;input :class=&quot;input_cls&quot; id=&quot;name&quot; v-model=&quot;$attrs.value.name&quot;&gt;
    &lt;label for=&quot;role&quot; :class=&quot;label_cls&quot;&gt;Title&lt;/label&gt;
    &lt;input :class=&quot;input_cls&quot; id=&quot;role&quot; v-model=&quot;$attrs.value.role&quot;&gt;
    &lt;label for=&quot;email&quot; :class=&quot;label_cls&quot;&gt;Email&lt;/label&gt;
    &lt;input :class=&quot;input_cls&quot; id=&quot;email&quot; v-model=&quot;$attrs.value.email&quot;&gt;
    &lt;label for=&quot;insta&quot; :class=&quot;label_cls&quot;&gt;Instagram&lt;/label&gt;
    &lt;input :class=&quot;input_cls&quot; id=&quot;insta&quot; v-model=&quot;$attrs.value.insta&quot; autocomplete=&quot;insta_off&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapGetters } from &quot;vuex&quot;;
export default {
  name: &quot;UserFields&quot;,
  computed: {
    input_cls() {
      return &quot;w-full appearance-none border rounded py-2 px-3 mb-6 text-grey-darkest&quot;;
    },
    label_cls() {
      return &quot;text-grey-darker font-light inline-block mb-2&quot;;
    }
  }
};
&lt;/script&gt;
</code></pre>
<pre><code class="language-js">&lt;template&gt;
  &lt;div class=&quot;w-5/6 md:w-3/4 lg:w-2/3 mx-auto mt-8&quot; v-if=&quot;activeUser&quot;&gt;
    &lt;h2 class=&quot;font-light&quot;&gt;Account Settings&lt;/h2&gt;
    &lt;div class=&quot;flex mt-8 pt-8 border-t border-grey-light&quot;&gt;
      &lt;div class=&quot;w-64 hidden md:block&quot;&gt;
        &lt;div class=&quot;mb-2&quot;&gt;Profile&lt;/div&gt;
        &lt;span class=&quot;text-xs text-grey-dark&quot;&gt;
          Keep your user infomation up to date so that team members can contact
          you.
        &lt;/span&gt;
      &lt;/div&gt;
      &lt;form @submit.prevent=&quot;updateUser(user);&quot; class=&quot;flex flex-col md:ml-8 w-full&quot;&gt;
        &lt;UserFields v-model=&quot;user&quot;/&gt;
        &lt;div class=&quot;flex items-center&quot;&gt;
          &lt;input
            class=&quot;bg-blue hover:bg-blue-dark text-white font-normal py-2 px-4 my-6 rounded w-48 tracking-wide&quot;
            type=&quot;submit&quot;
            value=&quot;Submit&quot;
          &gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { mapGetters, mapActions } from &quot;vuex&quot;;
import UserFields from &quot;./UserFields.vue&quot;;
export default {
  name: &quot;UserForm&quot;,
  components: {
    UserFields
  },
  data() {
    return {
      user: {}
    };
  },
  mounted() {
    this.getUser();
  },
  computed: {
    ...mapGetters([&quot;activeUser&quot;])
  },
  methods: {
    ...mapActions([&quot;getUser&quot;, &quot;updateUser&quot;]),
    updateLocalUser(e) {
      this.$set(this.user, e.target.id, e.target.value);
    }
  },
  watch: {
    activeUser: {
      handler() {
        this.user = { ...this.activeUser };
      }
    },
    immediate: true
  }
};
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 源码学习之main.js代码解析]]></title>
        <id>https://dzkjz.github.io/post/vue-yuan-ma-xue-xi-zhi-mainjs-dai-ma-jie-xi/</id>
        <link href="https://dzkjz.github.io/post/vue-yuan-ma-xue-xi-zhi-mainjs-dai-ma-jie-xi/">
        </link>
        <updated>2020-08-08T16:00:18.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">//main.js
import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

new Vue({
  render: h =&gt; h(App),
}).$mount('#app')

</code></pre>
<h4 id="vmmount"><a href="https://cn.vuejs.org/v2/api/index.html#vm-mount">vm.$mount</a></h4>
<blockquote>
<p>​	[vm.$mount( [elementOrSelector] )]</p>
<ul>
<li>
<p><strong>参数</strong>：</p>
<ul>
<li><code>{Element | string} [elementOrSelector]</code></li>
<li><code>{boolean} [hydrating]</code></li>
</ul>
</li>
<li>
<p><strong>返回值</strong>：<code>vm</code> - 实例自身</p>
</li>
<li>
<p><strong>用法</strong>：</p>
<p>如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 <code>vm.$mount()</code> 手动地挂载一个未挂载的实例。</p>
<p>如下：</p>
<pre><code class="language-js">new Vue({el:'#app'})
或者
new Vue().$mount('#app')
</code></pre>
<p>拓展一下 这个<a href="https://cn.vuejs.org/v2/api/index.html#el">el</a>选项</p>
<blockquote>
<ul>
<li><strong>类型</strong>：<code>string | Element</code></li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>
<p><strong>限制</strong>：只在用 <code>new</code> 创建实例时生效。</p>
</li>
<li>
<p><strong>详细</strong>：</p>
<p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p>
<p>在实例挂载之后，元素可以用<a href="#vm.$el"><code>vm.$el</code></a>访问。</p>
<p>如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 <a href="#vm.$mount"><code>vm.$mount()</code></a> 手动开启编译。</p>
<p>提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。<strong>因此不推荐挂载 root 实例到 <code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code> 上</strong>。</p>
<p>如果 <code>render</code> 函数和 <code>template</code> property 都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。</p>
</li>
</ul>
</blockquote>
<p>如果没有提供 <code>elementOrSelector</code> 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。</p>
<p>如下：</p>
<pre><code class="language-js">var v = new Vue().$mount();
document.getElementById('app').appendChild(v.$el);
</code></pre>
<p>其中v.$el解释：</p>
<blockquote>
<h4 id="vmel"><a href="https://cn.vuejs.org/v2/api/index.html#vm-el">vm.$el</a></h4>
<ul>
<li>
<p><strong>类型</strong>：<code>Element</code></p>
</li>
<li>
<p><strong>只读</strong></p>
</li>
<li>
<p><strong>详细</strong>：</p>
<p>Vue 实例使用的根 DOM 元素。</p>
</li>
</ul>
</blockquote>
<p>这个方法返回实例自身，因而可以链式调用其它实例方法。</p>
</blockquote>
<h4 id="productiontip"><a href="https://cn.vuejs.org/v2/api/index.html#productionTip">productionTip</a></h4>
<blockquote>
<blockquote>
<p>2.2.0 新增</p>
</blockquote>
<ul>
<li>
<p><strong>类型</strong>：<code>boolean</code></p>
</li>
<li>
<p><strong>默认值</strong>：<code>true</code></p>
</li>
<li>
<p><strong>用法</strong>：</p>
<p>设置为 <code>false</code> 以阻止 vue 在启动时生成生产提示。</p>
</li>
</ul>
</blockquote>
<p>实例化vue的选项这里只用到了render，在介绍render之前，先介绍template选项：</p>
<h4 id="template"><a href="https://cn.vuejs.org/v2/api/index.html#template">template</a></h4>
<blockquote>
<p>​	<strong>类型</strong>：<code>string</code></p>
<ul>
<li>
<p><strong>详细</strong>：</p>
<p>一个字符串模板作为 Vue 实例的标识使用。模板将会<strong>替换</strong>挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽（slot）。</p>
<p>如果值以 <code>#</code> 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 包含模板。</p>
<p>参考<a href="https://vuejsdevelopers.com/2017/03/24/vue-js-component-templates/"><em>7 Ways to Define a Component Template in Vue.js</em></a></p>
</li>
</ul>
<blockquote>
<p>这种用法一般就是示例才用：</p>
<pre><code class="language-js">Vue.component('alert-box', {
template: `
 &lt;div class=&quot;demo-alert-box&quot;&gt;
   &lt;strong&gt;Error!&lt;/strong&gt;
   &lt;slot&gt;&lt;/slot&gt;
 &lt;/div&gt;
`
})
</code></pre>
<p>更多的就是X-templates</p>
<blockquote>
<pre><code class="language-js">//app.js
Vue.component('my-checkbox', {
  template: '#checkbox-template',
  data() {
    return { checked: false, title: 'Check me' }
  },
  methods: {
    check() { this.checked = !this.checked; }
  }
});
</code></pre>
<pre><code class="language-html">&lt;!--index.html--&gt;
&lt;div id=&quot;app&quot;&gt;...&lt;/div&gt;
&lt;script type=&quot;text/x-template&quot; id=&quot;checkbox-template&quot;&gt;
  &lt;div class=&quot;checkbox-wrapper&quot; @click=&quot;check&quot;&gt;
    &lt;div :class=&quot;{ checkbox: true, checked: checked }&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;title&quot;&gt;{{ title }}&lt;/div&gt;
  &lt;/div&gt;
&lt;/script&gt;
</code></pre>
<p>即：在index.html中定义一个type为text/x-template的sctipt标签，给一个id：checkbox-template，组件中template选项就不用再写字符串，而是直接就用这个id引用script上的模板了。</p>
</blockquote>
</blockquote>
<ol>
<li>
<p>出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。</p>
</li>
<li>
<p>如果 Vue 选项中包含<a href="#render">渲染函数</a>，该模板将被忽略。</p>
</li>
</ol>
</blockquote>
<p>介绍了template，现在介绍render选项。</p>
<h4 id="render"><a href="https://cn.vuejs.org/v2/api/index.html#render">render</a></h4>
<blockquote>
<ul>
<li>
<p><strong>类型</strong>：<code>(createElement: () =&gt; VNode) =&gt; VNode</code></p>
</li>
<li>
<p><strong>详细</strong>：</p>
<p>字符串模板<a href="#template">template</a>的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>。</p>
<p>如果组件是一个函数组件，渲染函数还会接收一个额外的 <code>context</code> 参数，为没有实例的函数组件提供上下文信息。</p>
<p>Vue 选项中的 <code>render</code> 函数若存在，则 Vue 构造函数不会从 <code>template</code> 选项或通过 <code>el</code> 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</p>
</li>
</ul>
<p>这个解释太理论了。直接从<a href="https://vuejs.org/v2/guide/render-function.html">render-function</a>摘一段</p>
<pre><code class="language-js">Vue.component('anchored-heading', {
  render: function (createElement) {
    return createElement(
      'h' + this.level,   // tag name
      this.$slots.default // array of children
    )
  },
  props: {
    level: {
      type: Number,
      required: true
    }
  }
})
</code></pre>
<p>再看看<a href="https://www.tutorialspoint.com/vuejs/vuejs_render_function.htm">vuejs render function</a>的示例：</p>
<blockquote>
<p>将这个</p>
<pre><code class="language-html">&lt;html&gt;
   &lt;head&gt;
      &lt;title&gt;VueJs Instance&lt;/title&gt;
      &lt;script type = &quot;text/javascript&quot; src = &quot;js/vue.js&quot;&gt;&lt;/script&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;div id = &quot;component_test&quot;&gt;
         &lt;testcomponent&gt;Hello Jai&lt;/testcomponent&gt;
         &lt;testcomponent&gt;Hello Roy&lt;/testcomponent&gt;
         &lt;testcomponent&gt;Hello Ria&lt;/testcomponent&gt;
         &lt;testcomponent&gt;Hello Ben&lt;/testcomponent&gt;
      &lt;/div&gt;
      &lt;script type = &quot;text/javascript&quot;&gt;
         Vue.component('testcomponent',{
            template : '&lt;h1&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/h1&gt;',
            data: function() {
            },
            methods:{
            }
         });
         var vm = new Vue({
            el: '#component_test'
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>通过使用render function 优化成：</p>
<pre><code class="language-html">&lt;html&gt;
   &lt;head&gt;
      &lt;title&gt;VueJs Instance&lt;/title&gt;
      &lt;script type = &quot;text/javascript&quot; src = &quot;js/vue.js&quot;&gt;&lt;/script&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;div id = &quot;component_test&quot;&gt;
         &lt;testcomponent :elementtype = &quot;'div,red,25,div1'&quot;&gt;Hello Jai&lt;/testcomponent&gt;
         &lt;testcomponent :elementtype = &quot;'h3,green,25,h3tag'&quot;&gt;Hello Roy&lt;/testcomponent&gt;
         &lt;testcomponent :elementtype = &quot;'p,blue,25,ptag'&quot;&gt;Hello Ria&lt;/testcomponent&gt;
         &lt;testcomponent :elementtype = &quot;'div,green,25,divtag'&quot;&gt;Hello Ben&lt;/testcomponent&gt;
      &lt;/div&gt;
      &lt;script type = &quot;text/javascript&quot;&gt;
         Vue.component('testcomponent',{
            render :function(createElement){
               var a = this.elementtype.split(&quot;,&quot;);
               return createElement(a[0],{
                  attrs:{
                     id:a[3],
                     style:&quot;color:&quot;+a[1]+&quot;;font-size:&quot;+a[2]+&quot;;&quot;
                  }
               },
               this.$slots.default
               )
            },
            props:{
               elementtype:{
                  attributes:String,
                  required:true
               }
            }
         });
         var vm = new Vue({
            el: '#component_test'
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</blockquote>
<p>不过我觉得解释比较通顺的应该是：</p>
<p><a href="https://snipcart.com/blog/vue-render-functions">Vue render functions</a>中的：</p>
<blockquote>
<p>Each <a href="https://snipcart.com/blog/vue-component-example-tutorial"><strong>Vue component</strong></a> implements a render function. Most of the time, the function will be created by the Vue compiler. When you specify a <code>template</code> on your component, the content of this template will be processed by the Vue compiler that will return a render function. The render function essentially returns a virtual DOM node which will be rendered by Vue in your browser DOM.</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/renderingprocess.png" alt="" loading="lazy"></figure>
<blockquote>
<p>同时本文指出，虚拟DOM可以在更新浏览器前渲染组件，正是因为与浏览器的直接接触较少，所以速度更快。</p>
<blockquote>
<p>摘一段 https://blog.logrocket.com/using-jsx-with-vue/</p>
<p>Vue creates a Virtual DOM that keeps track of all the changes made to the real DOM and on every data change Vue returns a new Virtual DOM, it then compares the old virtual DOM to the new one and checks for specific changes and makes adjustments in the real DOM.</p>
<p>The process of comparing and checking changes between the old and the new Virtual DOM is referred to as <a href="https://en.wikipedia.org/wiki/Diff">diffing</a>.</p>
<p>This <a href="https://template-explorer.vuejs.org/">mini-app</a> helps explore the Vue templates and render functions, you can learn more about render functions in Vue and the Virtual DOM <a href="https://blog.logrocket.com/accessing-the-virtual-dom-using-render-functions-in-vue-js/">here</a>.</p>
</blockquote>
<p>这样更新的元素就更少，提高了效率，render function返回的就是虚拟DOM节点【通常叫VNode】，which is an interface that allows Vue to write these objects in your browser DOM。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/vuegraph.jpg" alt="" loading="lazy"></figure>
</blockquote>
<blockquote>
<p>组件中都可以用这个render function，一旦组件的属性更新了，这个render function就会被调用。</p>
<p>多数时候，这个render function是直接在build项目的时候，直接被vue 打包好的，你可以不用每个组件都写一遍这个render function。</p>
</blockquote>
<p>其余的部分不摘抄了，有很多高级的内容。</p>
<blockquote>
<p>这个传入的createElement方法，是vue自带的，可以用于创建element。</p>
</blockquote>
<p>《vue.js》书的作者有一个视频讲解：<a href="https://www.youtube.com/watch?v=l0eZCvJcYZ8">Create A Vue App With Render Functions Tutorial! What Is it?</a></p>
<blockquote>
<p>​	一般情况下我们是用的比如</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;home&quot; @click=&quot;()=&gt;alert('test')&quot;&gt;
    &lt;p&gt;
       no class
    &lt;/p&gt;
      &lt;p class=&quot;textp&quot;&gt;
        what a world
    &lt;/p&gt;
      &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;
      
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import HelloWorld from './components/HelloWorld.vue'

export default {
  name: 'hello',
  components: {
    HelloWorld
  }
}
&lt;/script&gt;

&lt;style&gt;

&lt;/style&gt;
</code></pre>
<p>这样的vue文件</p>
<p>就是 template 然后 script 然后 style</p>
<p>如果使用render可以直接不用template，也不用</p>
<pre><code class="language-vue">components: {
    HelloWorld
  }
</code></pre>
<p>直接</p>
<pre><code class="language-vue">&lt;script&gt;
import HelloWorld from './components/HelloWorld.vue'

export default {
  name: 'hello',
 render(createElement){
     return createElement(&quot;div&quot;,{
         attr:{
             class:&quot;home&quot;
         },
         on:{
             click:()=&gt;alert(&quot;test&quot;)
         }
     },
      [
         createElement(&quot;p&quot;,{},&quot;no class&quot;),
         createElement(&quot;p&quot;,{
             attr:{
                 class:&quot;textp&quot;
             }
         },&quot;what a world&quot;),
         createElement(HelloWorld,{
             props:{
                 msg:&quot;created!&quot;
             }
         })
     ])
 }
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;

</code></pre>
<p>一般还是用的template，因为比较直观，但是如果代码重复太多，那还是不要重复造轮，直接用这种createElement方式，反正两种方式，哪种方便用哪种。</p>
</blockquote>
</blockquote>
<p>render介绍完，那么<code>render: h =&gt; h(App),</code>中<code>h</code>是什么，为什么<code>h(APP)</code>这样使用</p>
<p>这里参考<a href="https://css-tricks.com/what-does-the-h-stand-for-in-vues-render-method/">What does the ‘h’ stand for in Vue’s render method?</a>:</p>
<blockquote>
<p>The <code>h</code> stands for <strong>hyperscript</strong>, hyperscript is actually <a href="https://github.com/hyperhype/hyperscript">the name of a library</a> (what isn’t updated these days) and it actually has a <a href="https://github.com/hyperhype/hyperscript#ecosystem">small ecosystem</a>,</p>
<blockquote>
<p><a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx/issues/6#issuecomment-232994673">尤雨溪注</a>：</p>
<p><em>Hyperscript itself stands for “script that generates HTML structures</em>,</p>
</blockquote>
<p>Really, you can think of it as being short for <code>createElement</code>. Here would be the long form:</p>
<pre><code class="language-js">render: function (createElement) {
return createElement(App);
}
</code></pre>
<p>If we replace that with an <code>h</code>, then we first arrive at:</p>
<pre><code class="language-javascript">render: function (h) {
return h(App);
}
</code></pre>
<p>…which can then be shortened with the use of ES6 to:</p>
<pre><code class="language-js">render: h =&gt; h (App)
</code></pre>
<p>The Vue version takes up to three arguments:</p>
<pre><code class="language-js">render(h) {
  return h('div', {}, [...])
}
</code></pre>
<ol>
<li>The first is type of the element (here shown as <code>div</code>).</li>
<li>The second is the data object. We nest some fields here, including: props, attrs, dom props, class and style.</li>
<li>The third is an array of child nodes. We’ll then have nested calls and eventually return a tree of virtual DOM nodes.</li>
</ol>
<p>There’s more in-depth information in the <a href="https://vuejs.org/v2/guide/render-function.html#createElement-Arguments">Vue Guide here</a>.</p>
</blockquote>
<p>这里还提到了JSX，那么JSX是什么，有什么优势，为什么用它？</p>
<blockquote>
<pre><code class="language-js">Vue.component('jsx-example', {
  render (h) {
    return &lt;div id=&quot;foo&quot;&gt;bar&lt;/div&gt;
  }
})
</code></pre>
</blockquote>
<blockquote>
<p>摘<a href="https://blog.logrocket.com/using-jsx-with-vue/">Using JSX with Vue</a></p>
<p>首先，JSX是类似XML文本的语法扩展，用来写js代码，是render function的抽象版本。最开始是Facebook工程师发明，用来写React的。</p>
</blockquote>
<blockquote>
<p>摘官方文档<a href="https://vuejs.org/v2/guide/render-function.html#JSX">JSX</a></p>
<p>If you’re writing a lot of <code>render</code> functions, it might feel painful to write something like this:</p>
<blockquote>
<pre><code class="language-js">createElement(
  'anchored-heading', {
    props: {
      level: 1
    }
  }, [
    createElement('span', 'Hello'),
    ' world!'
  ]
)
</code></pre>
</blockquote>
<p>Especially when the template version is so simple in comparison:</p>
<blockquote>
<pre><code class="language-html">&lt;anchored-heading :level=&quot;1&quot;&gt;
  &lt;span&gt;Hello&lt;/span&gt; world!
&lt;/anchored-heading&gt;
</code></pre>
</blockquote>
<p>That’s why there’s a <a href="https://github.com/vuejs/jsx">Babel plugin</a> to use JSX with Vue, getting us back to a syntax that’s closer to templates:</p>
<blockquote>
<pre><code class="language-vue">import AnchoredHeading from './AnchoredHeading.vue'

new Vue({
  el: '#demo',
  render: function (h) {
    return (
      &lt;AnchoredHeading level={1}&gt;
        &lt;span&gt;Hello&lt;/span&gt; world!
      &lt;/AnchoredHeading&gt;
    )
  }
})
</code></pre>
<p>注意，Vue中通常都是用<code>h</code>来简写代表<code>createElement</code>，<strong>在JSX中是必须用<code>h</code>的，但是babel3.4版本之后的，已经自动注入了<code>const h = this.$createElement</code>到方法和设置器中，所以(h)参数可以省略，之前的版本没有<code>h</code>参数会抛<code>h</code> not available异常</strong></p>
</blockquote>
<p>参考[JSX Implementation](https://blog.logrocket.com/using-jsx-with-vue/Using JSX with Vue)还可以这样：</p>
<p>原先的：</p>
<blockquote>
<pre><code class="language-js">&lt;template&gt;
   &lt;div v-if=&quot;user.age &gt; 18&quot;&gt;
      Welcome, {{user.name}}
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
</blockquote>
<p>可以改为：</p>
<blockquote>
<pre><code class="language-js">export default {
....
  methods: {
      checkStatement(){
        if (this.user.age &gt; 18) {
           return &lt;div&gt; Welcome, { this.user.name }&lt;/div&gt;;
        }
      }
    },
    render(){
      return(
        {this.checkStatement()}
      )
    }
}
</code></pre>
</blockquote>
<p>render会调用这个checkStatement方法。</p>
<p>[Using JSX with Vue]([https://blog.logrocket.com/using-jsx-with-vue/Using%20JSX%20with%20Vue](https://blog.logrocket.com/using-jsx-with-vue/Using JSX with Vue))还有Loops (v-for),Events(v-on),Interpolation (v-html),Importing components几个的具体修改方法，就不摘抄了。</p>
<p>还有几个要注意的</p>
<h5 id="vues-jsx-syntax-gotchas"><a href="https://scotch.io/tutorials/using-jsx-with-vue-and-why-you-should-care#toc-vue-s-jsx-syntax-gotchas">Vue's JSX syntax gotchas</a></h5>
<blockquote>
<p>First, you can no longer use the <code>:</code> and <code>@</code> shortcuts for binding and listening to events. They are invalid JSX syntax and your code won't compile.</p>
<p>To listen for events in JSX, we need the &quot;<em>on</em>&quot; prefix. For example, use <code>onClick</code> for click events.</p>
<pre><code class="language-js">render (createElement) {
     return (
         &lt;button onClick={this.handleClick}&gt;&lt;/button&gt;
     )
 }
</code></pre>
<p>To modify events, use:</p>
<pre><code class="language-js"> render (createElement) {
     return (
         &lt;button onClick:prevent={this.handleClick}&gt;&lt;/button&gt;
     )
 }
</code></pre>
<p>To bind a variable, instead of <code>:</code> use: 以前就是<code>:content=&quot;generatedText&quot;</code></p>
<pre><code class="language-js"> render (createElement) {
     return (
         &lt;button content={this.generatedText}&gt;&lt;/button&gt;
     )
 }
</code></pre>
<p>To set HTML string as the content of an element, instead of <code>v-html</code> use:</p>
<pre><code class="language-js"> render (createElement) {
     return (
         &lt;button domPropsInnerHTML={htmlContent}&gt;&lt;/button&gt;
     )
 }
</code></pre>
<p>We can also spread a large object.</p>
<pre><code class="language-js"> render (createElement) {
     return (
         &lt;button {...this.largeProps}&gt;&lt;/button&gt;
     )
 }
</code></pre>
<h6 id="how-to-make-jsx-work-with-typescript"><a href="https://scotch.io/tutorials/using-jsx-with-vue-and-why-you-should-care#toc-how-to-make-jsx-work-with-typescript">How to make JSX work with TypeScript</a></h6>
</blockquote>
<h5 id="using-jsx-in-render"><a href="https://scotch.io/tutorials/using-jsx-with-vue-and-why-you-should-care#toc-using-jsx-in-render">Using JSX in render</a></h5>
<p>最后建议：template适合在模板比较复杂的情况下使用，JSX适合重复造轮，代码却不复杂的情况下使用。</p>
<blockquote>
<p>I’m working on a project that has quite an amount of low-level components. They contain lots of scripting with small amounts of templating. JSX feels like a breath of fresh air in this scenario.</p>
<p>On the other hand, when building large views that consist of large chunks of html with some custom components and directives, Vue templates are a better fit.</p>
<p>Luckily, we don’t need to pick one, we can use both! I’ll be my low-level components with JSX, and the “views”, which will be written by other developers, will be writting with familiar Vue templates.</p>
<p>I suppose I’ll see how this all goes, only one way to find out! If I encounter a bunch tradeoffs in the coming months, expect a follow-up post about why I reverted back to <code>.vue</code> files.</p>
</blockquote>
</blockquote>
<p>这里再介绍一个vue选项里的</p>
<h4 id="rendererror"><a href="https://cn.vuejs.org/v2/api/index.html#renderError">renderError</a></h4>
<blockquote>
<blockquote>
<p>2.2.0 新增</p>
</blockquote>
<ul>
<li>
<p><strong>类型</strong>：<code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></p>
</li>
<li>
<p><strong>详细</strong>：</p>
<p><strong>只在开发者环境下工作。</strong></p>
<p>当 <code>render</code> 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 <code>renderError</code>。这个功能配合 hot-reload 非常实用。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="language-js">new Vue({
  render (h) {
    throw new Error('oops')
  },
  renderError (h, err) {
    return h('pre', { style: { color: 'red' }}, err.stack)
  }
}).$mount('#app')
</code></pre>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[几个SEO的百科站]]></title>
        <id>https://dzkjz.github.io/post/ji-ge-seo-de-bai-ke-zhan/</id>
        <link href="https://dzkjz.github.io/post/ji-ge-seo-de-bai-ke-zhan/">
        </link>
        <updated>2020-08-07T15:55:20.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.matthewwoodward.co.uk/seo/ 建议</p>
<p>https://backlinko.com/hub/seo 建议</p>
<p>https://moz.com/learn/seo 初学者建议看这个先。</p>
]]></content>
    </entry>
</feed>