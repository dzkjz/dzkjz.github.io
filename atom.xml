<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dzkjz.github.io/</id>
    <title>JojoLegend</title>
    <updated>2020-09-03T14:14:28.158Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dzkjz.github.io/"/>
    <link rel="self" href="https://dzkjz.github.io/atom.xml"/>
    <subtitle>Something for age</subtitle>
    <logo>https://dzkjz.github.io/images/avatar.png</logo>
    <icon>https://dzkjz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JojoLegend</rights>
    <entry>
        <title type="html"><![CDATA[Laravel Database Migrations学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-database-migrations-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-database-migrations-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-03T14:12:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>Migrations就类似于数据包的版本控制。</p>
<h4 id="creating-columns"><a href="https://laravel.com/docs/7.x/migrations#creating-columns">Creating Columns</a> 创建列</h4>
<h4 id="column-modifiers"><a href="https://laravel.com/docs/7.x/migrations#column-modifiers">Column Modifiers</a> 修饰列</h4>
<h4 id="modifying-columns"><a href="https://laravel.com/docs/7.x/migrations#modifying-columns">Modifying Columns</a> 修改列</h4>
<h4 id="dropping-columns"><a href="https://laravel.com/docs/7.x/migrations#dropping-columns">Dropping Columns</a>删除列</h4>
<h3 id="indexes"><a href="https://laravel.com/docs/7.x/migrations#indexes">Indexes</a></h3>
<pre><code class="language-php">$table-&gt;id()-&gt;unique();
$table-&gt;primary('id');
$table-&gt;spatialIndex('location');//除了sqlite以外的都支持
$table-&gt;primary(['id', 'parent_id']);
$table-&gt;unique('email');
$table-&gt;index(['account_id', 'created_at']);
$table-&gt;unique('email',
    'unique_email'// specify the index name yourself
);
$table-&gt;renameIndex('from', 'to');

</code></pre>
<h4 id="foreign-key-constraints"><a href="https://laravel.com/docs/7.x/migrations#foreign-key-constraints">Foreign Key Constraints</a></h4>
<pre><code class="language-php">//外键【一个表[users表]上的键[id]出现在别的表[orders表]上，就是外键[user_id]】添加
$table-&gt;foreign('user_id')-&gt;references('id')-&gt;on('users');


//作用同上
$table-&gt;foreignId('user_id')//unsignedBigInteger别名
-&gt;constrained();


$table-&gt;foreignId('user_id')//unsignedBigInteger别名
-&gt;constrained('users')//可以指定表名
-&gt;onDelete('cascade')//预期行为
;


$table-&gt;foreignId('user_id')//unsignedBigInteger别名
-&gt;nullable()//可在constrained前调用
-&gt;constrained();


$table-&gt;dropForeign('posts_user_id_foreign');//删除外键[存放在posts表中的user_id外键]

//也可以
$table-&gt;dropForeign(['user_id']);


//启动外键约束
// SQLite disables foreign key constraints by default.
// When using SQLite, make sure to enable foreign key support in your
// database configuration before attempting to create them in your migrations.
// In addition, SQLite only supports foreign keys upon creation of the table and not when tables are altered.
Schema::enableForeignKeyConstraints();

//取消外键约束
Schema::disableForeignKeyConstraints();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Database Pagination学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-database-pagination-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-database-pagination-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-03T12:30:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>默认情况下，分页的当前页码是在http的请求字符串page里的，后端会自动检测到，当然也会由分页器自动给插入到前端。</p>
<pre><code class="language-php">$users = DB::table('users')-&gt;paginate(15);
if ($users) {
    return view('user.index', ['users' =&gt; $users]);
}
//分页数据对于groupBy方法结果不太支持【目前】，如果确有需要，请自己实现

$users = DB::table('users')-&gt;simplePaginate(15);//前端只需要后一页，前一页的链接数据，而不是分页结果里每一页的链接地址数据


$users = \App\Models\User::paginate(15);

$users = \App\Models\User::where('votes', '&gt;', 100)-&gt;paginate(15);

$users = \App\Models\User::where('votes', '&gt;', 100)-&gt;simplePaginate(15);


//自定义分页器
// Illuminate\Pagination\Paginator[对应simplePaginate方法]
// or
// Illuminate\Pagination\LengthAwarePaginator【对应有paginate方法】
</code></pre>
<blockquote>
<p>View部分，如果使用laravel的前端，可以查看<a href="https://laravel.com/docs/7.x/pagination#customizing-the-pagination-view">Customizing The Pagination View</a>详细了解。以及前端的blade模板自定义，blade中paginator方法的调用<a href="https://laravel.com/docs/7.x/pagination#paginator-instance-methods">Paginator Instance Methods</a>。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Database Query Builder学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-database-query-builder-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-database-query-builder-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-03T11:38:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>*<em>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</em></p>
</blockquote>
<blockquote>
<p>The Laravel query builder uses PDO parameter binding to protect your application against SQL injection attacks. There is no need to clean strings being passed as bindings.</p>
</blockquote>
<pre><code class="language-php">//Retrieve single Row
$user = DB::table('users')-&gt;where('name', 'John')-&gt;first();
echo $user-&gt;name;

//Retrieve single row data's column value
$email = DB::table('users')-&gt;where('name', 'John')-&gt;value('email');

//Retrieve By ID
$user = DB::table('users')-&gt;find(3);


//Retrieve a list of column values
$titles = DB::table('roles')-&gt;pluck('title');
foreach ($titles as $title) {
    echo $title;
}

//
$roles = DB::table('roles')-&gt;pluck('title', 'name');
foreach ($roles as $name =&gt; $title) {
    echo $title;
}

//一次取一部分数据，分块获取，每一小块还可放进闭包里处理
DB::table('users')-&gt;orderBy('id')-&gt;chunk(100, function ($users) {
    foreach ($users as $user) {
        //
    }
});

DB::table('users')-&gt;orderBy('id')-&gt;chunk(100, function ($users) {
    //处理数据

    return false;//返回false表示停止处理然后退出返回
});


//如果你需要在闭包里处理及更新数据，一遍更新，一边取，如果是按修改时间取，那你修改了的就一直是最新，就一直在修改这一段，
//这个时候，建议使用chunkById方法，会依据数据的primary key排序
DB::table('users')-&gt;where('active', false)
    -&gt;chunkById(100, function ($users) {
        foreach ($users as $user) {
            DB::table('users')-&gt;where('id', $user-&gt;id)-&gt;update(['active' =&gt; true]);
        }
    });

//不过还需要注意，如果你的操作是增加或者删除数据，任何对primary key或者外键的修改，会影响chunk query结果。

/** Aggregates */
// count, max, min, avg, sum

$users = DB::table('users')-&gt;count();

$price = DB::table('orders')-&gt;max('price');

$price = DB::table('orders')
    -&gt;where('finalized', 1)
    -&gt;avg('price');

$exists = DB::table('orders')-&gt;where('finalized', 1)-&gt;exists();
$notExists = DB::table('orders')-&gt;where('finalized', 1)-&gt;doesntExist();

/** Selects */
$users = DB::table('users')-&gt;select('name', 'email as user_email')-&gt;get();

//唯一值
$users = DB::table('users')-&gt;distinct()-&gt;get();

//追加select限定
$query = DB::table('users')-&gt;select('name');
$users = $query-&gt;addSelect('age')-&gt;get();

//原生 表达式
$users = DB::table('users')
    -&gt;select(DB::raw('count(*) as user_count,status'))//原生语句会以字符串的形式注入到sql query种，一定要避免sql注入
    -&gt;where('status', '&lt;&gt;', 1)
    -&gt;groupBy('status')
    -&gt;get();

//selectRaw
$orders = DB::table('orders')
    -&gt;selectRaw('price * ? as price_with_tax', [1.0825])//接受第二个参数作为第一语句中'?'的绑定值
    -&gt;get();

DB::table('orders')
    -&gt;whereRaw('price &gt; IF(state = &quot;TX&quot;,?,100)', [200])
    -&gt;get();

DB::table('orders')-&gt;select('department', DB::raw('SUM(price) as total_sales'))
    -&gt;groupBy('department')
    -&gt;havingRaw('SUM(price)&gt;?', [2500]) //haveRaw和orHavingRaw方法可用于将原始字符串设置为having子句的值
    -&gt;get();


//orderByRaw方法可用于将原始字符串设置为order by子句的值：
DB::table('orders')-&gt;orderByRaw('updated_at - created_at DESC')-&gt;get();

//groupByRaw方法可用于将原始字符串设置为group by子句的值：
DB::table('orders')-&gt;select('city', 'state')-&gt;groupByRaw('city,state')-&gt;get();


//Joins
//Unions
//Where Clauses
//Ordering, Grouping, Limit &amp; Offset
//Conditional Clauses
$role = $request-&gt;input('role');
DB::table('users')
    -&gt;when($role, function ($query, $role) {
        $query-&gt;where('role_id', $role);
    })-&gt;get();
//Inserts
//Updates
//Deletes
//Pessimistic Locking
//Debugging
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Database学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-database-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-database-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-02T16:27:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>*<em>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</em></p>
</blockquote>
<p>Laravel支持多种SQL数据库，如果需要查看每个数据库怎么配置，请查看官方文档<a href="https://laravel.com/docs/7.x/database#configuration">Configuration</a></p>
<p>使用了多个数据库链接的情况下，如果要指定选其中一个链接来处理，可以参考<a href="https://laravel.com/docs/7.x/database#using-multiple-database-connections">Using Multiple Database Connections</a></p>
<blockquote>
<p>DB facade支持的增删改查方法，详细的请看官方文档<a href="https://laravel.com/docs/7.x/database#running-queries">Running Raw SQL Queries</a></p>
</blockquote>
<h3 id="listening-for-query-events"><a href="https://laravel.com/docs/7.x/database#listening-for-query-events">Listening For Query Events</a></h3>
<p>每个SQL请求都会触发事件，如果需要log这些query或者debug，可以使用<code>DB::listen</code>方法。</p>
<blockquote>
<p>详细请看<a href="https://laravel.com/docs/7.x/database#listening-for-query-events">Listening For Query Events</a></p>
</blockquote>
<h3 id="数据库事务database-transactions">数据库事务<a href="https://laravel.com/docs/7.x/database#database-transactions">Database Transactions</a></h3>
<pre><code class="language-php">$users = DB::connection('mysql')-&gt;select('');

//获取底层的pdo实例
$pdo = DB::connection()-&gt;getPdo();

// The select method will always return an array of results.
// Each result within the array will be a PHP stdClass object,
// allowing you to access the values of the results:
$users = DB::select('select * from users where active = ?', [1]);
if ($users) {
    return view('user.index', ['users' =&gt; $users]);
}

foreach ($users as $user) {
    echo $user-&gt;name;
}

//Naming bindings

$results = DB::select('select * from users where id =:id', ['id' =&gt; 1]);


//insert
DB::insert('insert into users(id,name) values(?,?)', [1, 'Dayle']);

//update
$affected = DB::update('update users set votes = 100 where name= ? ', ['John']);


//delete
$deleted = DB::delete('delete from users'); // the number of rows affected will be returned:


//statement
// Some database statements do not return any value.
// For these types of operations, you may use the statement method on the DB facade:
DB::statement('drop table users');


//Database Transactions 数据库事务，闭包内事务如果执行异常，会自动回滚处理，如果成功，事务就会自动完成执行
DB::transaction(function () {
    DB::table('users')-&gt;update(['votes' =&gt; 1]);
    DB::table('posts')-&gt;delete();
});


DB::transaction(function () {
    DB::table('users')-&gt;update(['votes' =&gt; 1]);
    DB::table('posts')-&gt;delete();
}, 5);//第二个参数作用，如果出现死锁，会最大尝试5次，超次就会抛异常

//手动启动事务执行
DB::beginTransaction();
//手动回滚
DB::rollBack();
//手动提交事务
DB::commit();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Task Scheduling学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-task-scheduling-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-task-scheduling-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-02T07:28:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>Schedule就是用来简化Cron操作的。</p>
<blockquote>
<p>初始配置查看 <a href="https://laravel.com/docs/7.x/scheduling#introduction">Introduction</a></p>
</blockquote>
<blockquote>
<p>执行Artisan command，queue job，shell命令，闭包方法，以及执行时间间隔，频率，执行所处的时间段等详细资料查看官方文档<a href="https://laravel.com/docs/7.x/scheduling#defining-schedules">Defining Schedules</a>。</p>
</blockquote>
<p>如果你的应用放置在三个服务器上，你的计划调度就会三个服务器同时启动，只需要一个调度完成的任务，三个都在调度，这样明显不好，应该限制只在一个机器上运行就可以了。使用onOneServer方法。</p>
<blockquote>
<p>详细参考<a href="https://laravel.com/docs/7.x/scheduling#running-tasks-on-one-server">Running Tasks On One Server</a></p>
</blockquote>
<p>如果有多个命令依序执行，有几个超耗时的命令排在前面，那后面的命令可能就一直卡很久，都不能按计划时间执行，这时候应该把这些命令改成后台执行，这样它们就能同步执行了。</p>
<blockquote>
<p>详细参考<a href="https://laravel.com/docs/7.x/scheduling#background-tasks">Background Tasks</a></p>
</blockquote>
<p>如果你的应用进入维护模式，这个时候Scheduled任务是不会运行的，但是如果你不想某些任务受到维护模式影响而不能运行，使用 <code>evenInMaintenanceMode</code>方法；</p>
<blockquote>
<p>详细参考：<a href="https://laravel.com/docs/7.x/scheduling#maintenance-mode">Maintenance Mode</a></p>
</blockquote>
<h3 id="task-output"><a href="https://laravel.com/docs/7.x/scheduling#task-output">Task Output</a></h3>
<pre><code class="language-php">//输出到文件
$filePath = '';
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;sendOutputTo($filePath);

//追加到文件
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;appendOutputTo($filePath);

//如果配置好了email发送服务
//可以把输出发送到指定邮箱
$schedule-&gt;command('foo')
    -&gt;daily()
    -&gt;sendOutputTo($filePath)
    -&gt;emailOutputTo('foo@example.com');

//只把错误信息发到指定邮箱
$schedule-&gt;command('foo')
    -&gt;daily()
    -&gt;emailOutputOnFailure('foo@example.com');
</code></pre>
<blockquote>
<p>独有的方法：</p>
<p>The <code>emailOutputTo</code>, <code>emailOutputOnFailure</code>, <code>sendOutputTo</code>, and <code>appendOutputTo</code> methods are exclusive to the <code>command</code> and <code>exec</code> methods.</p>
</blockquote>
<h3 id="task-hooks"><a href="https://laravel.com/docs/7.x/scheduling#task-hooks">Task Hooks</a></h3>
<pre><code class="language-php">//可以在任务执行前后安插逻辑
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;before(function () {
        // Task is about to start...
    })-&gt;after(function () {
        // Task is complete...
    });

//可以在任务成功和失败后安插逻辑
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;onSuccess(function () {
        // The task succeeded...
    })-&gt;onFailure(function () {
        // The task is failed...
    });


$url = '';
//可以在任务执行前或完成后ping一个URL
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;pingBefore($url)
    -&gt;thenPing($url);

//条件为真才ping
$condition = true;
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;pingBeforeIf($condition, $url)
    -&gt;thenPingIf($condition, $url);


//任务执行成功或失败后ping url
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;pingOnSuccess($url)
    -&gt;pingOnFailure($url);
</code></pre>
<blockquote>
<p>上面所有的ping 方法需要安装Guzzle Http包;</p>
<p>执行 <code>composer require guzzlehttp/guzzle</code>安装</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Queues学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-queues-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-queues-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-02T03:40:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>如果你有特别消耗时间的任务的时候，比如发送邮件，这时候用queue延迟一下发送操作，对于你的应用来说，可以急剧的提升请求速度。【用户点发送按钮，然后加入queue，整个应用不会因为卡在发送email过程而长时间等待，而是直接返回给用户，这样用户体验比较好】</p>
<p>如果你的应用在使用queue的时候，需要指定多个queue处理任务，比如一个queue用来存，一个用来发sms，一个用来做点其他的，那么可以给每个queue设置权重，权重越高的越先处理。<em>参考 <a href="https://laravel.com/docs/7.x/queues#connections-vs-queues">Connections Vs. Queues</a>最后一段文本。</em></p>
<h4 id="queuephp中的驱动配置可以参考driver-notes-prerequisites">queue.php中的驱动配置可以参考<a href="https://laravel.com/docs/7.x/queues#driver-prerequisites">Driver Notes &amp; Prerequisites</a></h4>
<h3 id="creating-jobs"><a href="https://laravel.com/docs/7.x/queues#creating-jobs">Creating Jobs</a></h3>
<p>Job用来被queue延迟执行的，主要是handle方法。</p>
<p>job一般是这样dispatch触发：dispatch就是加入到queue中；</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902093716.png" alt="" loading="lazy"></figure>
<p>传入job的model会被序列化，</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902093751.png" alt="" loading="lazy"></figure>
<p>而queue最后管理调用job的handle方法，执行处理。</p>
<blockquote>
<p>详细查看 <a href="https://laravel.com/docs/7.x/queues#class-structure">Class Structure</a> 以及 <a href="https://laravel.com/docs/7.x/queues#job-middleware">Job Middleware</a></p>
</blockquote>
<h3 id="dispatching-jobs"><a href="https://laravel.com/docs/7.x/queues#dispatching-jobs">Dispatching Jobs</a></h3>
<p>触发job查看官方文档。</p>
<p>如果要处理一个比如，发送邮件完毕且响应传回后才执行的job，可以使用</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902095041.png" alt="" loading="lazy"></figure>
<p>这两个方法；</p>
<p>如果不需要加入到queue而是需要立即处理掉job：</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902095315.png" alt="" loading="lazy"></figure>
<p>如果需要执行一列跟随任务：</p>
<p>参考<a href="https://laravel.com/docs/7.x/queues#job-chaining">Job Chaining</a>，比如</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902100238.png" alt="" loading="lazy"></figure>
<p>当然也可以在chain里加入闭包执行。</p>
<blockquote>
<p>job即使使用$this-&gt;delete()删除，也不会阻止chained的job被执行，除非job chain里面有fail。</p>
</blockquote>
<p>chain的jobs也可以指定connection和queue驱动执行，当然，如果chain里面的job显式指定过queue或者connection，那么该job会使用其指定的queue或connection。</p>
<blockquote>
<p>如果需要对job做等待超时，执行超时，超次限制，频率限制，请查看 <a href="https://laravel.com/docs/7.x/queues#max-job-attempts-and-timeout">Specifying Max Job Attempts / Timeout Values</a></p>
</blockquote>
<p>如果一个queued的job正在修改一个资源，但是这个资源同时只能有一个job去修改编辑，那么需要限制最大的工作job进程。</p>
<blockquote>
<p>请使用funnel做限制 ，参考<a href="https://laravel.com/docs/7.x/queues#rate-limiting">Rate Limiting</a></p>
</blockquote>
<p>需要注意的是，做了这么多限制之后，执行成功到底需要多少次尝试就很难判断了，因此，结合一个延时设置【 <a href="https://laravel.com/docs/7.x/queues#time-based-attempts">time based attempts</a>】会比较有用。</p>
<h3 id="queueing-closures"><a href="https://laravel.com/docs/7.x/queues#queueing-closures">Queueing Closures</a></h3>
<p>不想写job，或者job比较简单，可以直接queue一个闭包，逻辑写闭包里面就行。</p>
<h3 id="running-the-queue-worker"><a href="https://laravel.com/docs/7.x/queues#running-the-queue-worker">Running The Queue Worker</a></h3>
<pre><code class="language-php">php artisan queue:work
</code></pre>
<p>执行启动了<code>queue</code>之后，会一直在后台执行，但是代码的任何修改，<code>work</code>不会有反应，所以部署后，记得重启一下。</p>
<p>不过<code>php artisan queue:listen</code>可以侦听代码变化，不用重启<code>queue</code>，但是<code>listen</code>没有<code>work</code>高效。</p>
<pre><code class="language-php">php artisan queue:work redis --queue=emails
</code></pre>
<p><code>redis</code>就是指定的<code>queue connection</code>，<code>emails</code>就是指定的<code>queue</code>。</p>
<p>更多的queue 命令行操作参数比如权重，单次处理，停止，参考<a href="https://laravel.com/docs/7.x/queues#running-the-queue-worker">Running The Queue Worker</a></p>
<p>请注意：</p>
<blockquote>
<p>The queue uses the <a href="https://laravel.com/docs/7.x/cache">cache</a> to store restart signals, so you should verify a cache driver is properly configured for your application before using this feature.</p>
</blockquote>
<h4 id="job-expirations-timeouts"><a href="https://laravel.com/docs/7.x/queues#job-expirations-and-timeouts">Job Expirations &amp; Timeouts</a></h4>
<p>在您的config / queue.php配置文件中，每个队列连接定义一个retry_after选项。</p>
<p>该选项指定队列连接在重试正在处理的作业之前应等待的秒数。</p>
<p>例如，如果retry_after的值设置为90，则该job如果已处理90秒但未删除，则将其释放回到队列中。</p>
<h3 id="supervisor-configuration"><a href="https://laravel.com/docs/7.x/queues#supervisor-configuration">Supervisor Configuration</a></h3>
<p>如果有需要配置Supervisor，参考这个<a href="https://laravel.com/docs/7.x/queues#supervisor-configuration">Supervisor Configuration</a></p>
<h3 id="dealing-with-failed-jobs"><a href="https://laravel.com/docs/7.x/queues#dealing-with-failed-jobs">Dealing With Failed Jobs</a></h3>
<p>失败job重试，失败job记录到数据表，失败job清理，侦听失败job触发的事件，</p>
<p>如果传入job中的Eloquent模型在job被processing前删除了，job会抛出异常 <code>ModelNotFoundException</code>，默认可以在job类中的处理，参考<a href="https://laravel.com/docs/7.x/queues#ignoring-missing-models">Ignoring Missing Models</a></p>
<h3 id="job-events"><a href="https://laravel.com/docs/7.x/queues#job-events">Job Events</a></h3>
<p>如果需要在queue job执行前后做一些logging或者状态的编辑记录，可以参考<a href="https://laravel.com/docs/7.x/queues#job-events">Job Events</a>，主要是queue facade的before和after方法的调用，以及一个传入JobProcessing或JobProcessed类型事件参数的闭包。</p>
<p>还可以在worker尝试从queue中取一个job之前，执行一些逻辑。每次取之前都会执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Package Development学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-package-development-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-package-development-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-01T16:20:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>开发包主要是给Laravel提供功能。</p>
<blockquote>
<p>有些大佬开发的包，是独立的，任何PHP 框架都可以用，</p>
<p>有的包就必须在Laravel框架才能用，包里可能有routes controllers views 以及configuration之类的，包只是针对Laravel功能的。</p>
<p>Laravel中使用的时候，就是设置在composer.json文件中；</p>
</blockquote>
<p>扩展包里的servicer provider除了用户手动注册在app.php的providers里面，还可以参考<a href="https://laravel.com/docs/7.x/packages#package-discovery">Package Discovery</a>自动处理。</p>
<p>开发包如果有以下的部分，代码写完后，如何配置和发布可以参考：</p>
<blockquote>
<h4 id="resources"><a href="https://laravel.com/docs/7.x/packages#resources">Resources</a></h4>
<h5 id="configuration"><a href="https://laravel.com/docs/7.x/packages#configuration">Configuration</a></h5>
<h5 id="migrations"><a href="https://laravel.com/docs/7.x/packages#migrations">Migrations</a></h5>
<h5 id="factories"><a href="https://laravel.com/docs/7.x/packages#factories">Factories</a></h5>
<h5 id="routes"><a href="https://laravel.com/docs/7.x/packages#routes">Routes</a></h5>
<h4 id="translations"><a href="https://laravel.com/docs/7.x/packages#translations">Translations</a></h4>
<h4 id="views"><a href="https://laravel.com/docs/7.x/packages#views">Views</a></h4>
<h5 id="view-components"><a href="https://laravel.com/docs/7.x/packages#view-components">View Components</a></h5>
<h4 id="commands"><a href="https://laravel.com/docs/7.x/packages#commands">Commands</a></h4>
<h4 id="public-assets"><a href="https://laravel.com/docs/7.x/packages#public-assets">Public Assets</a></h4>
<h4 id="publishing-file-groups"><a href="https://laravel.com/docs/7.x/packages#publishing-file-groups">Publishing File Groups</a></h4>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Notifications学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-notifications-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-notifications-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-01T15:51:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>Notification主要用来发送简洁的通知，告知，比如付款成功之类的，Laravel支持mail，SMS，Slack方式的推送通知给用户。而且因为Notification也可用来显示在web页面上，所以Notification也可以被存在数据库中。</p>
<blockquote>
<p>创建通知参考<a href="https://laravel.com/docs/7.x/notifications#creating-notifications">Creating Notifications</a></p>
</blockquote>
<p>Model类如果需要支持被通知，那请使用<code>Notifiable</code> trait，不只User model可以支持，只要需要，就可以用这个trait。</p>
<blockquote>
<p>使用方法参考<a href="https://laravel.com/docs/7.x/notifications#using-the-notifiable-trait">Using The Notifiable Trait</a></p>
</blockquote>
<p>如果是发送给一组用户或者被通知的Model实例组，那可以使用Notification facade的<code>send</code>方法。</p>
<blockquote>
<p>使用方法具体参考<a href="https://laravel.com/docs/7.x/notifications#using-the-notification-facade">Using The Notification Facade</a></p>
</blockquote>
<p>因为Notifications发送时需要消耗时间的，特别是还要调用外部API来发送的场景下，那么请启用Queue；【就是 implements the ShouldQueue，但是使用还是和平常一样】</p>
<blockquote>
<p>具体参考<a href="https://laravel.com/docs/7.x/notifications#queueing-notifications">Queueing Notifications</a></p>
</blockquote>
<p>因为Notification的via方法是支持返回一组数组--如<code>['mail','slack']</code></p>
<p>就是这个通知发送将使用<code>['mail','slack']</code>两个渠道，而使用<code>queue</code>来处理发送的时候，可以针对这两个渠道，分别指定不同的<code>queue</code>处理。</p>
<blockquote>
<p>具体参考<a href="https://laravel.com/docs/7.x/notifications#queueing-notifications">Queueing Notifications</a>的Customizing Notification Channel Queues部分</p>
</blockquote>
<p>如果需要搞一个<em>按需通知</em>，可以使用<code>Notification::route</code>方法。</p>
<blockquote>
<p>具体参考<a href="https://laravel.com/docs/7.x/notifications#on-demand-notifications">On-Demand Notifications</a></p>
</blockquote>
<p>如果需要更改Mail Notification的Header和Footer的name值，请在<code>config/app.php</code>中设置<code>name</code>；</p>
<blockquote>
<p>如果需要了解怎么写一个Notification Email 以及更多的方法 请参考<a href="https://laravel.com/docs/7.x/notifications#mail-notifications">Mail Notifications</a></p>
</blockquote>
<blockquote>
<p>如果需要自定义Mail Notification或有更多的配置需求，可以查看<br>
<a href="https://laravel.com/docs/7.x/notifications#customizing-the-sender">Customizing The Sender</a><br>
<a href="https://laravel.com/docs/7.x/notifications#customizing-the-recipient">Customizing The Recipient</a><br>
<a href="https://laravel.com/docs/7.x/notifications#customizing-the-subject">Customizing The Subject</a><br>
<a href="https://laravel.com/docs/7.x/notifications#customizing-the-mailer">Customizing The Mailer</a><br>
如果需要对默认给的Notification邮件模板做一些自定义修改，参考<a href="https://laravel.com/docs/7.x/notifications#customizing-the-templates">Customizing The Templates</a></p>
<p>如果需要预览Notification Mail，可以参考<a href="https://laravel.com/docs/7.x/notifications#previewing-mail-notifications">Previewing Mail Notifications</a></p>
<p>每个就是一个方法的讲解而已。很简单</p>
</blockquote>
<h4 id="markdown-mail-notifications">Markdown Mail Notifications</h4>
<p>和Mail Notification差不多，只是不再使用action或者line方法调用来生成邮件内容，而是一个markdown方法调用。</p>
<blockquote>
<p>具体参考 <a href="https://laravel.com/docs/7.x/notifications#generating-the-message">Generating The Message</a></p>
</blockquote>
<p>而如果要修改邮件内容，就需要前面修改编辑markdown文件了；</p>
<blockquote>
<p>如何使用参考  <a href="https://laravel.com/docs/7.x/notifications#writing-the-message">Writing The Message</a></p>
</blockquote>
<blockquote>
<p>而每一个组件的修改编辑参考<a href="https://laravel.com/docs/7.x/notifications#customizing-the-components">Customizing The Components</a>，其实之前学习Email的时候，也是这个；</p>
</blockquote>
<h3 id="database-notifications"><a href="https://laravel.com/docs/7.x/notifications#database-notifications">Database Notifications</a></h3>
<p>主要是notification如果需要显示在页面上，这样就会用到database。比如用户登录了，就在dashbroad页面给显示notifications。</p>
<p>参考<a href="https://laravel.com/docs/7.x/notifications#database-prerequisites">Prerequisites</a>，先执行：</p>
<pre><code class="language-php">php artisan notifications:table

php artisan migrate
</code></pre>
<p>生成notification的数据表。</p>
<blockquote>
<p>定义被存储下来的数据，请参考<a href="https://laravel.com/docs/7.x/notifications#formatting-database-notifications">Formatting Database Notifications</a></p>
</blockquote>
<blockquote>
<p>存储下来的notifications数据，要展示出来的时候，请参考<a href="https://laravel.com/docs/7.x/notifications#accessing-the-notifications">Accessing The Notifications</a></p>
</blockquote>
<blockquote>
<p>现实使用的时候，可以添加一个Notification Controller，这样要从js客户端访问这个notifiable实体【比如当前user】的notifications数据的时候，可以从js客户端向后端的这个controller执行一个HTTP请求获取。</p>
</blockquote>
<blockquote>
<p>其他的标注已读，批量标注已读，批量更新，批量删除，请查阅<a href="https://laravel.com/docs/7.x/notifications#marking-notifications-as-read">Marking Notifications As Read</a></p>
</blockquote>
<h3 id="broadcast-notifications"><a href="https://laravel.com/docs/7.x/notifications#broadcast-notifications">Broadcast Notifications</a></h3>
<p>这个用就很牛了，可以做成聊天室式的广播告知【游戏里的大喇叭式，全站送礼物通知】。前端后端都需要参考Broadcasting做一些设置。</p>
<h3 id="sms-notifications"><a href="https://laravel.com/docs/7.x/notifications#sms-notifications">SMS Notifications</a></h3>
<p>如果有需要搞一个短信通知，那可以参考这个官方文档<a href="https://laravel.com/docs/7.x/notifications#sms-notifications">SMS Notifications</a>做一些设置和修改。</p>
<h3 id="slack-notifications"><a href="https://laravel.com/docs/7.x/notifications#slack-notifications">Slack Notifications</a></h3>
<p><a href="slack.com">Slack</a>可以用到协同办公和公共留言板之类的，支持很多app，如果需要这个可以看看官方文档如何配置。</p>
<h3 id="localizing-notifications"><a href="https://laravel.com/docs/7.x/notifications#localizing-notifications">Localizing Notifications</a></h3>
<p>语言本地化；</p>
<h3 id="notification-events"><a href="https://laravel.com/docs/7.x/notifications#notification-events">Notification Events</a></h3>
<p>在notification被发送后，会触发相关的事件，如果需要了解，请参考官方文档</p>
<h3 id="custom-channels"><a href="https://laravel.com/docs/7.x/notifications#custom-channels">Custom Channels</a></h3>
<p>Laravel以及提供了很多Notification发送的信道，如果还有更多需求来传输你的Notification，那么可以参考此部分文档：<a href="https://laravel.com/docs/7.x/notifications#custom-channels">Custom Channels</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Mail学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-mail-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-mail-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-01T07:31:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>Mail不用说，就是发邮件的时候使用，那么官方文档里介绍的功能，就应该主要思考，发邮件需要什么功能的时候才能够用上？</p>
<p>而这种场景下要用的功能，具体怎么配置，使用方法就不介绍，需要的时候参阅官方文档。 <strong>主要思考的是使用场景，而不是使用方法。</strong></p>
<h3 id="driver">Driver</h3>
<p>如果需要的是更加简便快捷的Email发送服务器，比SMTP更快的，那就是API式的服务器，比如MailGun或者Postmark。</p>
<blockquote>
<p>Mailgun和Postmark的配置使用参考<a href="https://laravel.com/docs/7.x/mail#driver-prerequisites">Driver Prerequisites</a></p>
</blockquote>
<p>如果需要Amazon SES驱动可以参考<a href="https://laravel.com/docs/7.x/mail#driver-prerequisites">Driver Prerequisites</a></p>
<h3 id="mailables">Mailables</h3>
<blockquote>
<p>Laravel发出的Email，就是被叫做可邮件化的类。</p>
<p>需要生成这个类，请参考<a href="https://laravel.com/docs/7.x/mail#generating-mailables">Generating Mailables</a></p>
<p>具体如何编辑这个类，请参考<a href="https://laravel.com/docs/7.x/mail#writing-mailables">Writing Mailables</a></p>
</blockquote>
<p>如果需要在邮件发送前，再执行某些自定义修改，可以使用<a href="https://laravel.com/docs/7.x/mail#customizing-the-swiftmailer-message">withSwiftMessage方法</a>。</p>
<h4 id="markdown-mailables">MarkDown Mailables</h4>
<blockquote>
<p>直接有预置模板，而且同时可以生成响应式HTML模板和对应的纯文本邮件内容。使用参考<a href="https://laravel.com/docs/7.x/mail#markdown-mailables">Markdown Mailables</a></p>
</blockquote>
<blockquote>
<p>Markdown可邮递类，结合了Blade组件和Markdown语法。</p>
<p><strong>特别需要注意的是，Markdown解析器会把缩进给解析为代码块</strong>，所以不要CTRL+SHIFT+L做代码格式化。</p>
</blockquote>
<p>预制的button组件，Panel组件，Table组件等直接开箱可用，需要了解可以参考 <a href="https://laravel.com/docs/7.x/mail#writing-markdown-messages">Writing Markdown Messages</a></p>
<p>很多情况下，邮件要做个自定义的样式，那么参考<a href="https://laravel.com/docs/7.x/mail#customizing-the-components">Customizing The Components</a></p>
<p>有需要queue 发送Mail的，可以参考<a href="https://laravel.com/docs/7.x/mail#queueing-mail">Queueing Mail</a></p>
<p>如果需要不发出邮件但是查看以文本样式渲染出来的Mail，可以参考<a href="https://laravel.com/docs/7.x/mail#rendering-mailables">Rendering Mailables</a></p>
<p>测试发送邮件，如果不是发送到真地址来看效果，可以使用log 邮件驱动，把邮件发出存到log文件里面；或者在mail.php文件中设置一个全局的to地址，或者<strong>使用Mailtrap，这个也是比较建议的。</strong></p>
<h3 id="events">Events</h3>
<p>邮件的发送会触发一系列的事件，详细参考<a href="https://laravel.com/docs/7.x/mail#events">Events</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel HTTP Client 学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-http-client-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-http-client-xue-xi-ti-gang/">
        </link>
        <updated>2020-08-31T17:50:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>如果有需要向外发送HTTP请求，因为Laravel包裹了<a href="http://docs.guzzlephp.org/en/stable/">Guzzle</a>，可以执行HTTP请求处理。不过需要提前执行<code>composer require guzzlehttp/guzzle</code>安装。</p>
<p>对于包含的guzzle请求，响应结果处理，异常处理，和发送方法，以及Http使用fake方法测试及asset断言，都参考<a href="https://laravel.com/docs/7.x/http-client">官方文档</a></p>
]]></content>
    </entry>
</feed>