<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dzkjz.github.io/</id>
    <title>JojoLegend</title>
    <updated>2020-09-02T03:40:50.565Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dzkjz.github.io/"/>
    <link rel="self" href="https://dzkjz.github.io/atom.xml"/>
    <subtitle>Something for age</subtitle>
    <logo>https://dzkjz.github.io/images/avatar.png</logo>
    <icon>https://dzkjz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JojoLegend</rights>
    <entry>
        <title type="html"><![CDATA[Laravel Queues学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-queues-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-queues-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-02T03:40:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>如果你有特别消耗时间的任务的时候，比如发送邮件，这时候用queue延迟一下发送操作，对于你的应用来说，可以急剧的提升请求速度。【用户点发送按钮，然后加入queue，整个应用不会因为卡在发送email过程而长时间等待，而是直接返回给用户，这样用户体验比较好】</p>
<p>如果你的应用在使用queue的时候，需要指定多个queue处理任务，比如一个queue用来存，一个用来发sms，一个用来做点其他的，那么可以给每个queue设置权重，权重越高的越先处理。<em>参考 <a href="https://laravel.com/docs/7.x/queues#connections-vs-queues">Connections Vs. Queues</a>最后一段文本。</em></p>
<h4 id="queuephp中的驱动配置可以参考driver-notes-prerequisites">queue.php中的驱动配置可以参考<a href="https://laravel.com/docs/7.x/queues#driver-prerequisites">Driver Notes &amp; Prerequisites</a></h4>
<h3 id="creating-jobs"><a href="https://laravel.com/docs/7.x/queues#creating-jobs">Creating Jobs</a></h3>
<p>Job用来被queue延迟执行的，主要是handle方法。</p>
<p>job一般是这样dispatch触发：dispatch就是加入到queue中；</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902093716.png" alt="" loading="lazy"></figure>
<p>传入job的model会被序列化，</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902093751.png" alt="" loading="lazy"></figure>
<p>而queue最后管理调用job的handle方法，执行处理。</p>
<blockquote>
<p>详细查看 <a href="https://laravel.com/docs/7.x/queues#class-structure">Class Structure</a> 以及 <a href="https://laravel.com/docs/7.x/queues#job-middleware">Job Middleware</a></p>
</blockquote>
<h3 id="dispatching-jobs"><a href="https://laravel.com/docs/7.x/queues#dispatching-jobs">Dispatching Jobs</a></h3>
<p>触发job查看官方文档。</p>
<p>如果要处理一个比如，发送邮件完毕且响应传回后才执行的job，可以使用</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902095041.png" alt="" loading="lazy"></figure>
<p>这两个方法；</p>
<p>如果不需要加入到queue而是需要立即处理掉job：</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902095315.png" alt="" loading="lazy"></figure>
<p>如果需要执行一列跟随任务：</p>
<p>参考<a href="https://laravel.com/docs/7.x/queues#job-chaining">Job Chaining</a>，比如</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902100238.png" alt="" loading="lazy"></figure>
<p>当然也可以在chain里加入闭包执行。</p>
<blockquote>
<p>job即使使用$this-&gt;delete()删除，也不会阻止chained的job被执行，除非job chain里面有fail。</p>
</blockquote>
<p>chain的jobs也可以指定connection和queue驱动执行，当然，如果chain里面的job显式指定过queue或者connection，那么该job会使用其指定的queue或connection。</p>
<blockquote>
<p>如果需要对job做等待超时，执行超时，超次限制，频率限制，请查看 <a href="https://laravel.com/docs/7.x/queues#max-job-attempts-and-timeout">Specifying Max Job Attempts / Timeout Values</a></p>
</blockquote>
<p>如果一个queued的job正在修改一个资源，但是这个资源同时只能有一个job去修改编辑，那么需要限制最大的工作job进程。</p>
<blockquote>
<p>请使用funnel做限制 ，参考<a href="https://laravel.com/docs/7.x/queues#rate-limiting">Rate Limiting</a></p>
</blockquote>
<p>需要注意的是，做了这么多限制之后，执行成功到底需要多少次尝试就很难判断了，因此，结合一个延时设置【 <a href="https://laravel.com/docs/7.x/queues#time-based-attempts">time based attempts</a>】会比较有用。</p>
<h3 id="queueing-closures"><a href="https://laravel.com/docs/7.x/queues#queueing-closures">Queueing Closures</a></h3>
<p>不想写job，或者job比较简单，可以直接queue一个闭包，逻辑写闭包里面就行。</p>
<h3 id="running-the-queue-worker"><a href="https://laravel.com/docs/7.x/queues#running-the-queue-worker">Running The Queue Worker</a></h3>
<pre><code class="language-php">php artisan queue:work
</code></pre>
<p>执行启动了<code>queue</code>之后，会一直在后台执行，但是代码的任何修改，<code>work</code>不会有反应，所以部署后，记得重启一下。</p>
<p>不过<code>php artisan queue:listen</code>可以侦听代码变化，不用重启<code>queue</code>，但是<code>listen</code>没有<code>work</code>高效。</p>
<pre><code class="language-php">php artisan queue:work redis --queue=emails
</code></pre>
<p><code>redis</code>就是指定的<code>queue connection</code>，<code>emails</code>就是指定的<code>queue</code>。</p>
<p>更多的queue 命令行操作参数比如权重，单次处理，停止，参考<a href="https://laravel.com/docs/7.x/queues#running-the-queue-worker">Running The Queue Worker</a></p>
<p>请注意：</p>
<blockquote>
<p>The queue uses the <a href="https://laravel.com/docs/7.x/cache">cache</a> to store restart signals, so you should verify a cache driver is properly configured for your application before using this feature.</p>
</blockquote>
<h4 id="job-expirations-timeouts"><a href="https://laravel.com/docs/7.x/queues#job-expirations-and-timeouts">Job Expirations &amp; Timeouts</a></h4>
<p>在您的config / queue.php配置文件中，每个队列连接定义一个retry_after选项。</p>
<p>该选项指定队列连接在重试正在处理的作业之前应等待的秒数。</p>
<p>例如，如果retry_after的值设置为90，则该job如果已处理90秒但未删除，则将其释放回到队列中。</p>
<h3 id="supervisor-configuration"><a href="https://laravel.com/docs/7.x/queues#supervisor-configuration">Supervisor Configuration</a></h3>
<p>如果有需要配置Supervisor，参考这个<a href="https://laravel.com/docs/7.x/queues#supervisor-configuration">Supervisor Configuration</a></p>
<h3 id="dealing-with-failed-jobs"><a href="https://laravel.com/docs/7.x/queues#dealing-with-failed-jobs">Dealing With Failed Jobs</a></h3>
<p>失败job重试，失败job记录到数据表，失败job清理，侦听失败job触发的事件，</p>
<p>如果传入job中的Eloquent模型在job被processing前删除了，job会抛出异常 <code>ModelNotFoundException</code>，默认可以在job类中的处理，参考<a href="https://laravel.com/docs/7.x/queues#ignoring-missing-models">Ignoring Missing Models</a></p>
<h3 id="job-events"><a href="https://laravel.com/docs/7.x/queues#job-events">Job Events</a></h3>
<p>如果需要在queue job执行前后做一些logging或者状态的编辑记录，可以参考<a href="https://laravel.com/docs/7.x/queues#job-events">Job Events</a>，主要是queue facade的before和after方法的调用，以及一个传入JobProcessing或JobProcessed类型事件参数的闭包。</p>
<p>还可以在worker尝试从queue中取一个job之前，执行一些逻辑。每次取之前都会执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Package Development学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-package-development-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-package-development-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-01T16:20:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>开发包主要是给Laravel提供功能。</p>
<blockquote>
<p>有些大佬开发的包，是独立的，任何PHP 框架都可以用，</p>
<p>有的包就必须在Laravel框架才能用，包里可能有routes controllers views 以及configuration之类的，包只是针对Laravel功能的。</p>
<p>Laravel中使用的时候，就是设置在composer.json文件中；</p>
</blockquote>
<p>扩展包里的servicer provider除了用户手动注册在app.php的providers里面，还可以参考<a href="https://laravel.com/docs/7.x/packages#package-discovery">Package Discovery</a>自动处理。</p>
<p>开发包如果有以下的部分，代码写完后，如何配置和发布可以参考：</p>
<blockquote>
<h4 id="resources"><a href="https://laravel.com/docs/7.x/packages#resources">Resources</a></h4>
<h5 id="configuration"><a href="https://laravel.com/docs/7.x/packages#configuration">Configuration</a></h5>
<h5 id="migrations"><a href="https://laravel.com/docs/7.x/packages#migrations">Migrations</a></h5>
<h5 id="factories"><a href="https://laravel.com/docs/7.x/packages#factories">Factories</a></h5>
<h5 id="routes"><a href="https://laravel.com/docs/7.x/packages#routes">Routes</a></h5>
<h4 id="translations"><a href="https://laravel.com/docs/7.x/packages#translations">Translations</a></h4>
<h4 id="views"><a href="https://laravel.com/docs/7.x/packages#views">Views</a></h4>
<h5 id="view-components"><a href="https://laravel.com/docs/7.x/packages#view-components">View Components</a></h5>
<h4 id="commands"><a href="https://laravel.com/docs/7.x/packages#commands">Commands</a></h4>
<h4 id="public-assets"><a href="https://laravel.com/docs/7.x/packages#public-assets">Public Assets</a></h4>
<h4 id="publishing-file-groups"><a href="https://laravel.com/docs/7.x/packages#publishing-file-groups">Publishing File Groups</a></h4>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Notifications学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-notifications-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-notifications-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-01T15:51:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>Notification主要用来发送简洁的通知，告知，比如付款成功之类的，Laravel支持mail，SMS，Slack方式的推送通知给用户。而且因为Notification也可用来显示在web页面上，所以Notification也可以被存在数据库中。</p>
<blockquote>
<p>创建通知参考<a href="https://laravel.com/docs/7.x/notifications#creating-notifications">Creating Notifications</a></p>
</blockquote>
<p>Model类如果需要支持被通知，那请使用<code>Notifiable</code> trait，不只User model可以支持，只要需要，就可以用这个trait。</p>
<blockquote>
<p>使用方法参考<a href="https://laravel.com/docs/7.x/notifications#using-the-notifiable-trait">Using The Notifiable Trait</a></p>
</blockquote>
<p>如果是发送给一组用户或者被通知的Model实例组，那可以使用Notification facade的<code>send</code>方法。</p>
<blockquote>
<p>使用方法具体参考<a href="https://laravel.com/docs/7.x/notifications#using-the-notification-facade">Using The Notification Facade</a></p>
</blockquote>
<p>因为Notifications发送时需要消耗时间的，特别是还要调用外部API来发送的场景下，那么请启用Queue；【就是 implements the ShouldQueue，但是使用还是和平常一样】</p>
<blockquote>
<p>具体参考<a href="https://laravel.com/docs/7.x/notifications#queueing-notifications">Queueing Notifications</a></p>
</blockquote>
<p>因为Notification的via方法是支持返回一组数组--如<code>['mail','slack']</code></p>
<p>就是这个通知发送将使用<code>['mail','slack']</code>两个渠道，而使用<code>queue</code>来处理发送的时候，可以针对这两个渠道，分别指定不同的<code>queue</code>处理。</p>
<blockquote>
<p>具体参考<a href="https://laravel.com/docs/7.x/notifications#queueing-notifications">Queueing Notifications</a>的Customizing Notification Channel Queues部分</p>
</blockquote>
<p>如果需要搞一个<em>按需通知</em>，可以使用<code>Notification::route</code>方法。</p>
<blockquote>
<p>具体参考<a href="https://laravel.com/docs/7.x/notifications#on-demand-notifications">On-Demand Notifications</a></p>
</blockquote>
<p>如果需要更改Mail Notification的Header和Footer的name值，请在<code>config/app.php</code>中设置<code>name</code>；</p>
<blockquote>
<p>如果需要了解怎么写一个Notification Email 以及更多的方法 请参考<a href="https://laravel.com/docs/7.x/notifications#mail-notifications">Mail Notifications</a></p>
</blockquote>
<blockquote>
<p>如果需要自定义Mail Notification或有更多的配置需求，可以查看<br>
<a href="https://laravel.com/docs/7.x/notifications#customizing-the-sender">Customizing The Sender</a><br>
<a href="https://laravel.com/docs/7.x/notifications#customizing-the-recipient">Customizing The Recipient</a><br>
<a href="https://laravel.com/docs/7.x/notifications#customizing-the-subject">Customizing The Subject</a><br>
<a href="https://laravel.com/docs/7.x/notifications#customizing-the-mailer">Customizing The Mailer</a><br>
如果需要对默认给的Notification邮件模板做一些自定义修改，参考<a href="https://laravel.com/docs/7.x/notifications#customizing-the-templates">Customizing The Templates</a></p>
<p>如果需要预览Notification Mail，可以参考<a href="https://laravel.com/docs/7.x/notifications#previewing-mail-notifications">Previewing Mail Notifications</a></p>
<p>每个就是一个方法的讲解而已。很简单</p>
</blockquote>
<h4 id="markdown-mail-notifications">Markdown Mail Notifications</h4>
<p>和Mail Notification差不多，只是不再使用action或者line方法调用来生成邮件内容，而是一个markdown方法调用。</p>
<blockquote>
<p>具体参考 <a href="https://laravel.com/docs/7.x/notifications#generating-the-message">Generating The Message</a></p>
</blockquote>
<p>而如果要修改邮件内容，就需要前面修改编辑markdown文件了；</p>
<blockquote>
<p>如何使用参考  <a href="https://laravel.com/docs/7.x/notifications#writing-the-message">Writing The Message</a></p>
</blockquote>
<blockquote>
<p>而每一个组件的修改编辑参考<a href="https://laravel.com/docs/7.x/notifications#customizing-the-components">Customizing The Components</a>，其实之前学习Email的时候，也是这个；</p>
</blockquote>
<h3 id="database-notifications"><a href="https://laravel.com/docs/7.x/notifications#database-notifications">Database Notifications</a></h3>
<p>主要是notification如果需要显示在页面上，这样就会用到database。比如用户登录了，就在dashbroad页面给显示notifications。</p>
<p>参考<a href="https://laravel.com/docs/7.x/notifications#database-prerequisites">Prerequisites</a>，先执行：</p>
<pre><code class="language-php">php artisan notifications:table

php artisan migrate
</code></pre>
<p>生成notification的数据表。</p>
<blockquote>
<p>定义被存储下来的数据，请参考<a href="https://laravel.com/docs/7.x/notifications#formatting-database-notifications">Formatting Database Notifications</a></p>
</blockquote>
<blockquote>
<p>存储下来的notifications数据，要展示出来的时候，请参考<a href="https://laravel.com/docs/7.x/notifications#accessing-the-notifications">Accessing The Notifications</a></p>
</blockquote>
<blockquote>
<p>现实使用的时候，可以添加一个Notification Controller，这样要从js客户端访问这个notifiable实体【比如当前user】的notifications数据的时候，可以从js客户端向后端的这个controller执行一个HTTP请求获取。</p>
</blockquote>
<blockquote>
<p>其他的标注已读，批量标注已读，批量更新，批量删除，请查阅<a href="https://laravel.com/docs/7.x/notifications#marking-notifications-as-read">Marking Notifications As Read</a></p>
</blockquote>
<h3 id="broadcast-notifications"><a href="https://laravel.com/docs/7.x/notifications#broadcast-notifications">Broadcast Notifications</a></h3>
<p>这个用就很牛了，可以做成聊天室式的广播告知【游戏里的大喇叭式，全站送礼物通知】。前端后端都需要参考Broadcasting做一些设置。</p>
<h3 id="sms-notifications"><a href="https://laravel.com/docs/7.x/notifications#sms-notifications">SMS Notifications</a></h3>
<p>如果有需要搞一个短信通知，那可以参考这个官方文档<a href="https://laravel.com/docs/7.x/notifications#sms-notifications">SMS Notifications</a>做一些设置和修改。</p>
<h3 id="slack-notifications"><a href="https://laravel.com/docs/7.x/notifications#slack-notifications">Slack Notifications</a></h3>
<p><a href="slack.com">Slack</a>可以用到协同办公和公共留言板之类的，支持很多app，如果需要这个可以看看官方文档如何配置。</p>
<h3 id="localizing-notifications"><a href="https://laravel.com/docs/7.x/notifications#localizing-notifications">Localizing Notifications</a></h3>
<p>语言本地化；</p>
<h3 id="notification-events"><a href="https://laravel.com/docs/7.x/notifications#notification-events">Notification Events</a></h3>
<p>在notification被发送后，会触发相关的事件，如果需要了解，请参考官方文档</p>
<h3 id="custom-channels"><a href="https://laravel.com/docs/7.x/notifications#custom-channels">Custom Channels</a></h3>
<p>Laravel以及提供了很多Notification发送的信道，如果还有更多需求来传输你的Notification，那么可以参考此部分文档：<a href="https://laravel.com/docs/7.x/notifications#custom-channels">Custom Channels</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Mail学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-mail-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-mail-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-01T07:31:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>Mail不用说，就是发邮件的时候使用，那么官方文档里介绍的功能，就应该主要思考，发邮件需要什么功能的时候才能够用上？</p>
<p>而这种场景下要用的功能，具体怎么配置，使用方法就不介绍，需要的时候参阅官方文档。 <strong>主要思考的是使用场景，而不是使用方法。</strong></p>
<h3 id="driver">Driver</h3>
<p>如果需要的是更加简便快捷的Email发送服务器，比SMTP更快的，那就是API式的服务器，比如MailGun或者Postmark。</p>
<blockquote>
<p>Mailgun和Postmark的配置使用参考<a href="https://laravel.com/docs/7.x/mail#driver-prerequisites">Driver Prerequisites</a></p>
</blockquote>
<p>如果需要Amazon SES驱动可以参考<a href="https://laravel.com/docs/7.x/mail#driver-prerequisites">Driver Prerequisites</a></p>
<h3 id="mailables">Mailables</h3>
<blockquote>
<p>Laravel发出的Email，就是被叫做可邮件化的类。</p>
<p>需要生成这个类，请参考<a href="https://laravel.com/docs/7.x/mail#generating-mailables">Generating Mailables</a></p>
<p>具体如何编辑这个类，请参考<a href="https://laravel.com/docs/7.x/mail#writing-mailables">Writing Mailables</a></p>
</blockquote>
<p>如果需要在邮件发送前，再执行某些自定义修改，可以使用<a href="https://laravel.com/docs/7.x/mail#customizing-the-swiftmailer-message">withSwiftMessage方法</a>。</p>
<h4 id="markdown-mailables">MarkDown Mailables</h4>
<blockquote>
<p>直接有预置模板，而且同时可以生成响应式HTML模板和对应的纯文本邮件内容。使用参考<a href="https://laravel.com/docs/7.x/mail#markdown-mailables">Markdown Mailables</a></p>
</blockquote>
<blockquote>
<p>Markdown可邮递类，结合了Blade组件和Markdown语法。</p>
<p><strong>特别需要注意的是，Markdown解析器会把缩进给解析为代码块</strong>，所以不要CTRL+SHIFT+L做代码格式化。</p>
</blockquote>
<p>预制的button组件，Panel组件，Table组件等直接开箱可用，需要了解可以参考 <a href="https://laravel.com/docs/7.x/mail#writing-markdown-messages">Writing Markdown Messages</a></p>
<p>很多情况下，邮件要做个自定义的样式，那么参考<a href="https://laravel.com/docs/7.x/mail#customizing-the-components">Customizing The Components</a></p>
<p>有需要queue 发送Mail的，可以参考<a href="https://laravel.com/docs/7.x/mail#queueing-mail">Queueing Mail</a></p>
<p>如果需要不发出邮件但是查看以文本样式渲染出来的Mail，可以参考<a href="https://laravel.com/docs/7.x/mail#rendering-mailables">Rendering Mailables</a></p>
<p>测试发送邮件，如果不是发送到真地址来看效果，可以使用log 邮件驱动，把邮件发出存到log文件里面；或者在mail.php文件中设置一个全局的to地址，或者<strong>使用Mailtrap，这个也是比较建议的。</strong></p>
<h3 id="events">Events</h3>
<p>邮件的发送会触发一系列的事件，详细参考<a href="https://laravel.com/docs/7.x/mail#events">Events</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel HTTP Client 学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-http-client-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-http-client-xue-xi-ti-gang/">
        </link>
        <updated>2020-08-31T17:50:17.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>如果有需要向外发送HTTP请求，因为Laravel包裹了<a href="http://docs.guzzlephp.org/en/stable/">Guzzle</a>，可以执行HTTP请求处理。不过需要提前执行<code>composer require guzzlehttp/guzzle</code>安装。</p>
<p>对于包含的guzzle请求，响应结果处理，异常处理，和发送方法，以及Http使用fake方法测试及asset断言，都参考<a href="https://laravel.com/docs/7.x/http-client">官方文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel File Storage[FileSystem] 学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-file-storagefilesystem-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-file-storagefilesystem-xue-xi-ti-gang/">
        </link>
        <updated>2020-08-31T17:16:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<blockquote>
<p>​	Laravel提供了强大的文件抽象特性。</p>
</blockquote>
<blockquote>
<p>对于文件存取，文件夹存取，disk配置，与Request交互，文件数据更新，追加数据，文件属性信息获取，文件URL获取与配置，以及自定义文件系统，请查看官方文档。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Collection 学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-collection-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-collection-xue-xi-ti-gang/">
        </link>
        <updated>2020-08-31T07:43:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学习，文档上介绍的功能在什么时候可以用？用来做什么？具体的用法请查看官方文档</strong></p>
</blockquote>
<ol>
<li>
<p>Collection主要是用来提供更方便的方法处理array数据的；</p>
</li>
<li>
<p>并且collection里方法都是返回一个新的collection实例，意味着可以写出面条代码，而原来的底层数据就不会被修改，就会完整的保留下来。</p>
</li>
<li>
<p>Eloquent查询的结果基本上也是返回的collection实例。</p>
</li>
</ol>
<blockquote>
<p>Collection有很多的方法，查看官方文档<a href="https://laravel.com/docs/7.x/collections#available-methods">Available Methods</a></p>
</blockquote>
<h3 id="higher-order-messages">Higher Order Messages</h3>
<blockquote>
<p>平时的方法：</p>
<pre><code class="language-php">$users = User::where('votes', '&gt;', 500)-&gt;get();

$users-&gt;each(function($item,$key){
    $item-&gt;markAsVip();
});
</code></pre>
<p>如each：</p>
<pre><code class="language-php">$users = User::where('votes', '&gt;', 500)-&gt;get();

$users-&gt;each-&gt;markAsVip();
</code></pre>
</blockquote>
<h3 id="lazycollection">LazyCollection</h3>
<p>对于需要读取大文件，数据量比较大的数据【10万条Eloquent模型数据】到collection里面，可以用LazyCollection，底层主要是PHP yield，这样不用一次性读取完到内存，而是一次一取一读。</p>
<blockquote>
<p>如果10万条数据一次用这种方式读取，那内存占用太大了：</p>
<pre><code class="language-php">$users = App\User::all()-&gt;filter(function ($user) {
 return $user-&gt;id &gt; 500;
});
</code></pre>
<p>Eloquent有一个cursor方法返回的是LazyCollection实例，一次读取一条，这样内存不会卡爆：</p>
<blockquote>
<pre><code class="language-php">$users = App\User::cursor()-&gt;filter(function ($user) {
return $user-&gt;id &gt; 500;
});

foreach ($users as $user) {
echo $user-&gt;id;
}
</code></pre>
</blockquote>
<p>当然，filter方法并不会在foreach之前就执行，而是在foreach中每次迭代的时候执行。</p>
</blockquote>
<p>LazyCollection 有2个与Collection不同的方法可以看下官方文档<a href="https://laravel.com/docs/7.x/collections#lazy-collection-methods">Lazy Collection Methods</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Cache学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-cache-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-cache-xue-xi-ti-gang/">
        </link>
        <updated>2020-08-30T14:47:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学：文档上介绍的功能在什么情况下使用，有什么作用？</strong></p>
</blockquote>
<blockquote>
<p>一般建议使用<code>Memcached</code>或者<code>Redis</code>。</p>
</blockquote>
<h3 id="cache使用方法">Cache使用方法</h3>
<blockquote>
<p>Cache的增删改查具体使用方法，请查看官方文档。</p>
<p>利用Mock方式进行Cache测试的时候，需要调用<code>Cache::shouldReceive</code>方法提供值。</p>
</blockquote>
<h3 id="cache-tags">Cache Tags</h3>
<p>给一堆的Cache值分组打标签需用到<code>Cache Tags</code>。</p>
<blockquote>
<p>Cache Tags 不被<code>file</code> 、<code>dynamodb</code>及 <code>database</code>驱动所支持，特别是如果需要使用多Tags的永久存储，memcached驱动时最优选择，性能最好，并自动清楚陈旧记录值。</p>
</blockquote>
<blockquote>
<p>Cache Tags的增删改读请查看<a href="https://laravel.com/docs/7.x/cache#cache-tags">官方文档</a></p>
</blockquote>
<h3 id="原子锁">原子锁</h3>
<p>原子锁只有在<code>memcached</code>,<code>dynamodb</code>,<code>redis</code>,<code>database</code>,<code>array</code>作为cache驱动的时候才能被使用。而且所有的servers【从属服务器】都必须与相同的中央cache server【主服务器】通信。</p>
<blockquote>
<p>每个类型的驱动如何配置，原子锁的具体使用，方法调用请查看<a href="https://laravel.com/docs/7.x/cache#atomic-locks">官方文档</a></p>
</blockquote>
<blockquote>
<p>跨进程管理原子锁，比如http请求的时候加锁，但是解锁是放在queue job或者某个事件触发逻辑之后。具体请查看<a href="https://laravel.com/docs/7.x/cache#managing-locks-across-processes">官方文档</a></p>
</blockquote>
<h3 id="添加自定义cache驱动">添加自定义Cache驱动</h3>
<blockquote>
<p>参考 <a href="https://laravel.com/docs/7.x/cache#adding-custom-cache-drivers">Adding Custom Cache Drivers</a></p>
</blockquote>
<h3 id="事件">事件</h3>
<blockquote>
<p>Cache的操作会触发事件，如果有需要监听这些事件做响应的操作，可以设置监听器，设置在EventServiceProvider类中，具体参考<a href="https://laravel.com/docs/7.x/cache#events">Events</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Broadcasting 学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-broadcasting-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-broadcasting-xue-xi-ti-gang/">
        </link>
        <updated>2020-08-30T12:17:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1思考每一个模块功能有什么用什么时候可以用到">1.思考每一个模块，功能有什么用，什么时候可以用到？</h2>
<p>主要就是通过利用WebSocket技术实现服务端对用户端的信息更新推送。</p>
<p><em>提前需要知道Event【事件】和Listeners 【监听器】如何用。</em></p>
<blockquote>
<p>详细一点，就是利用Pusher和Redis作为驱动，log一般是测试的时候用，自己可以参考 <a href="https://github.com/beyondcode/laravel-websockets">laravel-websockets</a>实现一个，通过WebSocket，实现Laravel服务端把事件广播到客户端的JavaScript应用上。</p>
<p>事件广播用到的信道，具体分公共和私有信道，公共的信道，任何用户可以不经授权和认证就可以订阅接受，私有的就必须认证和授权了。</p>
</blockquote>
<p>使用举例：</p>
<ol>
<li>
<p>假定有一个给用户查看订单发货状态的页面；</p>
</li>
<li>
<p>订单运输状态发生改变就会触发一个ShippingStatusUpdated事件。</p>
</li>
</ol>
<blockquote>
<pre><code class="language-php">event(new ShippingStatusUpdated($update));
</code></pre>
<p>当用户挂在这个页面，即使不需要刷新。也可以在运单状态改变的时候通过广播到应用的方式进行运单状态的更新。</p>
<blockquote>
<p>只需要实现<code>ShouldBroadcast</code>接口即可；具体实现看官方文档。</p>
</blockquote>
</blockquote>
<p>对于需要私有信道的，可以看<a href="https://laravel.com/docs/7.x/broadcasting#authorizing-channels">Authorizing Channels</a>。就是JS应用向后端发送HTTP请求，后端鉴权搞定就可以了，使用Laravel Echo的话，这些都是默认实现好了的。不过，需要定义相应的routes来响应这些请求。</p>
<blockquote>
<p>路由及其他的配置见官方文档。</p>
</blockquote>
<p>如果你的应用在routes/channels.php中配置有太多的channel，会非常的臃肿，这个时候，就建议执行<code>php artisan make:channel OrderChannel</code>这个artisan命令添加channel类【位于App\Broadcasting文件夹】，其实就很类似于http请求的routes了；把channels.php文件里面的闭包就换成类名<code>Broadcast::channel('order.{order}', OrderChannel::class);</code>具体代码就在channel类的join方法里面处理。</p>
<blockquote>
<p>更多的参考官方文档</p>
</blockquote>
<p>对于一个事件广播需要排除当前用户【客户端】的，一般是使用toOthers()方法，事件类需要使用<code>Illuminate\Broadcasting\InteractsWithSockets</code>trait来调用toOthers()方法。</p>
<blockquote>
<p>​	However, remember that we also broadcast the task's creation. If your JavaScript application is listening for this event in order to add tasks to the task list, you will have duplicate tasks in your list: one from the end-point and one from the broadcast. You may solve this by using the <code>toOthers</code> method to instruct the broadcaster to not broadcast the event to the current user.</p>
<blockquote>
<p>场景就是，用户发布了一个任务，然后axios的response获取到该任务更新，同时这个任务更新被事件广播出去，前端代码通过事件广播将用户们的任务列表+1，其他用户接收到了，本用户也接受到了，相当于当前用户收到了两次响应，这样就重复了，使用<code>toOthers</code>方法就可以不通知当前用户，这样就不会重复。</p>
</blockquote>
<blockquote>
<p>默认情况下，Vue+Axios已经实现了客户端的处理逻辑，也可以自定义，具体的看官方文档：<a href="https://laravel.com/docs/7.x/broadcasting#only-to-others">Only To Others</a>。</p>
</blockquote>
</blockquote>
<p>在线状态频道【我愿称之为局域网】，可以实现比如bilibili在线观看人数实时变动的功能。用户多一个，大家的在线观看人数都显示+1，当然更精细的可以做到，谁加入了直播间这种提示。<em>肯定也就是private信道，而且用户还必须过channel鉴权，不然怎么统计用户信息？</em></p>
<blockquote>
<p>也因此，鉴权的回调函数不是返回true值，而是一个包含用户数据的array，这个数据会被其他事件广播监听的用户所使用，如果没有被授权或授权失败，返回false或者null。</p>
</blockquote>
<blockquote>
<p>如果需要做聊天室类的应用或者功能可以参考官方文档。</p>
</blockquote>
<p>如果需要一个比如“正在输入”的状态提示给其他用户，而不用通知到后端，只需要一个很轻量简洁的功能，触发方使用Echo的<code>whisper</code>方法，接收方使用<code>listenForWhisper</code>即可。</p>
<blockquote>
<p>具体参考官方文档</p>
</blockquote>
<p>需要Notification也使用BroadCasting服务，不需要刷新就可以通知到前端，</p>
<p>请先参考<a href="https://laravel.com/docs/7.x/notifications#broadcast-notifications">the broadcast notification channel</a>配置Notification，然后前端参考<a href="https://laravel.com/docs/7.x/broadcasting#notifications">官方文档</a>进行Notification广播的监听即可。</p>
<h2 id="2具体用法只需要了解不使用的时候是记不住的具体要用再查官方文档">2.具体用法只需要了解【不使用的时候是记不住的】，具体要用再查官方文档。</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laradock Win10 ]]></title>
        <id>https://dzkjz.github.io/post/laradock-win10/</id>
        <link href="https://dzkjz.github.io/post/laradock-win10/">
        </link>
        <updated>2020-08-15T13:31:39.000Z</updated>
        <content type="html"><![CDATA[<p>参考官方的<a href="https://laradock.io/">文档</a> 以及<a href="https://xueyuanjun.com/post/9608">在 Mac/Windows 系统中使用 Laradock 搭建基于 Docker 的 Laravel 开发环境</a>安装</p>
<p>给👴一直报错。</p>
<blockquote>
<pre><code class="language-powershell">ERROR: for postgres  Cannot create container for service postgres: status code not OK but 500: {&quot;Message&quot;:&quot;Unhandled exception: Filesharing has been cancelled&quot;,&quot;StackTrace&quot;:&quot;   at Docker.ApiServices.Mounting.FileSharing.&lt;**DoShareAsync**&gt;d__6.MoveNext() in C:\workspaces\stable-2.3.x\src\github.com\docker\pinata\win\src\Docker.ApiServices\Mounting\FileSharing.cs:line 0\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Docker.ApiServices.Mounting.FileSharing.&lt;**ShareAsync**&gt;d__4.MoveNext() in C:\workspaces\stable-2.3.x\src\github.com\docker\pinata\win\src\Docker.ApiServices\Mounting\FileSharing.cs:line 47\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Docker.HttpApi.Controllers.FilesharingController.&lt;**ShareDirectory**&gt;d__2.MoveNext() in C:\workspaces\stable-2.3.x\src\github.com\docker\pinata\win\src\Docker.HttpApi\Controllers\FilesharingController.cs:line 21\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Threading.Tasks.TaskHelpersExtensions.&lt;**CastToObject**&gt;d__1`1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;**InvokeActionAsyncCore**&gt;d__1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ActionFilterResult.&lt;**ExecuteAsync**&gt;d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Dispatcher.HttpControllerDispatcher.&lt;**SendAsync**&gt;d__15.MoveNext()&quot;}	
</code></pre>
</blockquote>
<p>反正就是这类，没截完，</p>
<p>根据</p>
<p>https://github.com/docker/for-win/issues/5456</p>
<p>https://stackoverflow.com/questions/59942110/docker-drive-has-not-been-shared</p>
<p>https://forums.docker.com/t/cannot-share-drive-in-windows-10/28798</p>
<p>以及</p>
<blockquote>
<p><a href="http://www.karlxu.com/article/details/24">Laradock遇到的坑</a></p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200815212846.png" alt="" loading="lazy"></figure>
</blockquote>
<p>就是设置FILESHARING 里添加需要sharing的<strong>C盘和D盘</strong>就ok了。</p>
]]></content>
    </entry>
</feed>