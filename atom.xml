<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dzkjz.github.io/</id>
    <title>JojoLegend</title>
    <updated>2020-07-31T10:19:40.069Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dzkjz.github.io/"/>
    <link rel="self" href="https://dzkjz.github.io/atom.xml"/>
    <subtitle>Something for age</subtitle>
    <logo>https://dzkjz.github.io/images/avatar.png</logo>
    <icon>https://dzkjz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JojoLegend</rights>
    <entry>
        <title type="html"><![CDATA[laravel使用sendgrid的配置]]></title>
        <id>https://dzkjz.github.io/post/laravel-shi-yong-sendgrid-de-pei-zhi/</id>
        <link href="https://dzkjz.github.io/post/laravel-shi-yong-sendgrid-de-pei-zhi/">
        </link>
        <updated>2020-07-30T16:55:49.000Z</updated>
        <content type="html"><![CDATA[<p><code>petapi-app</code>的<code>.env</code>文件需要修改：</p>
<p>將<code>QUEUE_CONNECTION=sync</code>改爲：</p>
<pre><code>QUEUE_CONNECTION=database
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731015131.png" alt="" loading="lazy"></figure>
<p>這樣才能使用queue job，之前不改就一直给👴报500错误：</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731005112.png" alt="" loading="lazy"></figure>
<p><s>而且参考使用 <code>https://github.com/s-ichikawa/laravel-sendgrid-driver</code></s></p>
<p><s>之后 sendgrid 配置就很简单了：</s></p>
<blockquote>
<p>.env</p>
<pre><code>MAIL_DRIVER=sendgrid
SENDGRID_API_KEY='YOUR_SENDGRID_API_KEY'
</code></pre>
<p>config/services.php (In using lumen, require creating config directory and file.)</p>
<pre><code>'sendgrid' =&gt; [
  'api_key' =&gt; env('SENDGRID_API_KEY'),
],
</code></pre>
<p>config/mail.php</p>
<pre><code>'mailers' =&gt; [
  'sendgrid' =&gt; [
      'transport' =&gt; 'sendgrid',
  ],
],
</code></pre>
</blockquote>
<p>用了之后报550错误</p>
<p>官方文档写</p>
<blockquote>
<table>
<thead>
<tr>
<th>550</th>
<th><code>Requested action not taken: mailbox unavailable</code></th>
<th>The user’s mailbox was unavailable. Usually because it could not be found, or because of incoming policy reasons. Remove these address from your list - it is likely a fake, or it was mistyped.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>所以又换成了原来的默认配置，并且参考 https://sendgrid.com/docs/for-developers/sending-email/laravel/ 配置了<code>.env</code>，然后就ok了 port是用的587+ tls没有用ssl+465</strong></p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731015038.png" alt="" loading="lazy"></figure>
<p>另外参考 <code>https://laravel.io/forum/why-queue-still-waiting-when-send-mail-in-laravel</code> 可以在app容器内执行</p>
<pre><code>composer dumpautoload
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731014523.png" alt="" loading="lazy"></figure>
<p>还要注意，之前使用的queue容器，因为默认是root用户 无法执行artisan命令 所以这个容器就用不上了。</p>
<p>于是又改成了在docker容器里加<code>supervisord</code>：</p>
<blockquote>
<p>不过在使用supervisord前多说几句，</p>
<p>平时执行的 <code>php artisan queue:work</code>一旦关闭terminal，就会中止，所以需要介绍一个<a href="https://linux.die.net/man/1/nohup"><code>nohup</code></a>命令，此命令可以忽略terminal中止，<em>nohup-运行不受挂断影响的命令，并采用非tty输出</em> ，那么参考https://stackoverflow.com/a/28625847 即可执行：</p>
<p><code>nohup php artisan queue:work --daemon &amp;</code></p>
<p>或者执行下面命令把log输出到文件中</p>
<p><code>nohup php artisan queue:work --daemon &gt; app/storage/logs/laravel.log &amp;</code></p>
</blockquote>
<p>开始讲解如何使用supervisord:</p>
<p><a href="https://laravel.com/docs/7.x/queues#supervisor-configuration">官方讲解</a></p>
<p><a href="https://medium.com/@rohit_shirke/configuring-supervisor-for-laravel-queues-81e555e550c6">补充讲解</a></p>
<p><a href="https://blog.whabash.com/posts/installing-supervisor-manage-laravel-queue-processes-ubuntu">Installing Supervisor to Manage Laravel Queue Processes on Ubuntu</a></p>
<p>执行<code>sudo apt install supervisor</code> 这个安装由于可以在dockerfile中完成所以直接加到了app服务的Dockerfile中。</p>
<pre><code>FROM php:7.2.19-fpm

# Arguments defined in docker-compose.yml
ARG user
ARG uid

# Install system dependencies
RUN apt-get update &amp;&amp; apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip \
	supervisor


# Clear cache
RUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*

# Install PHP extensions
RUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd

# Get latest Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Create system user to run Composer and Artisan Commands
RUN useradd -G www-data,root -u $uid -d /home/$user $user
RUN mkdir -p /home/$user/.composer &amp;&amp; \
    chown -R $user:$user /home/$user

# Set working directory
WORKDIR /var/www

USER $user

</code></pre>
<p>然后是Supervisor配置文件，默认情况这个配置文件需要放在/etc/supervisor/conf.d文件夹下面，此文件夹下，可以创建无数你需要的配置文件，反正需要supervisor监视的就给到这里面，那这个文件夹在<code>docker-compose.prod.yml</code>里面直接用volume挂载好就行了，我这里是</p>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
      - ./docker-compose/supervisor:/etc/supervisor/conf.d
    networks:
      - petapin
</code></pre>
<p>挂的这个文件夹</p>
<p><code>- ./docker-compose/supervisor:/etc/supervisor/conf.d</code></p>
<p>然后再在 宿主机 上下文 <code>./docker-compose/supervisor</code>路径创建名为<code>petapi-worker.conf</code>的文件，容器启动后，容器内就挂得有一个<code>/etc/supervisor/conf.d/petapi-worker.conf</code>文件了。</p>
<p>编辑文件如下：</p>
<pre><code class="language-conf">[program:petapi-worker]
process_name=%(program_name)s_%(process_num)02d
command=sudo php /var/www/artisan queue:work --tries=3 --sleep=3 --daemon
user=petapi
autostart=true
autorestart=true
numprocs=1
redirect_stderr=true
stopwaitsecs=3600
stdout_logfile=/var/www/storage/logs/petapi-worker-supervisor.log
</code></pre>
<p>我的petapi挂载在/var/www下面，artisan命令执行也在改文件夹路径，所以command为<code>command=sudo php /var/www/artisan queue:work</code></p>
<blockquote>
<p>也可以使用conf再执行脚本的方式，参考 https://gist.github.com/danharper/9136507</p>
</blockquote>
<blockquote>
<p><strong>由于需要给supervisor执行php artisan命令的权限，所以用户设置为了petapi，有的如：<a href="https://ekn.me/2019-11-05/how-to-use-laravel-queue-worker-with-supervisor">How to use Laravel Queue Worker with Supervisor </a> 及<a href="https://blog.whabash.com/posts/installing-supervisor-manage-laravel-queue-processes-ubuntu">Installing Supervisor to Manage Laravel Queue Processes on Ubuntu</a>给了用户组supervisor然后给这个用户组添加执行artisan命令的权限，这里我们不需要的。</strong></p>
</blockquote>
<p>然后服务容器启动就执行</p>
<pre><code>sudo supervisorctl reread

sudo supervisorctl update

sudo supervisorctl start petapi-worker:*
</code></pre>
<p><s>直接写到supervisor_petapi.sh脚本里面，文件在<code>./docker-compose/supervisor</code>宿主机文件夹内</s></p>
<pre><code class="language-sh">supervisorctl reread

supervisorctl update

supervisorctl start petapi-worker:*
</code></pre>
<p><s>然后Dockerfile添加：</s></p>
<pre><code>COPY --chown=$user ./docker-compose/supervisor/supervisor_petapi.sh /var/www

...
USER $user
...
CMD supervisor_petapi.sh                  
</code></pre>
<p><s>有异常:</s></p>
<blockquote>
<pre><code>  supervisorctl reread
</code></pre>
<p>error: &lt;class 'socket.error'&gt;, [Errno 2] No such file or directory: file: /usr/lib/python2.7/socket.py line: 228</p>
</blockquote>
<p><s>这样app容器启动的时候就会执行上述脚本命令了。</s></p>
<h3 id="还是没成功明天继续">还是没成功，明天继续！</h3>
<p>发现执行</p>
<p><code>docker exec -it petapi-app bash</code>进入容器后，用户由于在Dockerfile中被指定为了petapi，执行<code>apt-get</code>会提示没有权限，所以参考<a href="https://stackoverflow.com/questions/28721699/root-password-inside-a-docker-container">Root password inside a Docker container</a>执行<code>docker exec -u 0 -it petapi-app bash</code>以root身份登录进入即可</p>
<p>执行<code>supervisorctl reread</code></p>
<p>报错<code>unix:///var/run/supervisor.sock no such file</code>，参考<a href="https://serverfault.com/questions/808732/supervisor-sock-file-missing">Supervisor sock file missing</a>执行</p>
<pre><code>service supervisor stop
service supervisor start 
</code></pre>
<p><s>执行<code>supervisorctl reread</code>有报错：</s> 这不是错；</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731141643.png" alt="" loading="lazy"></figure>
<p>参考<a href="https://stackoverflow.com/questions/41618674/supervisord-config-changes-not-recognized-after-reread-update">Supervisord config changes not recognized after reread/update</a> 是指，没有更新，所以没有显示有变化。</p>
<p>然后执行<code>supervisorctl update</code></p>
<p>以及<code>supervisorctl start petapi-worker:*</code></p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731142051.png" alt="" loading="lazy"></figure>
<p>这次是报错了。找不到文件。</p>
<p>如果是报这个错<a href="https://stackoverflow.com/questions/54811044/why-i-get-this-error-laravel-worker-error-no-such-group">laravel-worker: ERROR (no such group)</a>，可以看看</p>
<p><code>/etc/supervisord.conf</code>文件配置的</p>
<pre><code>[include]
files = supervisord.d/*.conf
</code></pre>
<p>这个include部分是不是指向的worker配置路径，我这里是</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731142741.png" alt="" loading="lazy"></figure>
<blockquote>
<p>由于debug需要ps命令，所以参考<a href="https://stackoverflow.com/questions/26982274/ps-command-doesnt-work-in-docker-container">ps command doesn't work in docker container</a>,执行<code>RUN apt-get update &amp;&amp; apt-get install -y procps</code>添加之</p>
</blockquote>
<p>执行<code>ps -ef | grep supervisor</code>查看</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731143919.png" alt="" loading="lazy"></figure>
<p>但是执行<code>service supervisor stop</code>后依然有一个</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731144343.png" alt="" loading="lazy"></figure>
<p>索性直接执行<code>kill -s SIGTERM 468</code>关闭这个468进程。</p>
<p>然后执行<code>service supervisor start</code>启动后查看：</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731144534.png" alt="" loading="lazy"></figure>
<p>下面解释一下</p>
<p><code>/usr/bin/supervisord -c /etc/supervisor/supervisord.conf</code>，</p>
<blockquote>
<p>参考<a href="http://supervisord.org/installing.html#creating-a-configuration-file">Creating a Configuration File</a>，如果执行用户没有root权限或者supervisord.conf文件没有放在默认的/etc/supervisord.conf路径，那么-c后面接你实际防止supervisord.conf文件的路径。默认情况下，supervisor会在其当前路径里面找这个conf文件，加 -c 就可以指定其他位置了。</p>
</blockquote>
<p>但是执行<code>supervisorctl start petapi-worker:*</code></p>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731142051.png" alt="" loading="lazy"></figure>
<p>这次是依然报错了。找不到文件。直接nano编辑这个文件然后</p>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731151403.png" alt="" loading="lazy"></figure>
<p>终于给👴OK了。</p>
<p>然后执行<code>supervisorctl status</code>查看一下状态：</p>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731151632.png" alt="" loading="lazy"></figure>
<p>行吧。</p>
<p>再改一下。</p>
<p>先执行<code>supervisorctl stop all</code></p>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731152456.png" alt="" loading="lazy"></figure>
<p>及执行<code>service supervisor stop</code>停掉进程。</p>
<p>再执行<code>supervisorctl status</code>查看状态：</p>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731151828.png" alt="" loading="lazy"></figure>
<p>再执行<code>ps -ef | grep supervisor</code>查看进程停止完没有：</p>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731151941.png" alt="" loading="lazy"></figure>
<p>OK，停止完了，我们改改这个petapi-worker.conf文件：</p>
<p>去掉sudo后：</p>
<figure data-type="image" tabindex="17"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731152052.png" alt="" loading="lazy"></figure>
<p>然后执行<code>service supervisor start</code>及</p>
<pre><code>supervisorctl reread

supervisorctl update

supervisorctl start petapi-worker:*
</code></pre>
<p>然后执行<code>supervisorctl status</code>查看状态</p>
<figure data-type="image" tabindex="18"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200731152816.png" alt="" loading="lazy"></figure>
<p>OK了。</p>
<h2 id="总结">总结</h2>
<h4 id="petapi-workerconf文件">petapi-worker.conf文件：</h4>
<pre><code>[program:petapi-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /var/www/artisan queue:work --tries=3 --sleep=3 --daemon
user=petapi
autostart=true
autorestart=true
numprocs=1
redirect_stderr=true
;stopwaitsecs=3600
stdout_logfile=/var/www/storage/logs/petapi-worker-supervisor.log
</code></pre>
<h4 id="app容器的dockerfile文件">app容器的Dockerfile文件：</h4>
<pre><code>FROM php:7.2.19-fpm

# Arguments defined in docker-compose.yml
ARG user
ARG uid

# Install system dependencies
RUN apt-get update &amp;&amp; apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip \
	supervisor


# Clear cache
RUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*

# Install PHP extensions
RUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd

# Get latest Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Create system user to run Composer and Artisan Commands
RUN useradd -G www-data,root -u $uid -d /home/$user $user
RUN mkdir -p /home/$user/.composer &amp;&amp; \
    chown -R $user:$user /home/$user

# Set working directory
WORKDIR /var/www

USER $user
</code></pre>
<p>考虑给一个supervisor容器。</p>
<blockquote>
<p>因为supervisorctl命令执行需要root用户，petapi用户不行。</p>
</blockquote>
<p>之前在Dockerfile中添加</p>
<pre><code>COPY --chown=$user  ./docker-compose/supervisor/supervisor_petapi.sh . 
...
USER $user
...
CMD /var/www/supervisor_petapi.sh
...
</code></pre>
<p>的方式不可行，因为sh脚本里面的命令执行必须是root权限，而切换成USER petapi后就无法执行sh脚本里面的supervisorctl命令了。</p>
<p>另外也不能将CMD删除换成在USER切换前的RUN命令，因为虽然用户权限有了，但是容器没有启动，sh脚本里面的conf文件执行artisan命令必然失败。</p>
<p>所以考虑给一个supervisor容器。</p>
<h2 id="最方便的方式">最方便的方式：</h2>
<p>也是最合适的方式，这样一个容器只负责一件事。</p>
<p><code>docker-compose.prod.yml</code>采用php-queue服务，其服务容器的镜像就是这个petapi-app的镜像，而用户不给参数，则直接使用petapi-app中就设置好的petapi用户，然后command就是<code>command: [&quot;php&quot;, &quot;/var/www/app/artisan&quot;, &quot;queue:work&quot;, &quot;--daemon&quot;, &quot;--sleep=3&quot;, &quot;--tries=3&quot;]</code></p>
<p>这样supervisor都不用。</p>
<p>不过 同时我们还需要执行一个<code>composer dumpautoload</code>命令，参考<a href="https://stackoverflow.com/questions/30063907/using-docker-compose-how-to-execute-multiple-commands">Using Docker-Compose, how to execute multiple commands</a>所以：</p>
<pre><code>command: &gt;
	bash -c &quot;php artisan queue:work --sleep=3 --tries=3 &amp;&amp;
	composer dumpautoload&quot;
</code></pre>
<p>如果没有安装bash的，请使用<code>sh -c</code></p>
<h4 id="docker-composerprodyml"><code>docker-composer.prod.yml</code></h4>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  php-queue:
    restart: always
    container_name: petapi-app-queue
    working_dir: /var/www/
    image: petapii
    depends_on:
      - &quot;app&quot;
    command: bash -c &quot;php artisan queue:work --sleep=3 --tries=3 &amp;&amp; composer dumpautoload&quot;
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
   #env_file:
     # - ~/petapi/pets-api/.env
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
      - ./docker-compose/mysql/data:/var/lib/mysql
    networks:
      - petapin
  nginx:
   # build:
    # context: ./dockerfiles/nginx/
   #  dockerfile: Dockerfile
  #  image: nginx:1.19.1-alpine-custom
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql Docker容器关于如何处理down后up数据就丢失的问题以及原理]]></title>
        <id>https://dzkjz.github.io/post/mysql-docker-rong-qi-guan-yu-ru-he-chu-li-down-hou-up-shu-ju-jiu-diu-shi-de-wen-ti-yi-ji-yuan-li/</id>
        <link href="https://dzkjz.github.io/post/mysql-docker-rong-qi-guan-yu-ru-he-chu-li-down-hou-up-shu-ju-jiu-diu-shi-de-wen-ti-yi-ji-yuan-li/">
        </link>
        <updated>2020-07-27T07:45:51.000Z</updated>
        <content type="html"><![CDATA[<p>Mysql Docker容器关于如何处理down后up数据就丢失的问题以及原理</p>
<p>[toc]</p>
<p>docker-compose 可以很方便的用于部署多容器环境。其中比较繁琐的就是做到多应用间数据分离。</p>
<p>容器随时我们可以关闭更新更换，但是要怎么做到数据的连续性就很关键了。</p>
<h2 id="一-场景介绍">一、场景介绍</h2>
<p>比较常见的情况，如果你运行起一个数据库容器，如果你删除了这个容器，那存在其中的数据也就丢失了。</p>
<p>特别是执行<code>docker-compose down</code>然后更新dockerfile和docker-compose.yml文件，再执行<code>docker-compose up -d</code>，你之前网站的数据就丢了。</p>
<h2 id="二-原理以及原因">二、原理以及原因</h2>
<blockquote>
<p>我们在有运行数据库容器的机器里面演示；</p>
</blockquote>
<p>执行<code>docker volume ls</code>查看服务器里面的数据卷：</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200727152424.png" alt="" loading="lazy"></figure>
<p>默认driver就是local ，我们配置的数据卷都在这里面了。</p>
<p>为了查看哪一个是数据库容器的数据卷，以及对应的详细信息</p>
<p>执行<code>docker inspect 数据库容器名</code></p>
<p>然后找到 Mounts部分：</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200727152753.png" alt="" loading="lazy"></figure>
<p>第一个我们配置的可以在docker-compose.prod.yml中找到：</p>
<pre><code class="language-yml">  db:
    image: mysql:5.7
    container_name: ***api-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
</code></pre>
<p>而第二个对应目标地址是<code>/var/lib/mysql</code>的，因为我没有配置，所以自动给了一个，正是这个没有配置，导致每次<code>docker-compose up -d</code>就生成一个新容器及对应的数据卷，然后之前的数据库数据就丢失了。</p>
<h2 id="三-处理办法">三、处理办法</h2>
<p>如果你配置了比如</p>
<pre><code class="language-yml">  db:
    ...
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
      - /data/mysql:/var/lib/mysql
   #   - /data/pgsql:/var/lib/postgresql
   #   - /data/maria:/var/lib/mariadb
   #   - /data/redis:/var/lib/redis
   #   - /data/memcached:/var/lib/memcached
   #   - /data/neo4j:/var/lib/neo4j/data
    networks:
      ...
</code></pre>
<p>配置了对应的本地[宿主机]数据卷位置，第一次<code>docker-compose up -d</code>的时候会直接关联起来，而下一次执行<code>docker-compose up -d</code>的时候，daemon执行到生成一个对应数据卷位置的时候，发现已经给了配置，那就跳过，使用先前的。</p>
<p>当然也可以这么配置：</p>
<pre><code class="language-yml">volumes:
- db-data:/var/lib/mysql
volumes:
 db-data:
  driver: local
</code></pre>
<blockquote>
<p>参考 <a href="https://linuxhint.com/run_postgresql_docker_compose/">Running PostgreSQL using Docker Compose</a></p>
<p>参考 <a href="https://stackoverflow.com/questions/43297384/data-is-lost-in-mysql-docker-container-after-comminting-it-to-a-new-image">Data is lost in Mysql docker container after comminting it to a new image?</a></p>
<blockquote>
<p>I don't know which image you're using but I believe every <code>Dockerfile</code> of <a href="https://github.com/docker-library/mysql">official mysql images</a> has following command:</p>
<pre><code>VOLUME /var/lib/mysql
</code></pre>
<p>which means all mysql data goes to volume. From <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">docker volume docs</a> they specially mentioned that:</p>
<pre><code>&gt; Changes to a data volume will not be included when you update an image.
</code></pre>
<p>And this is the root cause you loss your data in newly started container.</p>
<p>For your question:</p>
<blockquote>
<p>How to achieve this?</p>
</blockquote>
<p>You can use either <a href="https://docs.docker.com/engine/tutorials/dockervolumes/#mount-a-host-directory-as-a-data-volume">mounted volumes</a>, or create a <a href="https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container">data volume container</a>, then run mysql container with option <code>--volumes-from</code>. The former links contain step-by-step guide of how to do it.</p>
<blockquote>
<p>I don't want to use mounted volumes because i want to link this container with another container of my application so that it can inset and update into db</p>
</blockquote>
<p>I don't know what other concerns you have about mounted volumes, but as far as I can tell, using mounted volumes does not prevent you to link containers.</p>
<p>Hope this helps you.</p>
</blockquote>
</blockquote>
<h2 id="四-如果不慎丢失怎么恢复">四、如果不慎丢失，怎么恢复</h2>
<p>如果数据卷都删除了 docker rm 容器的时候 添加了 -v 或 -volume，那就拜拜，没有任何办法的。如果没有删除volume 参考：</p>
<p><a href="https://www.primozker.in/post/saving-lost-data-docker/">Saving 'lost' MYSQL database running in Docker</a></p>
<p>更多可以看<a href="https://docs.docker.com/storage/volumes/">官方文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 解决 sitemap robots.txt 以及提交google index]]></title>
        <id>https://dzkjz.github.io/post/jie-jue-sitemap-robotstxt-yi-ji-ti-jiao-google-index/</id>
        <link href="https://dzkjz.github.io/post/jie-jue-sitemap-robotstxt-yi-ji-ti-jiao-google-index/">
        </link>
        <updated>2020-07-26T12:48:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="sitemap"><a href="#https://www.npmjs.com/package/@nuxtjs/sitemap">Sitemap</a></h2>
<p>在nuxt app里面执行</p>
<pre><code class="language-powershell">npm install @nuxtjs/sitemap
</code></pre>
<pre><code class="language-js">//nuxt.config.js
  modules: [
    // Doc: https://axios.nuxtjs.org/usage
    '@nuxtjs/axios',
    '@nuxtjs/auth',
    'vue-social-sharing/nuxt',
    // Doc: https://github.com/nuxt-community/dotenv-module
    '@nuxtjs/dotenv',
    'cookie-universal-nuxt',//https://www.npmjs.com/package/cookie-universal-nuxt
    '@nuxtjs/sitemap',
  ],

  sitemap: {
    //https://www.npmjs.com/package/@nuxtjs/sitemap
    hostname: 'https://' + process.env.DOMAIN_NAME,
    gzip: true,
    exclude: [
      '/verify/**',
      '/verifynew/**',
      '/password_reset/**',
      '/dashboard_reset/**',
      '/animals/create/**',
    ],
</code></pre>
<p>具体配置<a href="#https://www.npmjs.com/package/@nuxtjs/sitemap">官方文档</a>有讲。</p>
<p>默认情况下只有static页面会自动添加，对于动态的路由页面，<code>parent/:children</code>，这样的，参考 <a href="#https://elision.design/en/blog/dynamic-routes-in-sitemap-with-nuxt-js">HOW TO: Include dynamic routes in sitemap with Nuxt.js</a></p>
<h2 id="robottxt"><a href="#https://www.npmjs.com/package/@nuxtjs/robots">Robot.txt</a></h2>
<p><code>npm install @nuxtjs/robots</code></p>
<pre><code class="language-js">//nuxt.config.js
  modules: [
    // Doc: https://axios.nuxtjs.org/usage
    '@nuxtjs/axios',
    '@nuxtjs/auth',
    'vue-social-sharing/nuxt',
    // Doc: https://github.com/nuxt-community/dotenv-module
    '@nuxtjs/dotenv',
    'cookie-universal-nuxt',//https://www.npmjs.com/package/cookie-universal-nuxt
    '@nuxtjs/sitemap',
    '@nuxtjs/robots',
  ],
        robots: [ //https://www.npmjs.com/package/@nuxtjs/robots
    {
      // UserAgent: 'Googlebot',
      UserAgent: '*',
      Disallow: () =&gt; [
        '/verify',
        '/verify',
        '/verifynew',
        '/password_reset',
        '/dashboard_reset',
        '/animals/create',
      ], // accepts function
      Sitemap: 'https://' + process.env.DOMAIN_NAME + '/sitemap.xml',
    }
  ],
</code></pre>
<p>具体配置介绍参考<a href="#https://www.npmjs.com/package/@nuxtjs/robots">官方文档</a>。</p>
<h2 id="ask-google-to-recrawl-your-urls"><a href="https://support.google.com/webmasters/answer/6065812">Ask Google to recrawl your URLs</a></h2>
<p>Submit a sitemap (many URLs at once)</p>
<p>A sitemap is an important way for Google to discover URLs on your site. A sitemap can also include additional metadata about alternate language versions and video-, image-, or news-specific pages. <a href="https://support.google.com/webmasters/answer/156184">Learn how to create a sitemap.</a></p>
<p>If you have not changed your sitemap since the last time Google crawled it, resubmitting the sitemap won't have any additional benefit. If you have updated pages in the sitemap, mark them with <code>&lt;lastmod&gt;</code>.</p>
<p>Here are the different ways that you can alert Google about your sitemap:</p>
<ul>
<li><strong>Submit a sitemap using the <a href="https://support.google.com/webmasters/answer/7451001">sitemaps report</a>.</strong></li>
<li><strong>Use the ping tool.</strong> Send a GET request in your browser or the command line to this address, specifying the full URL of the sitemap. Be sure that the sitemap file is accessible:<br>
<code>http://www.google.com/ping?sitemap=*&lt;full_URL_of_sitemap&gt;*</code><br>
<strong>Example:</strong><br>
<code>http://www.google.com/ping?sitemap=https://example.com/sitemap.xml</code></li>
<li><strong>Insert the following line anywhere in your <code>robots.txt</code> file</strong>, specifying the path to your sitemap. We will find it the next time we crawl your site:<br>
<code>Sitemap: http://example.com/my_sitemap.xml</code></li>
</ul>
<h2 id="nuxt页面跳转过度动效">Nuxt页面跳转过度动效</h2>
<pre><code class="language-css">/*assets/styles/main.css*/
/*@import '@vue-cookie-accept-decline.css';*/

.page-enter-active, .page-leave-active {
  transition: opacity .5s;
}

.page-enter, .page-leave-to {
  opacity: 0;
}
</code></pre>
<pre><code class="language-js">//nuxt.config.js 
css: [
      ...
    '@/assets/styles/main.css',
      ...
  ],
</code></pre>
<p>官方文档：</p>
<p>https://nuxtjs.org/api/configuration-loading</p>
<p>https://nuxtjs.org/api/pages-transition</p>
<pre><code class="language-js">//nuxt.config.js
loading: {
    color: 'orange',
    height: '5px',
    failedColor: 'red',
    duration: 5000,
    continuous: true,
  },
</code></pre>
<p>自定义的可以参考 <a href="#https://nuxtjs.org/api/configuration-loading#using-a-custom-loading-component">使用自定义的组件设置加载样式</a></p>
<h2 id="改变favicon">改变Favicon</h2>
<p>参考 https://github.com/nuxt/nuxt.js/issues/903</p>
<pre><code class="language-js">//nuxt.config.js
link: [
      {rel: 'icon', type: 'image/x-icon', href: '/tiere_favi.png'},
    ]
</code></pre>
<p><a href="#https://nuxtjs.org/guide/assets/">官方文档</a>也可以看看</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「踩坑记录」 Nuxt.js & Ant-design-vue 配置]]></title>
        <id>https://dzkjz.github.io/post/cai-keng-ji-lu-nuxtjs-and-ant-design-vue-pei-zhi/</id>
        <link href="https://dzkjz.github.io/post/cai-keng-ji-lu-nuxtjs-and-ant-design-vue-pei-zhi/">
        </link>
        <updated>2020-07-25T06:42:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="nuxtjs-ant-design-vue">Nuxt.js &amp; ant-design-vue</h1>
<p>最近开发一个带seo以及部分后台功能的项目，nuxt作为vue ssr框架可以非常好的完成这个需求，这里我选择了<code>ant-design-vue</code>作为UI组件库。</p>
<p>以下是踩坑的一些记录 ：</p>
<p>首先介绍一下项目情况和需求：</p>
<ul>
<li>Nuxt.js是一个 Vue.js 通用框架，预设了使用 Vue.js开发SSR的各种配置。项目中使用的是SSR模式，因此首屏是由<strong>服务端完成渲染</strong>。</li>
<li>项目仅用到少数的UI组件，因此我们希望使用按需加载组件，以减少网络开销。</li>
</ul>
<h2 id="1-按需加载引入组件">1. 按需加载引入组件</h2>
<p>首先我们移除掉 nuxt.config.js 中</p>
<pre><code class="language-js">{   css: ['ant-design-vue/dist/antd.css'],   // 这里会全局引入所有样式，不是我们所希望的按需加载 }
</code></pre>
<p>参考官方文档antd-vue # 按需加载：</p>
<pre><code class="language-js">// 同时参考 Nuxt-cli 创建项目时 创建的 plugin/antd-ui.js 
import Vue from 'vue' import Button from 'ant-design-vue/lib/button'; 
import 'ant-design-vue/lib/button/style'; // 或者 ant-design-vue/lib/button/style/css 加载 css 文件  
Vue.use(Button.name, Button)
</code></pre>
<p>编译未通过，提示错误：</p>
<pre><code class="language-shell">// https://github.com/ant-design/ant-motion/issues/44 .bezierEasingMixin(); ^ Inline JavaScript is not enabled. Is it set in your options?
</code></pre>
<p>根据报错所提供的信息，less升级到3.0 后，需要 less-loader配置一个功能，才能正常使用：</p>
<pre><code class="language-js">// nuxt.config.js 
{  
    build: {   
        loaders: {    
            less: {     
                javascriptEnabled: true    
            }   
        }  
    } 
}
</code></pre>
<p>编译通过，打开页面，返回500，提示：</p>
<figure data-type="image" tabindex="1"><img src="https://i0.wp.com/upload-images.jianshu.io/upload_images/4655331-6b7d1982b438ab82.png" alt="img" loading="lazy"></figure>
<p>image.png</p>
<p>编译能通过，说明代码编译没有问题，但是server端执行时出现了错误。尝试注释掉plugin/antd-ui.js引入样式文件这行 import 'ant-design-vue/lib/button/style'; ，server首屏渲染能够正常启动，但引入的button组件样式丢失。</p>
<p>打开 ant-design-vue/lib/button/style/index.js 查看：</p>
<pre><code class="language-js">'use strict'; 
require('../../style/index.less'); 
require('./index.less');  
// ant-design-vue/es/button/style/index.js 
import '../../style/index.less'; 
import './index.less';
</code></pre>
<p>可以看到，antd-vue为生产环境提供了两种模块的代码。为了tree-shaking 我们优先选择 es 模块。</p>
<blockquote>
<p>补充知识：现在的webpack@4+ 支持识别项目 packge.json module字段，使用ESModule的依赖更好的支持构建中的tree-shaking。</p>
</blockquote>
<p>修改代码为 es/button/...，编译通过，但页面仍抛出一500服务端错误：</p>
<figure data-type="image" tabindex="2"><img src="https://i0.wp.com/upload-images.jianshu.io/upload_images/4655331-ae7c35452bf86a74.png" alt="img" loading="lazy"></figure>
<p>image.png</p>
<p>根据错误提示cannot use import statement和es包使用的ESModule语法，猜测服务端侧渲染页面时语法出错，Node.js 不能直接识别 .js文件内的ESModule语法。</p>
<pre><code class="language-js">// .nuxt.config.js 
{  
    plugins: 
    [   
        {    
            src: '@/plugins/antd-ui',    
            mode: 'client' // 仅 客户端使用plugin   
        }  
    ] 
}
</code></pre>
<p>页面正常加载，但Vue.js 给出了错误提示</p>
<figure data-type="image" tabindex="3"><img src="https://i0.wp.com/upload-images.jianshu.io/upload_images/4655331-e03fb922189d9a8c.png" alt="img" loading="lazy"></figure>
<p>image.png</p>
<p>此时，我们再将plugin代码替换回lib以及移除mode: 'client ，错误又回到了最开始的 invalid or unexpected token。</p>
<p>搜索Nuxt官方文档：</p>
<blockquote>
<p>如果要使用Babel与特定的依赖关系进行转换，你可以在build.transpile中添加它们，transpile中的选项可以是字符串或正则表达式对象，用于匹配依赖项文件名。</p>
</blockquote>
<p>添加配置：</p>
<pre><code class="language-js">{ // nuxt.config.js  
    build: {   
        transpile: [/ant-design-vue/]
    } 
}
</code></pre>
<p>终于，服务端渲染正常，样式也正常加载。接着引入 ant-design-vue官方推荐使用的插件babel-plugin-import</p>
<pre><code class="language-js">// nuxt.config.js 
{  
    build: {
        babel: {
            plugins: [
                [      
                    'import',      
                    {       
                        libraryName: 'ant-design-vue',       
                        libraryDirectory: 'es',       
                        // 选择子目录 例如 es 表示 ant-design-vue/es/component       
                        // lib 表示 ant-design-vue/lib/component              
                        style: true       
                        // 默认不使用该选项，即不导入样式 , 注意 ant-design-vue 使用 js 文件引入样式       
                        // true 表示 import  'ant-design-vue/es/component/style'      
                        // 'css' 表示 import 'ant-design-vue/es/component/style/css'      
                    }     
                ]    
            ]   
        }  
    } 
}  // plugins/antd-ui.js 
import Vue from 'vue' 
import { Button } from 'ant-dsign-vue' // 这时，可以通过 简写的方式引入样式和组件  
Vue.use(Button)
</code></pre>
<h2 id="2-pages目录内引入组件">2. pages目录内引入组件</h2>
<figure data-type="image" tabindex="4"><img src="https://i0.wp.com/upload-images.jianshu.io/upload_images/4655331-8123f1ba7bbc27a8.gif" alt="img" loading="lazy"></figure>
<p>flash.gif</p>
<p>上图是在pages/index.vue内引入组件，npm run build &amp;&amp; npm run start 执行后的线上环境，可以看到样式在刷新首屏时，会看到闪烁的现象，这里出现的问题在于入口文件并不包含组件，而是异步引入的，从编译结果上也可以看到 610kb 的包对应的chunk vendors.pages/index ，并不在entrypoint内，默认情况下Nuxt.js 路由页面已经被分配为dynamic import，同时style是通过js设置到style上的，而不是单独打包出来。经过测试，css单独打包后，UI组件仍是单独分包，即便是单独打包出来，依然会有按需加载的问题，首屏仍会闪烁。</p>
<figure data-type="image" tabindex="5"><img src="https://i0.wp.com/upload-images.jianshu.io/upload_images/4655331-1dd3852daa2d8ff2.png" alt="img" loading="lazy"></figure>
<p>build result</p>
<p>因此，如果组件被大多数页面使用，推荐在 plugin内注册，或者通过 nuxt.config.js的css相关文件直接引入对应的组件样式，同时关闭babel-import-plugin 的 style选项。 (吐槽一句，iView只能引入单一全局样式，不能按需加载样式，1.5m的大小非常恐怖)</p>
<p>除此以外，可以考虑配置webpack的splitchunks配置，实现自己的需求。</p>
<h2 id="3-解决antd-icon-过大传统艺能">3. 解决antd-icon 过大（传统艺能</h2>
<p>前面生产环境的包可以发现，只使用了一个Button，却打包了600kb的依赖，检查后发现是引入了@ant-design/icon 包。</p>
<p>参考： https://github.com/HeskeyBaozi/reduce-antd-icons-bundle-demo</p>
<pre><code class="language-js">{ // nuxt.config.js  
    build: 
    {   
        extend(config, ctx) {
            config.resolve.alias['@ant-design/icons/lib/dist$'] = path.resolve(__dirname, './assets/icon/antd-icon.js') // 引入需要的  
        }  
    } 
}
</code></pre>
<h2 id="题外话">题外话</h2>
<p><strong>“按需引入”</strong></p>
<figure data-type="image" tabindex="6"><img src="https://i0.wp.com/upload-images.jianshu.io/upload_images/4655331-2faf55ca3844885e.png" alt="img" loading="lazy"></figure>
<p>image.png</p>
<p>https://github.com/ant-design/babel-plugin-import/issues/347</p>
<h2 id="reference">reference</h2>
<p>https://github.com/vueComponent/ant-design-vue/issues/234<br>
https://www.zhihu.com/question/265227812</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[总结nuxt laravel nginx mysql docker ubuntu部署的流程]]></title>
        <id>https://dzkjz.github.io/post/zong-jie-nuxt-laravel-nginx-mysql-docker-ubuntu-bu-shu-de-liu-cheng/</id>
        <link href="https://dzkjz.github.io/post/zong-jie-nuxt-laravel-nginx-mysql-docker-ubuntu-bu-shu-de-liu-cheng/">
        </link>
        <updated>2020-07-19T06:40:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-docker">一、Docker</h2>
<p>什么是docker可以参考:<a href="https://yeasy.gitbook.io/docker_practice/introduction/what">什么是 Docker</a></p>
<p>在进行下面的操作之前，请先<a href="https://yeasy.gitbook.io/docker_practice/install">安装Docker </a></p>
<p>针对这篇文章，我们需要的是：</p>
<ol>
<li>一个容器运行nginx</li>
<li>一个容器运行php-fpm</li>
<li>一个容器运行mysql</li>
<li>一个容器运行node</li>
</ol>
<p>四个容器：</p>
<ul>
<li>
<p>nginx和mysql容器可以直接用官方的镜像。<em>所以这两个容器不需要Dockerfile</em>；</p>
</li>
<li>
<p>php-fpm容器 主要是运行 laravel；</p>
</li>
<li>
<p>另外需要一个临时容器给安装composer，安装完成后删除这个临时容器就行；</p>
</li>
<li>
<p>node容器用于运行nuxt。</p>
</li>
</ul>
<p>php-fpm容器我们需要安装一些扩展包，执行composer安装，所以用Dockerfile配置：</p>
<p>更多Dockerfile配置的指令介绍参考：<a href="https://yeasy.gitbook.io/docker_practice/image/build">使用 Dockerfile 定制镜像</a></p>
<p>请注意教程中的</p>
<blockquote>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p><strong>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</strong></p>
</blockquote>
<p>以及对路径上下文的解释</p>
<blockquote>
<h3 id="镜像构建上下文context"><a href="https://yeasy.gitbook.io/docker_practice/image/build#jing-xiang-gou-jian-shang-xia-wen-context">镜像构建上下文（Context）</a></h3>
<p>这个也是很奇葩的，初学的时候，是单纯的认为 下面这个命令</p>
<p>COPY ./somefiles /var/www</p>
<p>就是复制Dockerfile所在的文件夹下somefiles文件夹及其内部文件到 此镜像构建的容器内的 /var/www目录里。</p>
<p>但是这么理解会出问题，首先，可以用~/sub/fab/docker/somotherfiles/ 这么指定宿主机文件夹路径吗？</p>
<p>答案是不行的。会报错找不到。</p>
<p>然后，那么可以用 ../this/somefiles/指定宿主机文件夹路径吗？</p>
<p>答案也是不行的，也是报错找不到。</p>
<p>具体涉及到的是 Docker 引擎，具体看教程解释，不过可以简单的这么说，就是构建的时候，只打包dockerfile文件路径下的<strong>所有内容</strong>传到docker引擎，所以是不包含外部的以及可以用~指定的路径下的。同时也要注意，这个dockerfile文件打包的所有内容如果你给的文件太大了，那传输起来就牛了，有的几十个GB 传输很头疼的，所以需要注意，dockerfile所在文件夹下的文件内容，只留下需要的。</p>
<p>还有上面是笼统的说成是dockerfile文件所在文件夹，其实也是不完全正确的。</p>
<p>因为可以 -f ../Dockerfilev3 这么指定需要的Dockerfile 首先路径在外面，然后名字也不同，不过一般情况不这么干。默认状态下前面说的不严谨但也可以是对的。还有<a href="https://yeasy.gitbook.io/docker_practice/image/build#qi-ta-docker-build-de-yong-fa">其它 <code>docker build</code> 的用法。</a></p>
</blockquote>
<h5 id="app-容器-dockerfile">app 容器 Dockerfile</h5>
<pre><code class="language-yml">FROM php:7.2.19-fpm #指定 基础镜像

# Arguments defined in docker-compose.yml
ARG user #定义参数
ARG uid  #定义参数

# Install system dependencies 安装系统依赖 #RUN 指令是用来执行命令行命令的
# Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式
RUN apt-get update &amp;&amp; apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip


# Clear cache 清理cache
RUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* #使用 &amp;&amp; 将各个所需命令串联起来

# Install PHP extensions 安装扩展
RUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd

# Get latest Composer 这里是把composer给复制到 本Dockerfile定义的容器的 /usr/bin/composer里
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Create system user to run Composer and Artisan Commands
# 创建系统用户用于执行 composer和 artisan 命令 实际是给权限。
RUN useradd -G www-data,root -u $uid -d /home/$user $user
RUN mkdir -p /home/$user/.composer &amp;&amp; \
    chown -R $user:$user /home/$user

# Set working directory 本容器的工作文件夹
WORKDIR /var/www

USER $user #设置容器的用户

</code></pre>
<blockquote>
<p>需要了解更多指令可以参考：</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy">COPY 复制文件</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/add">ADD 更高级的复制文件</a></p>
<p>[Dockerfile 最佳实践文档](Dockerfile 最佳实践文档)</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/cmd">CMD 容器启动命令</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint">ENTRYPOINT 入口点</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/env">ENV 设置环境变量</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/arg">ARG 构建参数</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/volume">VOLUME 定义匿名卷</a> 上面的dockerfile没有挂载数据卷到容器内，但是我们在docker-compose里挂载了，后面讲。</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/expose">EXPOSE 暴露端口</a> <code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务， 明确 -P随机映射端口时会映射到EXPOSE的端口，-p指定时，是按-p指定的来。</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/workdir">WORKDIR 指定工作目录</a></p>
<p><strong>请注意<code>Dockerfile</code> 构建分层存储的概念。</strong></p>
<p>每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。</p>
<blockquote>
<pre><code class="language-yml">RUN cd /app
RUN echo &quot;hello&quot; &gt; world.txt
</code></pre>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code></p>
<p>第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
</blockquote>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/user">USER 指定当前用户</a></p>
<blockquote>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p><code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
</blockquote>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/healthcheck">HEALTHCHECK 健康检查</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/onbuild">ONBUILD 为他人作嫁衣裳</a></p>
<blockquote>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
</blockquote>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/references">参考文档</a></p>
</blockquote>
<p>laravel运行的php-fpm容器Dockerfile配置好之后，接下来是配置前端nuxt需要的node容器。</p>
<h5 id="node容器dockerfile">node容器Dockerfile</h5>
<pre><code class="language-yml">#使用node:12-alpine 作为基础进行构建
FROM node:12-alpine

#创建/app 目录作为部署目录,创建容器实例时,挂载此目录
RUN mkdir -p /app

#移动工作目录到 /app
WORKDIR /app

#安装 bash 和 busybox
RUN apk update \
        &amp;&amp; apk upgrade \
        &amp;&amp; apk add --no-cache bash \
        bash-doc \
        bash-completion \
        &amp;&amp; /bin/bash \
        &amp;&amp; apk add --no-cache busybox \
        &amp;&amp; rm -rf /var/cache/apk/*

#安装 git
RUN apk add git
		
#设置node环境变量为production
ENV NODE_ENV=production

# copy the app, note .dockerignore
COPY ./pets-client /app
RUN npm install

# build necessary, even if no static files are needed,
# since it builds the server as well
RUN npm run build
RUN npm cache clean --force

# set app serving to permissive / assigned
#ENV NUXT_HOST=0.0.0.0 已经在nuxt.config.js中设置了server block
# set app port
#ENV NUXT_PORT=5000 已经在nuxt.config.js中设置了server block

#设置容器启动时执行的命令
#ENTRYPOINT [ &quot;npm&quot;,&quot;start&quot; ]
CMD [&quot;npm&quot;,&quot;start&quot;]
</code></pre>
<p>Dockerfile部分到此就结束了，接下来，需要了解Docker-Compose</p>
<h2 id="二-docker-compose">二、<a href="https://yeasy.gitbook.io/docker_practice/compose">Docker-Compose</a></h2>
<p>Docker-Compose 是用来管理你的容器的，有点像一个容器的管家，想象一下当你的Docker中有成百上千的容器需要启动，如果一个一个的启动那得多费时间。有了Docker-Compose你只需要编写一个文件，在这个文件里面声明好要启动的容器，配置一些参数，执行一下这个文件，Docker就会按照你声明的配置去把所有的容器启动起来，只需docker-compose up即可启动所有的容器，但是Docker-Compose只能管理当前主机上的Docker，也就是说不能去启动其他主机上的Docker容器。</p>
<p>补充</p>
<blockquote>
<p>Docker Swarm<br>
Docker Swarm 是一款用来管理多主机上的Docker容器的工具，可以负责帮你启动容器，监控容器状态，如果容器的状态不正常它会帮你重新帮你启动一个新的容器，来提供服务，同时也提供服务之间的负载均衡，而这些东西Docker-Compose 是做不到的</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/kubernetes/intro">Kubernetes</a><br>
Kubernetes它本身的角色定位是和Docker Swarm 是一样的，也就是说他们负责的工作在容器领域来说是相同的部分，都是一个跨主机的容器管理平台，当然也有自己一些不一样的特点，k8s是谷歌公司根据自身的多年的运维经验研发的一款容器管理平台。而Docker Swarm则是由Docker 公司研发的。<strong>现在常用Kubernetes</strong></p>
</blockquote>
<p>它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p>本节的安装链接已经有安装教程，安装此处略</p>
<p>给出本次项目的完成版本<code>docker-compose.prod.yml</code></p>
<h4 id="完成版本docker-composeprodyml">完成版本<code>docker-compose.prod.yml</code></h4>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin
  nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge
</code></pre>
<p>接下来细分拆解；</p>
<h3 id="app部分">app部分：</h3>
<pre><code class="language-yml">app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
</code></pre>
<p>这是定义的第一个服务，</p>
<p>app【php】的Dockerfile里，我们定义了两个参数 user 和 uid ，这里进行了赋值。</p>
<p>因为使用build指令，所以必须给到context 和 Dockerfile，这个context即已经在 <a href="#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Context%EF%BC%89">前面提到过的镜像构建上下文。</a></p>
<p>build可以不给context 直接给路径如：<code>build: ./dir</code> 需要注意的格式是 <code>build:[空格]./dir</code> <strong>空格不能少</strong></p>
<p>image 是给这个生成的镜像的名字，如果没有build而是直接给image，docker会去dockerhub官方搜这个包，搜到了就给pull下来。</p>
<p>app 其运行起来的容器名叫petapi-app，这个名字很重要，nginx的conf里，我们会用到这个：</p>
<blockquote>
<pre><code class="language-conf">server {
listen 80;
   listen [::]:80;
   server_name api.example.com;
   return 301 https://$http_host$request_uri;
   #rewrite ^(.*)$ https://$host$1 permanent; we just replace request to https
}
server{
listen 443 ssl;
   listen [::]:443 ssl;
   server_name api.example.com;
   #ssl on; no need this anymore please change use listen 443 ssl only
   ssl_certificate /etc/nginx/certs/cert.pem;
   ssl_certificate_key /etc/nginx/certs/key.pem;
   #ssl_session_timeout 5m;
   #ssl_protocols read blow info please;
   # By default nginx uses “ssl_protocols TLSv1 TLSv1.1 TLSv1.2” and 
#“ssl_ciphers HIGH:!aNULL:!MD5”, so configuring them explicitly is 
#generally not needed.
   index index.php index.html;
   error_log /var/log/nginx/error.log;
   access_log /var/log/nginx/access.log;
   root /var/www/public;
   location ~ \.php$ {
           try_files $uri =404;
           fastcgi_split_path_info ^(.+\.php)(/.+)$;
           fastcgi_pass petapi-app:9000;
           fastcgi_index index.php;
           include fastcgi_params;
           fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
           fastcgi_param PATH_INFO $fastcgi_path_info;
           }
   location / {
            try_files $uri $uri/ /index.php?$query_string;
            gzip_static on;
            }
    }   
</code></pre>
</blockquote>
<p>注意 <code>fastcgi_pass petapi-app:9000;</code> 我们用到了container_name 即这个app容器的名字。9000是默认php-fpm的端口。</p>
<p>其次，我们Dockerfile之前没有设置数据卷，这里设置了加载 <code>docker-compose.prod.yml</code>所在文件夹全部内容 到容器中</p>
<p>restart:  指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p>
<p>networks:  配置容器连接的网络。这个网络主要是给服务容器之间通信的，db我们用的mysql通过这个网络和app通信，nginx也通过这个网络和app通信。这三个公用的 petapin 这个网路，这个网络是在 外层 networks:中定义的。</p>
<p>一般来说，docker -compose 就是：</p>
<pre><code class="language-yml">version: 
services:
networks:
</code></pre>
<p>这三个。<s>networks 的 driver 可以参考 network_mode。</s>  <strong>错啦！networks 应该参考 <a href="https://docs.docker.com/compose/compose-file/#network-configuration-reference">Network configuration reference</a></strong></p>
<p>关于networks和links 请看 <a href="https://docs.docker.com/compose/networking/">Networking in Compose</a></p>
<blockquote>
<p>compose 默认会提供一个network ，每个服务都会加入这个network，且默认互通，它们之间以一个基于容器名生成的名作区分。</p>
<p>一般来说网络名基于项目名【项目基于存放其的文件夹名】</p>
<p>比如说, 假设你的app存放于一个叫<code>myapp</code>的文件夹里, 你的 <code>docker-compose.yml</code> 配置如下:</p>
<pre><code>version: &quot;3&quot;
services:
web:
build: .
ports:
    - &quot;8000:8000&quot;
db:
  image: postgres
  ports:
    - &quot;8001:5432&quot;
</code></pre>
<p>当你执行 <code>docker-compose up</code>,的时候 ，会有如下流程:</p>
<ol>
<li>一个名叫<code>myapp_default</code>的网络被创建 。</li>
<li>使用 <code>web</code>配置创建一个容器. 该容器加入 <code>myapp_default</code> 网络并且赋予一个标识名 <code>web</code>.</li>
<li>使用 <code>db</code>配置创建一个容器.  该容器加入 <code>myapp_default</code> 网络并且赋予一个标识名 db.</li>
</ol>
<p>每一个容器都可以通过标识名<code>web</code>,<code>db</code>查询到这两容器，并获得这两容器的ip地址，比如，web容器里的程序代码可以通过<code>postgres:5342</code>链接到<code>db</code>容器，就可以使用postgres数据库啦。</p>
<p>It is important to note the distinction between <code>HOST_PORT</code> and <code>CONTAINER_PORT</code>. In the above example, for <code>db</code>, the <code>HOST_PORT</code> is <code>8001</code> and the container port is <code>5432</code> (postgres default). Networked service-to-service communication use the <code>CONTAINER_PORT</code>. When <code>HOST_PORT</code> is defined, the service is accessible outside the swarm as well.</p>
<p>Within the <code>web</code> container, your connection string to <code>db</code> would look like <code>postgres://db:5432</code>, and from the host machine, the connection string would look like <code>postgres://{DOCKER_IP}:8001</code>.</p>
<h2 id="links了解就行"><a href="https://docs.docker.com/compose/networking/#links">Links了解就行</a></h2>
<p>这个参考 <a href="https://docs.docker.com/compose/compose-file/#links"><strong>links将会在今后被移除</strong></a>，后期这个没有了，现在了解就行，不推荐使用。</p>
<p>Links allow you to define extra aliases by which a service is reachable from another service. They are not required to enable services to communicate - by default, any service can reach any other service at that service’s name. In the following example, <code>db</code> is reachable from <code>web</code> at the hostnames <code>db</code> and <code>database</code>:</p>
<pre><code>version: &quot;3&quot;
services:

web:
  build: .
  links:
    - &quot;db:database&quot;
db:
  image: postgres
</code></pre>
<p>See the <a href="https://docs.docker.com/compose/compose-file/compose-file-v2/#links">links reference</a> for more information.</p>
<h2 id="networks"><a href="https://docs.docker.com/compose/compose-file/#networks">NETWORKS</a></h2>
<p>我们这里用的就是这个。</p>
</blockquote>
<p>更多的指令参考 <a href="https://yeasy.gitbook.io/docker_practice/compose/compose_file">docker compose 指令</a></p>
<p>frontapp配置参考上面的自己理解，</p>
<h3 id="db部分">db部分：</h3>
<pre><code class="language-yml">  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin
</code></pre>
<p>数据库在这个项目中，存在一个导入的操作，如果以后网站主机迁移，同样也可以打包导入，教程在cnblog有。</p>
<p>数据库部分其余的都没啥好说的，主要是environment里的配置，一般情况下使用的是</p>
<pre><code class="language-yml">environment:
  RACK_ENV: development
  SHOW: 'true'
  SESSION_SECRET:
environment:
  - RACK_ENV=development
  - SHOW=true
  - SESSION_SECRET
</code></pre>
<p>这种赋值格式。</p>
<p>但是<code>${...}</code> 怎么理解？</p>
<blockquote>
<p>You can use environment variables in configuration values with a Bash-like <code>${VARIABLE}</code> syntax - see <a href="https://docs.docker.com/compose/compose-file/#variable-substitution">variable substitution</a> for full details.</p>
<p>就是说，<code>${...}</code>是可以读取设置在<code>.env</code>文件中的值的，但是必须在执行 <code>docker-compose up</code>的时候，如果在执行的时候另行赋值 <code>--name=...</code>会覆盖<code>.env</code>中的值。<code>.env</code>文件中配置的值只在 <code>docker-compose up</code>执行的时候起作用，<code>docker stack deploy</code>不起作用。</p>
<p>其他用法： <code>${VARIABLE:-default}</code>及<code>${VARIABLE-default}</code> 及<code>${VARIABLE:?err}</code>及<code>${VARIABLE?err}</code></p>
</blockquote>
<p>也就是说，上面配置db容器的值，在docker-compose up的时候，读取同目录下.env文件中配置的值。</p>
<h3 id="nginx部分">nginx部分</h3>
<pre><code class="language-yml">nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
</code></pre>
<p>nginx配置中我们使用了两个conf，petapi.conf及 petclient.conf存放于 ./docker-compose/nginx目录下。通过volumes配置，加载到了nginx容器内的/etc/nginx/conf.d文件夹中。</p>
<p>然后是ssl的key.pem和cert.pem文件存放在./docker-compose/nginx/certs文件夹下。通过volumes配置，加载到了nginx容器内的/etc/nginx/certs文件夹内。</p>
<p>为什么配置 ./加载到/var/www文件夹中呢？</p>
<p>我们看看petapi.conf:</p>
<pre><code class="language-conf">server {
   listen 80;
        略...
     }
server{
   listen 443 ssl;
        listen [::]:443 ssl;
        server_name api.example.com;
        ssl_certificate /etc/nginx/certs/cert.pem;
        ssl_certificate_key /etc/nginx/certs/key.pem;
        index index.php index.html;
        error_log /var/log/nginx/error.log;
        access_log /var/log/nginx/access.log;
        root /var/www/public;
        location ~ \.php$ {
                try_files $uri =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass petapi-app:9000;
                fastcgi_index index.php;
                }
        location / {
                 try_files $uri $uri/ /index.php?$query_string;
                 gzip_static on;
                 }
         }
</code></pre>
<p>再看目录结构</p>
<pre><code>drwxrwxr-x 16 ***** *****     4096 Jul 18 15:05 ./
drwxrwxr-x  4 ***** *****      4096 Jul 13 07:09 ../
drwxrwxr-x 11 ***** *****      4096 Jul 12 17:00 app/
-rw-rw-r--  1 ***** *****      1686 Jul 12 17:00 artisan
drwxrwxr-x  3 ***** *****      4096 Jul 12 17:00 bootstrap/ 
-rw-rw-r--  1 ***** *****      1660 Jul 12 17:00 composer.json
-rw-rw-r--  1 ***** *****    208927 Jul 12 17:00 composer.lock
drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 config/
drwxrwxr-x  5 ***** *****      4096 Jul 12 17:00 database/
drwxrwxr-x  4 ***** *****      4096 Jul 16 06:15 docker-compose/
-rw-rw-r--  1 ***** *****      1806 Jul 18 13:06 docker-compose.prod.yml
-rw-rw-r--  1 ***** *****       741 Jul 12 17:12 Dockerfile
drwxrwxr-x  3 ***** *****      4096 Jul 15 18:07 dockerfiles/
-rw-rw-r--  1 ***** *****       220 Jul 12 17:00 .editorconfig
-rw-rw-r--  1 ***** *****       844 Jul 12 18:37 .env
-rw-rw-r--  1 ***** *****       778 Jul 12 17:00 .env.example
drwxrwxr-x  8 ***** *****      4096 Jul 12 17:00 .git/
-rw-rw-r--  1 ***** *****       111 Jul 12 17:00 .gitattributes
-rw-rw-r--  1 ***** *****       163 Jul 12 17:00 .gitignore
drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 .idea/
-rw-rw-r--  1 ***** *****      1013 Jul 12 17:00 package.json
-rw-rw-r--  1 ***** *****    462139 Jul 12 17:00 package-lock.json
-rw-rw-r--  1 ***** *****      1197 Jul 12 17:00 phpunit.xml
drwxrwxr-x  2 ***** *****      4096 Jul 13 14:46 public/
-rw-rw-r--  1 ***** *****      4497 Jul 12 17:00 README.md
drwxrwxr-x  6 ***** *****      4096 Jul 12 17:00 resources/
drwxrwxr-x  2 ***** *****      4096 Jul 12 17:00 routes/
-rw-rw-r--  1 ***** *****       563 Jul 12 17:00 server.php
drwxrwxr-x  5 ***** ********   4096 Jul 12 17:00 storage/
-rw-rw-r--  1 ***** *****       174 Jul 12 17:00 .styleci.yml
drwxrwxr-x  4 ***** *****      4096 Jul 12 17:00 tests/
drwxr-xr-x 48 ***** *****      4096 Jul 12 18:28 vendor/
-rw-rw-r--  1 ***** *****       538 Jul 12 17:00 webpack.mix.js
</code></pre>
<p>nginx在 api.example.com:80或443请求的时候，80强制转443，然后看443中处理逻辑。</p>
<p>容器中的<code>root /var/www/public/</code>对应的就是宿主机 public文件夹。</p>
<pre><code>location / {
	try_files $uri $uri/ /index.php?$query_string;
	gzip_static on;
	}
</code></pre>
<p>访问的时候，尝试的是比如	<code>http://api.exampl.com/api/pigs/all/1</code>会解析出uri <code>api/pigs/all/1</code>，这个uri文件在public目录中是没有的。</p>
<p>public目录：</p>
<pre><code>drwxrwxr-x  2 ***** ***** 4096 Jul 13 14:46 ./
drwxrwxr-x 16 ***** ***** 4096 Jul 18 15:05 ../
-rw-rw-r--  1 ***** *****    0 Jul 12 17:00 favicon.ico
-rw-rw-r--  1 ***** *****  603 Jul 12 17:00 .htaccess
-rw-rw-r--  1 ***** ***** 1823 Jul 12 17:00 index.php
-rw-rw-r--  1 ***** *****   24 Jul 12 17:00 robots.txt
lrwxrwxrwx  1 ***** *****   27 Jul 13 14:46 storage -&gt; /var/www/storage/app/public
-rw-rw-r--  1 ***** ***** 1194 Jul 12 17:00 web.config
</code></pre>
<p>所以直接跳解析<code>/index.php?$query_string;</code> 然后$query_string就是<code>api/pigs/all/1</code>，然后就是laravel工作逻辑了。解析出request，parameters...</p>
<p>所以这个加载到nginx中是必要的，如果不用try_files呢【没试过】？那应该就app容器开一个端口[比如12343]，然后nginx使用proxy_pass petapi-app:开的端口号[12343] ，这样就ok了吧。</p>
<p>接下来看看ssl配置，前面说到</p>
<blockquote>
<p>ssl的key.pem和cert.pem文件存放在./docker-compose/nginx/certs文件夹下。通过volumes配置，加载到了nginx容器内的/etc/nginx/certs文件夹内。</p>
</blockquote>
<p>所以ssl部分的配置有：</p>
<pre><code>ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;
</code></pre>
<p>同样的来看看</p>
<p>frontapp部分的conf配置：</p>
<pre><code>server {
listen 80;
listen [::]:80;
server_name example.com www.example.com;
return 301 https://$http_host$request_uri;
#rewrite ^(.*)$ https://$host$1 permanent; we just replace request to https
}
server{
listen 443 ssl;
listen [::]:443 ssl;
server_name example.com www.example.com;
#ssl on; no need this anymore please change use listen 443 ssl only
ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;
#ssl_session_timeout 5m;
#ssl_protocols read blow info please;
# By default nginx uses “ssl_protocols TLSv1 TLSv1.1 TLSv1.2” and 
#“ssl_ciphers HIGH:!aNULL:!MD5”, so configuring them explicitly is generally 
#not needed.
index index.php index.html;
error_log /var/log/nginx/error.log;
access_log /var/log/nginx/access.log;
root /var/www/public;
location ~ \.php$ {
try_files $uri =404;
fastcgi_split_path_info ^(.+\.php)(/.+)$;
fastcgi_pass frontapp:9000;
fastcgi_index index.php;
include fastcgi_params;
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
fastcgi_param PATH_INFO $fastcgi_path_info;
}
location / {
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host  $http_host;
proxy_set_header X-Nginx-Proxy true;
proxy_set_header Connection &quot;&quot;;
proxy_pass http://frontapp:8000; #因为在nuxt中 server配置就这个
gzip_static on;
}
}
</code></pre>
<p>与petapi.conf不同的就是</p>
<pre><code>location / {
                proxy_set_header X-Real-IP $remote_addr;
				proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
				proxy_set_header Host  $http_host;
				proxy_set_header X-Nginx-Proxy true;
				proxy_set_header Connection &quot;&quot;;
				proxy_pass http://frontapp:8000; #因为在nuxt中 server配置就这个
                gzip_static on;
                }
</code></pre>
<p>proxy_pass一定是 http://开头+ip+:+端口，</p>
<p>ip用了容器参数，这也是为啥nginx容器的depends_on设置了app和frontapp两个容器，因为要用啊。</p>
<p>端口设置为8000是因为nuxt中<code>nuxt.config.js</code>值为：</p>
<pre><code class="language-js">  server: {
    port: 8000, // default: 3000
    host: '0.0.0.0', // default: localhost,
    timing: false
    // timing: {
    //   total: true
    // }
  },
</code></pre>
<p>端口给设置了8000，node的<a href="#node%E5%AE%B9%E5%99%A8Dockerfile">Dockerfile</a>我们也就没有开端口了。</p>
<p>如果给docker-compose.prod.yml加一个</p>
<pre><code class="language-yml">  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    ports:
     - 800:8000
    networks:
      - petclientn
</code></pre>
<p>注意其中</p>
<pre><code class="language-yml">    ports:
     - 800:8000
</code></pre>
<p>加上了就可以通过宿主机ip[当前环境下就是服务器ip]:8000直接访问nuxt应用。我们这里不用，只是说原理如此。但是如果你给开个443端口访问这个8000端口，会不行，会报端口已经被(就是nginx容器)占用。</p>
<p>docker-compose.prod.yml配置完了，然后执行 <code>docker-compose -f docker-compose.prod.yml build app frontapp</code>给爷生成这两容器的镜像出来。生成完了 执行 <code>docker-compose -f docker-compose.prod.yml up -d</code>就可以跑起来了。执行命令切换到 docker-compose.prod.yml文件的目录下，这样-f指定免得给一串长的地址。</p>
<h2 id="三-laravel发布需要准备的文件和生产环境要做的一些操作">三、laravel发布需要准备的文件和生产环境要做的一些操作</h2>
<p>laravel的代码，我是直接git clone 下来然后进到app容器里</p>
<p>执行</p>
<p><code>cp .env.example .env</code> .env文件。</p>
<p>特别注意</p>
<pre><code>APP_ENV=production
APP_DEBUG=false
APP_URL
</code></pre>
<p><code>php artisan key:generate</code> 生成key</p>
<p>然后自己配置.env文件中的值，mail啊 jwt啊 mysql之类的。</p>
<p><code>php artisan migrate</code> 数据库</p>
<p>然后就是进入db数据库容器，检查用户，表，导入打包的数据库。</p>
<p>接着就是把storage里的文件用rsync给传到服务器[宿主机]的laravel存放文件夹里的storage对应的文件夹里。</p>
<p>再在app容器执行</p>
<p><code>php artisan storage:link</code></p>
<p>然后就可以用了。</p>
<p><code>php artisan optimize</code></p>
<p>至于邮件，需要开启queue，以及<a href="https://medium.com/@ahmeeddhon/laravel-docker-using-alpine-1f80fab7359b">supervisor</a>。【暂缺】【不用supervisor也可以开启queue并确保不service down 参考<a href="#%E4%B8%83%E3%80%81%E6%9B%B4%E6%96%B0">更新部分</a> 】</p>
<h2 id="四-nuxt遇到的坑">四、nuxt遇到的坑</h2>
<p>如果有代码用到了</p>
<p><code>target: (process.env.NODE_ENV === &quot;production&quot;) ? process.env.API_URL : &quot;http://petapi.test/api&quot;,</code></p>
<p>这样的，那env文件必须要有。否则必然报target null 类型错误。</p>
<p>还要安装<a href="https://github.com/nuxt-community/dotenv-module">dotenv</a> ,且配置如下：</p>
<pre><code class="language-js">require('dotenv').config(); //https://github.com/nuxt-community/proxy-module/issues/3


export default{
    ...
    modules: [
   ...
    // Doc: https://github.com/nuxt-community/dotenv-module
    '@nuxtjs/dotenv',
    ...
  ],
        ...
}

</code></pre>
<p>我这个直接用的ssr，目前还是有个问题就是js包太大，要精简一下。虽然nuxt可以直接搞ssl不用nginx，但是这里443端口被nginx占用了，另外nginx还是比node要强。node+nginx推荐。</p>
<p>也是参考的 https://jonathanmh.com/deploying-a-nuxt-js-app-with-docker/</p>
<p>先直接git clone代码，然后COPY到frontapp容器，然后npm install，build，start【<a href="#node%E5%AE%B9%E5%99%A8Dockerfile">Dockerfile里有配置</a>】。</p>
<p>这里其实可以用volume加载到容器的，我是COPY，反正前端也没啥变化，变化了就又要install build一套，volume问题不大。</p>
<p>因为nuxt开发的.gitignore没有添加static文件夹，所以git clone的时候就有了static文件夹里的文件，就不rsync上传了。</p>
<p>记得nano .env添加 .env文件并配置需要的值。</p>
<p>我配置的就有：</p>
<pre><code class="language-env">API_URL=&quot;https://api.example.com/api&quot;
NODE_ENV=&quot;production&quot;
AUTH_URL=&quot;https://api.example.com/api/auth&quot;
</code></pre>
<h2 id="五-mysql">五、mysql</h2>
<p>执行<code>docker cp ./****.sql ***api-db:/tmp/</code>copy到mysql里；</p>
<p>这个容器用的默认的没有bash，只有sh。</p>
<p>一些常用的命令。</p>
<p>mysql -uroot -p</p>
<p>show databases;</p>
<p>use databaseA;</p>
<p>show datatables;</p>
<p>selecr * from datatableA1;</p>
<p>source 打包的地址.sql 【这个用来导入的】</p>
<p>exit</p>
<h2 id="六-nginx">六、nginx</h2>
<p>上面提到的petapi.conf和petclient.conf是怎么加载进nginx的呢？</p>
<p>首先这两个通过<a href="#%E5%AE%8C%E6%88%90%E7%89%88%E6%9C%AC%60docker-compose.prod.yml%60">docker-compose.prod.yml</a> 加载进了容器的 /etc/nginx/conf.d文件夹里，然后</p>
<p>看看nginx.conf文件：</p>
<p>执行<code>docker exec -it pet-nginx sh</code>进到nginx容器，因为没有安装bash所以用sh。</p>
<p>找到nginx.conf打开：</p>
<pre><code class="language-conf">user  nginx;
worker_processes  auto;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
events {
	worker_connections  1024;
}
http {
	include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
</code></pre>
<p>注意就是最后一行<code>include /etc/nginx/conf.d/*.conf;</code>引入了这两个conf文件。</p>
<p>同时我们注意权限：</p>
<pre><code class="language-drwxr-xr-x">drwxr-xr-x    1 root     root          4096 Jul 18 15:11 ..
drwxrwxr-x    2 1000     1000          4096 Jul 15 16:54 certs
drwxrwxr-x    3 1000     1000          4096 Jul 19 18:06 conf.d
-rw-r--r--    1 root     root          1077 Jul  7 16:14 fastcgi.conf
-rw-r--r--    1 root     root          1007 Jul  7 16:14 fastcgi_params
-rw-r--r--    1 root     root          2837 Jul  7 16:14 koi-utf
-rw-r--r--    1 root     root          2223 Jul  7 16:14 koi-win
-rw-r--r--    1 root     root          5231 Jul  7 16:14 mime.types
lrwxrwxrwx    1 root     root            22 Jul 10 20:27 modules -&gt; /usr/lib/nginx/modules
-rw-r--r--    1 root     root           646 Jul  7 16:14 nginx.conf
-rw-r--r--    1 root     root           636 Jul  7 16:14 scgi_params
-rw-r--r--    1 root     root           664 Jul  7 16:14 uwsgi_params
-rw-r--r--    1 root     root          3610 Jul  7 16:14 win-utf
</code></pre>
<p>这里面certs和conf.d文件夹的owner和组都是1000，就是app容器里的用户。里面的文件也是这样的。</p>
<pre><code class="language-drwxrwxr-x">drwxr-xr-x    1 root     root          4096 Jul 18 15:11 ..
drwxrwxr-x    2 1000     1000          4096 Jul 15 16:54 certs
-rw-rw-r--    1 1000     1000          1465 Jul 19 18:06 petapi.conf
-rw-rw-r--    1 1000     1000          1709 Jul 18 15:07 petclient.conf
</code></pre>
<p><strong>注意这是在nginx容器里了。</strong></p>
<p>对比一看 certs文件夹好像重复了。可以改，这样 注释掉<code>- ./docker-compose/nginx/certs:/etc/nginx/certs</code></p>
<p>然后把petapi.conf和petclient.conf里加载ssl文件的路径由：</p>
<pre><code class="language-conf">ssl_certificate /etc/nginx/certs/cert.pem;
ssl_certificate_key /etc/nginx/certs/key.pem;
</code></pre>
<p>改为：</p>
<pre><code class="language-yml">ssl_certificate /etc/nginx/conf.d/certs/cert.pem;
ssl_certificate_key /etc/nginx/conf.d/certs/key.pem;
</code></pre>
<p>nginx解析代理配置，比如：</p>
<pre><code class="language-conf">location /some/path/ {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://localhost:8000;
}
</code></pre>
<p>参考：<a href="https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/">NGINX Reverse Proxy</a></p>
<p>还有个Upstream 参考 <a href="https://docs.nginx.com/nginx/admin-guide/security-controls/securing-http-traffic-upstream/">Securing HTTP Traffic to Upstream Servers</a></p>
<p>以及 <a href="https://www.thepolyglotdeveloper.com/2017/03/nginx-reverse-proxy-containerized-docker-applications/">Use NGINX As A Reverse Proxy To Your Containerized Docker Applications</a></p>
<p>以及 <a href="https://www.freecodecamp.org/news/docker-nginx-letsencrypt-easy-secure-reverse-proxy-40165ba3aee2/">How to set up an easy and secure reverse proxy with Docker, Nginx &amp; Letsencrypt</a></p>
<h4 id="目前存在的bug">目前存在的bug：</h4>
<p>网站标题没有<img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/%E6%89%B9%E6%B3%A8%202020-07-20%20141957.png" alt="批注 2020-07-20 141957" loading="lazy"></p>
<p>privacy没有【已添加页面】，contact么有【不要】，footer没有【已添加】，邮件 【后期申请了服务后更新env文件即可】jwt没配置【已配置】，没开queue【见下方】，recaptcha没配置【已经设置为由env文件配置】。</p>
<p>至于queue，原本打算使用supervisord，但是参考：</p>
<p><a href="https://www.reddit.com/r/docker/comments/8zlakh/advice_best_approach_to_getting_supervisor_setup/">[Advice] Best approach to getting Supervisor setup with a docker compose setup?</a></p>
<blockquote>
<p>​	There is no need for supervisor, just add another php service to your file (same volumes) and add a command line with your queue cmd.</p>
<pre><code class="language-yml">php-queue:
 restart: always
 image: php:7.2-fpm
 command: php artisan queue:work
 volumes:
        - ./www:/var/www
</code></pre>
<p>这里面restart always就能保证重启维护了。</p>
<p>If I wanted to have multiple works would I just setup multiple <code>php-queue</code> containers? Would I need to be concerned about running to many PHP containers on one server?</p>
<blockquote>
<p>If you mean multiple queues then i think that queue:work has a --queue argument so you can specify multiple queues.</p>
<p>If you mean multiple processes then you can use the <code>scale</code> argument in docker-compose, something like:</p>
<pre><code>docker-compose up -d --scale php-queue=3
</code></pre>
<p>For Swarm mode you can use the <a href="https://docs.docker.com/compose/compose-file/#replicas"><code>replicas</code></a> option.</p>
<p><a href="https://github.com/maitrungduc1410/docker-laravel-horizon-load-balancing">Option --scale webserver=3 will create 3 instances of <code>webserver</code> service (you can choose any number of instances you like)</a></p>
</blockquote>
<p>That is an interesting approach. How would you handle reboots and auto running the command?</p>
<blockquote>
<p>Thats what <a href="https://docs.docker.com/compose/compose-file/#restart"><code>restart: always</code></a> does, it will restart the container if it crashes and autostarts them on boot. If you are using Swarm then you should use <a href="https://docs.docker.com/compose/compose-file/#restart_policy">restart-policy</a> instead.</p>
</blockquote>
<p>I would spin up an new container for supervisor Just use the same app path</p>
<p>Remember you need an redis also</p>
</blockquote>
<p>如果确实需要supervisord可以参考<a href="https://stackoverflow.com/a/57353086">How to keep Laravel Queue system running on server</a> ，也可以考虑使用bash脚本：<br>
<a href="https://laravel-news.com/laravel-scheduler-queue-docker">Running the Laravel Scheduler and Queue with Docker</a></p>
<p>所以最后完成版本的docker-composer.prod.yml如下：</p>
<h2 id="七-更新">七、更新</h2>
<h3 id="updated-docker-compose-prodyml">Updated docker-compose-prod.yml</h3>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  php-queue:
    image: php:7.2.19-fpm
    container_name: petapi-app-queue
    command: php artisan queue:work
    working_dir: /var/www/
    restart: always
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    working_dir: /app
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
    networks:
      - petapin
  nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge
</code></pre>
<p>由于进行了一些源代码的更新，特别是前端的代码，所以这里顺带讲解一下以后也可以参考，如何进行更新。</p>
<p>请开始前参考 [Updated docker-compose-prod.yml](#Updated docker-compose-prod.yml) 把<code>docker-compose-prod.yml</code> 更改完毕。</p>
<h3 id="七-一-sql数据库迁移">七、（一） SQL数据库迁移</h3>
<p>首先是后端api，如果需要大更新特别是涉及到数据库的，sql数据库备份很重要。</p>
<p>两种方式:</p>
<h5 id="第一种手动为了走一遍流程">第一种，手动【为了走一遍流程】</h5>
<p>执行<code>docker exec -it petapi-db bash</code>进入db容器</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724023050297.png" alt="image-20200724023050297" loading="lazy"></figure>
<p>执行<code>mysql -uroot -p</code> 并输入密码，登录数据库</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724023113362.png" alt="" loading="lazy"></figure>
<p>登录后执行<code>show databases;</code>检查数据库，然后确认我们要备份的数据库</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724023211774.png" alt="" loading="lazy"></figure>
<p>接下来执行<code>exit</code>退出数据库登录，</p>
<p>在db容器shell执行<code>mysqldump -uroot -p ***api &gt; backup.sql</code> 就可以了，格式参考<a href="https://blog.shanelee.name/2017/04/09/how-to-import-and-export-databases-in-mysql-or-mariadb-with-docker/">How To Import and Export Databases in MySQL or MariaDB with Docker</a>为：</p>
<pre><code class="language-bash">mysqldump -u username -p database_name &gt; dump.sql  
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724023446387.png" alt="" loading="lazy"></figure>
<p>可以执行<code>head -n 5 backup.sql</code> 检查结果；<code>5</code>不够可以设置<code>20</code></p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724023737718.png" alt="" loading="lazy"></figure>
<p>由于我们的db容器把数据卷设置在了<code>docker-entrypoint-initdb.d</code>文件夹里，所以最好是备份到这文件夹里。这样宿主机备份后，宿主机可以直接拿到，这里我就直接给mv到文件夹里去了。</p>
<p><code>exit</code>退出容器，然后就可以在宿主机 <code>docker-compose.prod.yml</code>的上下文<code>./docker-compose/mysql</code>文件夹路径里看到我们刚dump打包的数据库备份文件了。</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724024534310.png" alt="" loading="lazy"></figure>
<p>接下来就是<a href="#%E4%BA%94%E3%80%81mysql">参考之前的导入方法</a>导入到新数据库即可。</p>
<h5 id="第二种使用databackmysql-backup">第二种，使用<a href="https://hub.docker.com/r/databack/mysql-backup">databack/mysql-backup</a></h5>
<p>建议使用这种方式，因为可以自动执行备份。即使不迁移，平时的运维也应该这么做好备份比较安全。备份完成之后，建议直接发送或上传到库。</p>
<h3 id="七-二pull-更新后的laravel-api后端代码">七、（二）pull 更新后的laravel api后端代码</h3>
<p>其实就是重复操作 <a href="#%E4%B8%89%E3%80%81laravel%E5%8F%91%E5%B8%83%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%A6%81%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C">三、laravel发布需要准备的文件和生产环境要做的一些操作</a></p>
<h3 id="七-三-前端部分">七、（三） 前端部分</h3>
<p>整体来说可以参考<a href="#%E5%9B%9B%E3%80%81nuxt%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91">四、nuxt遇到的坑</a> ，这里当然详细讲解一下。</p>
<p>首先是把代码更新到github。</p>
<p>执行 <code>ssh user_name@server_ip_address</code>登录到服务器。</p>
<p>node的Dockerfile不需要更新了。</p>
<p>我们直接切到 <a href="#node%E5%AE%B9%E5%99%A8Dockerfile">node容器Dockerfile</a> 上下文的路径 <code>./pet-client</code>下，参考 [<code>docker-compose.prod.yml</code>](#Updated docker-compose-prod.yml)中frontapp部分定义的context:<code>context: ~/petclient/dockerfiles/node/</code> ，即切换到的路径是<code>~/petclient/dockerfiles/node/pet-client</code> 这里面就是我们前端代码存放的位置了。</p>
<p>在 <code>~/petclient/dockerfiles/node/</code>这个路径下执行：<code>rm -rf pets-client/</code>删除掉前端代码，因为我们的容器镜像，打包的时候是直接COPY到容器内的。更新的时候，删除这个文件夹，然后稍后删除镜像，重新打包启动即可。</p>
<p>然后执行 <code>git clone https://github.com/****/******.git</code> 把代码拉到宿主机内。如果已经clone过的 可以<code>git pull https://github.com/****/******.git</code>进行update。</p>
<p>然后切换到<code>docker-compose.prod.yml</code>所在文件夹路径下执行: <code>docker-compose -f docker-compose.prod.yml down</code>关闭所有服务。</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/image-20200724141740430.png" alt="" loading="lazy"></figure>
<blockquote>
<p>这个警告是因为我们编辑过<code>docker-compose.prod.yml</code>，但是运行的服务并不是这个编辑过的。以后最好是全部停了之后，再编辑。</p>
</blockquote>
<p>接下来执行 <code>docker ps -a</code>查看容器，移除掉旧版本的容器。</p>
<p>接下来执行 <code>docker images</code>查看镜像，然后执行<code>docker rmi 镜像名</code>的方式移除掉node，frontapp镜像，</p>
<p>然后执行<code>docker-compose -f docker-compose.prod.yml build frontapp</code> 构建frontapp的镜像。</p>
<p>构建完成 执行 <code>docker-compose -f docker-compose.prod.yml up -d</code>即可。</p>
<p>容器完全构建好了并启动之后，继续下面的操作。</p>
<h3 id="七-四配置env文件">七、（四）配置.env文件</h3>
<blockquote>
<p><strong>如果docker-compose.yml文件和Dockerfile提前需要.env文件中设置的值，那此步骤需要在build前操作。</strong></p>
<p>因为后端api是数据卷挂载到容器内的，所以.env文件可以宿主机里编辑。</p>
<p>frontapp是COPY到容器内的，所以需要切换到容器内，或者<strong>在build前建立好，build执行的时候直接COPY到容器内了</strong>，建议提前在petclient被clone到本地后就编辑好。</p>
<p>如果是需要容器内修改，</p>
<p>执行<code>docker exec -it petclient-frontapp bash</code>进入容器内。</p>
<p>执行 vi .env 然后编辑然后保存退出。</p>
</blockquote>
<p>完成。</p>
<p>补充，最好精简一下css 及 js代码。</p>
<h3 id="七-五参考mysql-docker容器关于如何处理down后up数据就丢失的问题以及原理-防止每次重新配置数据库">七、（五）参考<a href="https://dzkjz.github.io/post/mysql-docker-rong-qi-guan-yu-ru-he-chu-li-down-hou-up-shu-ju-jiu-diu-shi-de-wen-ti-yi-ji-yuan-li/">Mysql Docker容器关于如何处理down后up数据就丢失的问题以及原理</a> 防止每次重新配置数据库</h3>
<p><code>docker-compose.prod.yml</code>更新为：</p>
<pre><code class="language-yml">version: &quot;3.7&quot;
services:
  app:
    build:
      args:
        user: petapi
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: petapii
    container_name: petapi-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - petapin
  php-queue:
    restart: always
    container_name: petapi-app-queue
    working_dir: /var/www/
    image: php:7.2.19-fpm
    command: php artisan queue:work
    volumes:
      - ./:/var/www
    networks:
      - petapin
  frontapp:
    build:
      context: ~/petclient/dockerfiles/node/
      dockerfile:  Dockerfile
    image: frontapp
    container_name: petclient-frontapp
    restart: unless-stopped
    networks:
      - petclientn
  db:
    image: mysql:5.7
    container_name: petapi-db
    restart: unless-stopped
    env_file:
      - ~/petapi/pets-api/.env
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - ./docker-compose/mysql:/docker-entrypoint-initdb.d
      - ./docker-compose/mysql/data:/var/lib/mysql
    networks:
      - petapin
  nginx:
    image: nginx:1.19.1-alpine
    container_name: pet-nginx
    restart: always
    depends_on:
      - app
      - frontapp
    ports:
      - 80:80
      - 443:443
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d
      - ./docker-compose/nginx/certs:/etc/nginx/certs
    networks:
      - petapin
      - petclientn
networks:
  petapin:
    driver: bridge
  petclientn:
    driver: bridge
</code></pre>
<h2 id="八-ssl-cronjob-与-supervisor介绍">八、ssl cronJob 与 supervisor介绍</h2>
]]></content>
    </entry>
</feed>