<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dzkjz.github.io/</id>
    <title>JojoLegend</title>
    <updated>2020-08-15T14:55:41.618Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dzkjz.github.io/"/>
    <link rel="self" href="https://dzkjz.github.io/atom.xml"/>
    <subtitle>Something for age</subtitle>
    <logo>https://dzkjz.github.io/images/avatar.png</logo>
    <icon>https://dzkjz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JojoLegend</rights>
    <entry>
        <title type="html"><![CDATA[Laradock Win10 ]]></title>
        <id>https://dzkjz.github.io/post/laradock-win10/</id>
        <link href="https://dzkjz.github.io/post/laradock-win10/">
        </link>
        <updated>2020-08-15T13:31:39.000Z</updated>
        <content type="html"><![CDATA[<p>参考官方的<a href="https://laradock.io/">文档</a> 以及<a href="https://xueyuanjun.com/post/9608">在 Mac/Windows 系统中使用 Laradock 搭建基于 Docker 的 Laravel 开发环境</a>安装</p>
<p>给👴一直报错。</p>
<blockquote>
<pre><code class="language-powershell">ERROR: for postgres  Cannot create container for service postgres: status code not OK but 500: {&quot;Message&quot;:&quot;Unhandled exception: Filesharing has been cancelled&quot;,&quot;StackTrace&quot;:&quot;   at Docker.ApiServices.Mounting.FileSharing.&lt;**DoShareAsync**&gt;d__6.MoveNext() in C:\workspaces\stable-2.3.x\src\github.com\docker\pinata\win\src\Docker.ApiServices\Mounting\FileSharing.cs:line 0\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Docker.ApiServices.Mounting.FileSharing.&lt;**ShareAsync**&gt;d__4.MoveNext() in C:\workspaces\stable-2.3.x\src\github.com\docker\pinata\win\src\Docker.ApiServices\Mounting\FileSharing.cs:line 47\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Docker.HttpApi.Controllers.FilesharingController.&lt;**ShareDirectory**&gt;d__2.MoveNext() in C:\workspaces\stable-2.3.x\src\github.com\docker\pinata\win\src\Docker.HttpApi\Controllers\FilesharingController.cs:line 21\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Threading.Tasks.TaskHelpersExtensions.&lt;**CastToObject**&gt;d__1`1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;**InvokeActionAsyncCore**&gt;d__1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Controllers.ActionFilterResult.&lt;**ExecuteAsync**&gt;d__5.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at System.Web.Http.Dispatcher.HttpControllerDispatcher.&lt;**SendAsync**&gt;d__15.MoveNext()&quot;}	
</code></pre>
</blockquote>
<p>反正就是这类，没截完，</p>
<p>根据</p>
<p>https://github.com/docker/for-win/issues/5456</p>
<p>https://stackoverflow.com/questions/59942110/docker-drive-has-not-been-shared</p>
<p>https://forums.docker.com/t/cannot-share-drive-in-windows-10/28798</p>
<p>以及</p>
<blockquote>
<p><a href="http://www.karlxu.com/article/details/24">Laradock遇到的坑</a></p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200815212846.png" alt="" loading="lazy"></figure>
</blockquote>
<p>就是设置FILESHARING 里添加需要sharing的<strong>C盘和D盘</strong>就ok了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue之inheritAttrs]]></title>
        <id>https://dzkjz.github.io/post/vue-zhi-inheritattrshttpscnvuejsorgv2apiinheritattrs/</id>
        <link href="https://dzkjz.github.io/post/vue-zhi-inheritattrshttpscnvuejsorgv2apiinheritattrs/">
        </link>
        <updated>2020-08-13T05:48:34.000Z</updated>
        <content type="html"><![CDATA[<p>参考<a href="https://stackoverflow.com/questions/56224091/what-are-inheritattrsfalse-and-attrs-used-for-in-vue">what are inheritAttrs:false and $attrs used for in vue?</a>：</p>
<blockquote>
<pre><code>// Component
Vue.component('base-input', {
 inheritAttrs: false,
 props: ['label', 'value'],
 template: `
   &lt;label&gt;
     {{ label }}
     &lt;input
       v-bind=&quot;$attrs&quot;
       v-bind:value=&quot;value&quot;
       v-on:input=&quot;$emit('input', $event.target.value)&quot;
     &gt;
   &lt;/label&gt;
 `
})

// Usage
&lt;base-input
 v-model=&quot;username&quot;
 required
 placeholder=&quot;Enter your username&quot;
/&gt;
</code></pre>
<p>The <code>required</code> and <code>placeholder</code> attributes are then set on the <code>input</code> instead of the wrapping <code>label</code>.</p>
<p>It doesn't really have anything to do with children of children of components but it can be used in such a hierarchy.</p>
<p>I hope that clears things up for you.</p>
<p>上面的示例代码来自 <a href="https://vuejs.org/v2/guide/components-props.html#Disabling-Attribute-Inheritance">Disabling Attribute Inheritance</a>官方文档。</p>
<p>其实就是 <code>inheritAttrs</code>设置为<code>false</code>值之后，</p>
<p>使用的</p>
<pre><code>&lt;base-input
 v-model=&quot;username&quot;
 required
 placeholder=&quot;Enter your username&quot;
</code></pre>
<p>这里面设置的 <code>required</code> 和 <code>placeholder</code>就不在模板根元素<code>label</code>上，而是在指定了<code>$attrs</code>的</p>
<pre><code>&lt;input
       v-bind=&quot;$attrs&quot;
</code></pre>
<p><code>input</code>标签上。参考这个，以后要用的就是你想设置到哪里，就设置<code>$attrs</code>到哪里，一般这个用在自定义基础组件<a href="https://vuejs.org/v2/style-guide/#Base-component-names-strongly-recommended">base components</a>的上面。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 之 作用域插槽]]></title>
        <id>https://dzkjz.github.io/post/vue-zhi-zuo-yong-yu-cha-cao/</id>
        <link href="https://dzkjz.github.io/post/vue-zhi-zuo-yong-yu-cha-cao/">
        </link>
        <updated>2020-08-11T18:53:34.000Z</updated>
        <content type="html"><![CDATA[<p>参考<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%85%B6%E5%AE%83%E7%A4%BA%E4%BE%8B">其他示例</a><br>
其实</p>
<pre><code> &lt;slot name=&quot;todo&quot; v-bind:todo=&quot;todo&quot;&gt;
      &lt;!-- 后备内容 --&gt;
      {{ todo.text }}
    &lt;/slot&gt;
</code></pre>
<p>就是把子组件中的 todo 暴露给外层组件</p>
<p>然后外层组件就可以通过</p>
<pre><code> &lt;template v-slot:todo=&quot;{ todo }&quot;&gt;
    &lt;span v-if=&quot;todo.isComplete&quot;&gt;✓&lt;/span&gt;
    {{ todo.text }}
  &lt;/template&gt;
</code></pre>
<p>这里面用了{todo}解构出上面slot的<code>:todo</code>其值为上面那个组件中的<code>todo</code>值，<br>
暴露出来在外层组件的template里面，就可以访问了：<code>todo.isComplete</code>及<code>{{ todo.text }}</code>就是从外层访问的子组件中的值。<br>
slot只能通过这种方式由内而外，被外层访问到。<br>
需要注意的是，之前版本是<code>slot-scope=&quot;slotProps&quot;</code>这种方式访问的，但是已经被<strong>废弃了</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义组件的 v-model]]></title>
        <id>https://dzkjz.github.io/post/zi-ding-yi-zu-jian-de-v-model/</id>
        <link href="https://dzkjz.github.io/post/zi-ding-yi-zu-jian-de-v-model/">
        </link>
        <updated>2020-08-11T15:45:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="自定义组件的"><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model">自定义组件的 <code>v-model</code></a></h1>
<p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突：</p>
<pre><code>Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    &lt;input
      type=&quot;checkbox&quot;
      v-bind:checked=&quot;checked&quot;
      v-on:change=&quot;$emit('change', $event.target.checked)&quot;
    &gt;
  `
})
</code></pre>
<p>现在在这个组件上使用 <code>v-model</code> 的时候：</p>
<pre><code>&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;
</code></pre>
<p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p>
<p>注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p>
<p>就是说：</p>
<p>默认情况下：</p>
<p><code>&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</code></p>
<p>lovingVue会对应到<code>base-checkbox</code>里面的value值，但是如果外层component需要的是使用这个<code>base-checkbox</code>component的其他属性，那就用</p>
<pre><code>  model: {
    prop: 'checked',
    event: 'change'
  },
</code></pre>
<p>这种方式；</p>
<p><code>v-model=&quot;lovingVue&quot;</code>对应到的就是<code>base-checkbox</code>component里面的<code>checked</code>属性，这个属性必须在该组件props里声明，</p>
<p>且</p>
<pre><code>v-on:change=&quot;$emit('change', $event.target.checked)&quot;
</code></pre>
<p>以及</p>
<pre><code> model: {
    prop: 'checked',
    event: 'change'
  },
</code></pre>
<p>中的<code>event: 'change'</code>都不可省略，还必须对应，抛出的事件和model里的事件必须一样。</p>
<p>拓展分析：</p>
<p>有这样一个组件</p>
<pre><code class="language-vue">//BaseInput.vue
&lt;template&gt;
    &lt;label class=&quot;inner base&quot;&gt;
        {{ label }} : {{value}}
        &lt;input :placeholder=&quot;$attrs['placej']&quot;
               :value=&quot;value&quot;
               @input=&quot;$emit('inputa', $event.target.value)&quot;&gt;
    &lt;/label&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name: &quot;BaseInput&quot;,
        inheritAttrs: false,
        props: ['label', 'value'],
        model: {
            prop: 'label',
            event: 'inputa'
        }
    }
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>外层组件</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;div &gt;
        &lt;BaseInput class=&quot;outter home&quot; placej=&quot;aj&quot; v-model=&quot;bi&quot;&gt;&lt;/BaseInput&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name: 'Home',
        data() {
            return {
                bi: '',
            }
        },
    }
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;

</code></pre>
<p>流程分析：</p>
<p>首先<code>BaseInput.vue</code>中两个属性<code>props: ['label', 'value']</code>是空值。接下来，当输入的时候，input事件触发，在<code>BaseInput.vue</code>中</p>
<p><code>@input=&quot;$emit('inputa', $event.target.value)&quot;</code>，抛出<code>inputa</code>事件，值为input更加底层的value即<code>$event.target.value</code>抛出；</p>
<p>然后由于</p>
<pre><code> model: {
            prop: 'label',
            event: 'inputa'
        }
</code></pre>
<p>所以，label值被设置为这个<code>$event.target.value</code>的值，并<code>v-model=&quot;bi&quot;</code>设置到外层组件的<code>bi</code>值，同时，value值因为<code>:value=&quot;value&quot;</code>而该组件中value为空，则一旦触发<code>input</code>事件，这个<code>:value</code>又被重置为空，输入框值也就被清空。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 之 $attrs]]></title>
        <id>https://dzkjz.github.io/post/vue-zhi-dollarattrs/</id>
        <link href="https://dzkjz.github.io/post/vue-zhi-dollarattrs/">
        </link>
        <updated>2020-08-11T13:41:46.000Z</updated>
        <content type="html"><![CDATA[<p>参考<a href="https://medium.com/@filip.stepien/using-v-model-attrs-on-vue-components-7fc44a315270">Using v-model + $attrs on Vue Components</a>：</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;div&gt;
    &lt;label for=&quot;name&quot; :class=&quot;label_cls&quot;&gt;Name&lt;/label&gt;
    &lt;input :class=&quot;input_cls&quot; id=&quot;name&quot; v-model=&quot;$attrs.value.name&quot;&gt;
    &lt;label for=&quot;role&quot; :class=&quot;label_cls&quot;&gt;Title&lt;/label&gt;
    &lt;input :class=&quot;input_cls&quot; id=&quot;role&quot; v-model=&quot;$attrs.value.role&quot;&gt;
    &lt;label for=&quot;email&quot; :class=&quot;label_cls&quot;&gt;Email&lt;/label&gt;
    &lt;input :class=&quot;input_cls&quot; id=&quot;email&quot; v-model=&quot;$attrs.value.email&quot;&gt;
    &lt;label for=&quot;insta&quot; :class=&quot;label_cls&quot;&gt;Instagram&lt;/label&gt;
    &lt;input :class=&quot;input_cls&quot; id=&quot;insta&quot; v-model=&quot;$attrs.value.insta&quot; autocomplete=&quot;insta_off&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapGetters } from &quot;vuex&quot;;
export default {
  name: &quot;UserFields&quot;,
  computed: {
    input_cls() {
      return &quot;w-full appearance-none border rounded py-2 px-3 mb-6 text-grey-darkest&quot;;
    },
    label_cls() {
      return &quot;text-grey-darker font-light inline-block mb-2&quot;;
    }
  }
};
&lt;/script&gt;
</code></pre>
<pre><code class="language-js">&lt;template&gt;
  &lt;div class=&quot;w-5/6 md:w-3/4 lg:w-2/3 mx-auto mt-8&quot; v-if=&quot;activeUser&quot;&gt;
    &lt;h2 class=&quot;font-light&quot;&gt;Account Settings&lt;/h2&gt;
    &lt;div class=&quot;flex mt-8 pt-8 border-t border-grey-light&quot;&gt;
      &lt;div class=&quot;w-64 hidden md:block&quot;&gt;
        &lt;div class=&quot;mb-2&quot;&gt;Profile&lt;/div&gt;
        &lt;span class=&quot;text-xs text-grey-dark&quot;&gt;
          Keep your user infomation up to date so that team members can contact
          you.
        &lt;/span&gt;
      &lt;/div&gt;
      &lt;form @submit.prevent=&quot;updateUser(user);&quot; class=&quot;flex flex-col md:ml-8 w-full&quot;&gt;
        &lt;UserFields v-model=&quot;user&quot;/&gt;
        &lt;div class=&quot;flex items-center&quot;&gt;
          &lt;input
            class=&quot;bg-blue hover:bg-blue-dark text-white font-normal py-2 px-4 my-6 rounded w-48 tracking-wide&quot;
            type=&quot;submit&quot;
            value=&quot;Submit&quot;
          &gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { mapGetters, mapActions } from &quot;vuex&quot;;
import UserFields from &quot;./UserFields.vue&quot;;
export default {
  name: &quot;UserForm&quot;,
  components: {
    UserFields
  },
  data() {
    return {
      user: {}
    };
  },
  mounted() {
    this.getUser();
  },
  computed: {
    ...mapGetters([&quot;activeUser&quot;])
  },
  methods: {
    ...mapActions([&quot;getUser&quot;, &quot;updateUser&quot;]),
    updateLocalUser(e) {
      this.$set(this.user, e.target.id, e.target.value);
    }
  },
  watch: {
    activeUser: {
      handler() {
        this.user = { ...this.activeUser };
      }
    },
    immediate: true
  }
};
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 源码学习之main.js代码解析]]></title>
        <id>https://dzkjz.github.io/post/vue-yuan-ma-xue-xi-zhi-mainjs-dai-ma-jie-xi/</id>
        <link href="https://dzkjz.github.io/post/vue-yuan-ma-xue-xi-zhi-mainjs-dai-ma-jie-xi/">
        </link>
        <updated>2020-08-08T16:00:18.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">//main.js
import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

new Vue({
  render: h =&gt; h(App),
}).$mount('#app')

</code></pre>
<h4 id="vmmount"><a href="https://cn.vuejs.org/v2/api/index.html#vm-mount">vm.$mount</a></h4>
<blockquote>
<p>​	[vm.$mount( [elementOrSelector] )]</p>
<ul>
<li>
<p><strong>参数</strong>：</p>
<ul>
<li><code>{Element | string} [elementOrSelector]</code></li>
<li><code>{boolean} [hydrating]</code></li>
</ul>
</li>
<li>
<p><strong>返回值</strong>：<code>vm</code> - 实例自身</p>
</li>
<li>
<p><strong>用法</strong>：</p>
<p>如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 <code>vm.$mount()</code> 手动地挂载一个未挂载的实例。</p>
<p>如下：</p>
<pre><code class="language-js">new Vue({el:'#app'})
或者
new Vue().$mount('#app')
</code></pre>
<p>拓展一下 这个<a href="https://cn.vuejs.org/v2/api/index.html#el">el</a>选项</p>
<blockquote>
<ul>
<li><strong>类型</strong>：<code>string | Element</code></li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>
<p><strong>限制</strong>：只在用 <code>new</code> 创建实例时生效。</p>
</li>
<li>
<p><strong>详细</strong>：</p>
<p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p>
<p>在实例挂载之后，元素可以用<a href="#vm.$el"><code>vm.$el</code></a>访问。</p>
<p>如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 <a href="#vm.$mount"><code>vm.$mount()</code></a> 手动开启编译。</p>
<p>提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。<strong>因此不推荐挂载 root 实例到 <code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code> 上</strong>。</p>
<p>如果 <code>render</code> 函数和 <code>template</code> property 都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。</p>
</li>
</ul>
</blockquote>
<p>如果没有提供 <code>elementOrSelector</code> 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。</p>
<p>如下：</p>
<pre><code class="language-js">var v = new Vue().$mount();
document.getElementById('app').appendChild(v.$el);
</code></pre>
<p>其中v.$el解释：</p>
<blockquote>
<h4 id="vmel"><a href="https://cn.vuejs.org/v2/api/index.html#vm-el">vm.$el</a></h4>
<ul>
<li>
<p><strong>类型</strong>：<code>Element</code></p>
</li>
<li>
<p><strong>只读</strong></p>
</li>
<li>
<p><strong>详细</strong>：</p>
<p>Vue 实例使用的根 DOM 元素。</p>
</li>
</ul>
</blockquote>
<p>这个方法返回实例自身，因而可以链式调用其它实例方法。</p>
</blockquote>
<h4 id="productiontip"><a href="https://cn.vuejs.org/v2/api/index.html#productionTip">productionTip</a></h4>
<blockquote>
<blockquote>
<p>2.2.0 新增</p>
</blockquote>
<ul>
<li>
<p><strong>类型</strong>：<code>boolean</code></p>
</li>
<li>
<p><strong>默认值</strong>：<code>true</code></p>
</li>
<li>
<p><strong>用法</strong>：</p>
<p>设置为 <code>false</code> 以阻止 vue 在启动时生成生产提示。</p>
</li>
</ul>
</blockquote>
<p>实例化vue的选项这里只用到了render，在介绍render之前，先介绍template选项：</p>
<h4 id="template"><a href="https://cn.vuejs.org/v2/api/index.html#template">template</a></h4>
<blockquote>
<p>​	<strong>类型</strong>：<code>string</code></p>
<ul>
<li>
<p><strong>详细</strong>：</p>
<p>一个字符串模板作为 Vue 实例的标识使用。模板将会<strong>替换</strong>挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽（slot）。</p>
<p>如果值以 <code>#</code> 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 包含模板。</p>
<p>参考<a href="https://vuejsdevelopers.com/2017/03/24/vue-js-component-templates/"><em>7 Ways to Define a Component Template in Vue.js</em></a></p>
</li>
</ul>
<blockquote>
<p>这种用法一般就是示例才用：</p>
<pre><code class="language-js">Vue.component('alert-box', {
template: `
 &lt;div class=&quot;demo-alert-box&quot;&gt;
   &lt;strong&gt;Error!&lt;/strong&gt;
   &lt;slot&gt;&lt;/slot&gt;
 &lt;/div&gt;
`
})
</code></pre>
<p>更多的就是X-templates</p>
<blockquote>
<pre><code class="language-js">//app.js
Vue.component('my-checkbox', {
  template: '#checkbox-template',
  data() {
    return { checked: false, title: 'Check me' }
  },
  methods: {
    check() { this.checked = !this.checked; }
  }
});
</code></pre>
<pre><code class="language-html">&lt;!--index.html--&gt;
&lt;div id=&quot;app&quot;&gt;...&lt;/div&gt;
&lt;script type=&quot;text/x-template&quot; id=&quot;checkbox-template&quot;&gt;
  &lt;div class=&quot;checkbox-wrapper&quot; @click=&quot;check&quot;&gt;
    &lt;div :class=&quot;{ checkbox: true, checked: checked }&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;title&quot;&gt;{{ title }}&lt;/div&gt;
  &lt;/div&gt;
&lt;/script&gt;
</code></pre>
<p>即：在index.html中定义一个type为text/x-template的sctipt标签，给一个id：checkbox-template，组件中template选项就不用再写字符串，而是直接就用这个id引用script上的模板了。</p>
</blockquote>
</blockquote>
<ol>
<li>
<p>出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。</p>
</li>
<li>
<p>如果 Vue 选项中包含<a href="#render">渲染函数</a>，该模板将被忽略。</p>
</li>
</ol>
</blockquote>
<p>介绍了template，现在介绍render选项。</p>
<h4 id="render"><a href="https://cn.vuejs.org/v2/api/index.html#render">render</a></h4>
<blockquote>
<ul>
<li>
<p><strong>类型</strong>：<code>(createElement: () =&gt; VNode) =&gt; VNode</code></p>
</li>
<li>
<p><strong>详细</strong>：</p>
<p>字符串模板<a href="#template">template</a>的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>。</p>
<p>如果组件是一个函数组件，渲染函数还会接收一个额外的 <code>context</code> 参数，为没有实例的函数组件提供上下文信息。</p>
<p>Vue 选项中的 <code>render</code> 函数若存在，则 Vue 构造函数不会从 <code>template</code> 选项或通过 <code>el</code> 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</p>
</li>
</ul>
<p>这个解释太理论了。直接从<a href="https://vuejs.org/v2/guide/render-function.html">render-function</a>摘一段</p>
<pre><code class="language-js">Vue.component('anchored-heading', {
  render: function (createElement) {
    return createElement(
      'h' + this.level,   // tag name
      this.$slots.default // array of children
    )
  },
  props: {
    level: {
      type: Number,
      required: true
    }
  }
})
</code></pre>
<p>再看看<a href="https://www.tutorialspoint.com/vuejs/vuejs_render_function.htm">vuejs render function</a>的示例：</p>
<blockquote>
<p>将这个</p>
<pre><code class="language-html">&lt;html&gt;
   &lt;head&gt;
      &lt;title&gt;VueJs Instance&lt;/title&gt;
      &lt;script type = &quot;text/javascript&quot; src = &quot;js/vue.js&quot;&gt;&lt;/script&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;div id = &quot;component_test&quot;&gt;
         &lt;testcomponent&gt;Hello Jai&lt;/testcomponent&gt;
         &lt;testcomponent&gt;Hello Roy&lt;/testcomponent&gt;
         &lt;testcomponent&gt;Hello Ria&lt;/testcomponent&gt;
         &lt;testcomponent&gt;Hello Ben&lt;/testcomponent&gt;
      &lt;/div&gt;
      &lt;script type = &quot;text/javascript&quot;&gt;
         Vue.component('testcomponent',{
            template : '&lt;h1&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/h1&gt;',
            data: function() {
            },
            methods:{
            }
         });
         var vm = new Vue({
            el: '#component_test'
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>通过使用render function 优化成：</p>
<pre><code class="language-html">&lt;html&gt;
   &lt;head&gt;
      &lt;title&gt;VueJs Instance&lt;/title&gt;
      &lt;script type = &quot;text/javascript&quot; src = &quot;js/vue.js&quot;&gt;&lt;/script&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;div id = &quot;component_test&quot;&gt;
         &lt;testcomponent :elementtype = &quot;'div,red,25,div1'&quot;&gt;Hello Jai&lt;/testcomponent&gt;
         &lt;testcomponent :elementtype = &quot;'h3,green,25,h3tag'&quot;&gt;Hello Roy&lt;/testcomponent&gt;
         &lt;testcomponent :elementtype = &quot;'p,blue,25,ptag'&quot;&gt;Hello Ria&lt;/testcomponent&gt;
         &lt;testcomponent :elementtype = &quot;'div,green,25,divtag'&quot;&gt;Hello Ben&lt;/testcomponent&gt;
      &lt;/div&gt;
      &lt;script type = &quot;text/javascript&quot;&gt;
         Vue.component('testcomponent',{
            render :function(createElement){
               var a = this.elementtype.split(&quot;,&quot;);
               return createElement(a[0],{
                  attrs:{
                     id:a[3],
                     style:&quot;color:&quot;+a[1]+&quot;;font-size:&quot;+a[2]+&quot;;&quot;
                  }
               },
               this.$slots.default
               )
            },
            props:{
               elementtype:{
                  attributes:String,
                  required:true
               }
            }
         });
         var vm = new Vue({
            el: '#component_test'
         });
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</blockquote>
<p>不过我觉得解释比较通顺的应该是：</p>
<p><a href="https://snipcart.com/blog/vue-render-functions">Vue render functions</a>中的：</p>
<blockquote>
<p>Each <a href="https://snipcart.com/blog/vue-component-example-tutorial"><strong>Vue component</strong></a> implements a render function. Most of the time, the function will be created by the Vue compiler. When you specify a <code>template</code> on your component, the content of this template will be processed by the Vue compiler that will return a render function. The render function essentially returns a virtual DOM node which will be rendered by Vue in your browser DOM.</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/renderingprocess.png" alt="" loading="lazy"></figure>
<blockquote>
<p>同时本文指出，虚拟DOM可以在更新浏览器前渲染组件，正是因为与浏览器的直接接触较少，所以速度更快。</p>
<blockquote>
<p>摘一段 https://blog.logrocket.com/using-jsx-with-vue/</p>
<p>Vue creates a Virtual DOM that keeps track of all the changes made to the real DOM and on every data change Vue returns a new Virtual DOM, it then compares the old virtual DOM to the new one and checks for specific changes and makes adjustments in the real DOM.</p>
<p>The process of comparing and checking changes between the old and the new Virtual DOM is referred to as <a href="https://en.wikipedia.org/wiki/Diff">diffing</a>.</p>
<p>This <a href="https://template-explorer.vuejs.org/">mini-app</a> helps explore the Vue templates and render functions, you can learn more about render functions in Vue and the Virtual DOM <a href="https://blog.logrocket.com/accessing-the-virtual-dom-using-render-functions-in-vue-js/">here</a>.</p>
</blockquote>
<p>这样更新的元素就更少，提高了效率，render function返回的就是虚拟DOM节点【通常叫VNode】，which is an interface that allows Vue to write these objects in your browser DOM。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/vuegraph.jpg" alt="" loading="lazy"></figure>
</blockquote>
<blockquote>
<p>组件中都可以用这个render function，一旦组件的属性更新了，这个render function就会被调用。</p>
<p>多数时候，这个render function是直接在build项目的时候，直接被vue 打包好的，你可以不用每个组件都写一遍这个render function。</p>
</blockquote>
<p>其余的部分不摘抄了，有很多高级的内容。</p>
<blockquote>
<p>这个传入的createElement方法，是vue自带的，可以用于创建element。</p>
</blockquote>
<p>《vue.js》书的作者有一个视频讲解：<a href="https://www.youtube.com/watch?v=l0eZCvJcYZ8">Create A Vue App With Render Functions Tutorial! What Is it?</a></p>
<blockquote>
<p>​	一般情况下我们是用的比如</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;home&quot; @click=&quot;()=&gt;alert('test')&quot;&gt;
    &lt;p&gt;
       no class
    &lt;/p&gt;
      &lt;p class=&quot;textp&quot;&gt;
        what a world
    &lt;/p&gt;
      &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;
      
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import HelloWorld from './components/HelloWorld.vue'

export default {
  name: 'hello',
  components: {
    HelloWorld
  }
}
&lt;/script&gt;

&lt;style&gt;

&lt;/style&gt;
</code></pre>
<p>这样的vue文件</p>
<p>就是 template 然后 script 然后 style</p>
<p>如果使用render可以直接不用template，也不用</p>
<pre><code class="language-vue">components: {
    HelloWorld
  }
</code></pre>
<p>直接</p>
<pre><code class="language-vue">&lt;script&gt;
import HelloWorld from './components/HelloWorld.vue'

export default {
  name: 'hello',
 render(createElement){
     return createElement(&quot;div&quot;,{
         attr:{
             class:&quot;home&quot;
         },
         on:{
             click:()=&gt;alert(&quot;test&quot;)
         }
     },
      [
         createElement(&quot;p&quot;,{},&quot;no class&quot;),
         createElement(&quot;p&quot;,{
             attr:{
                 class:&quot;textp&quot;
             }
         },&quot;what a world&quot;),
         createElement(HelloWorld,{
             props:{
                 msg:&quot;created!&quot;
             }
         })
     ])
 }
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;

</code></pre>
<p>一般还是用的template，因为比较直观，但是如果代码重复太多，那还是不要重复造轮，直接用这种createElement方式，反正两种方式，哪种方便用哪种。</p>
</blockquote>
</blockquote>
<p>render介绍完，那么<code>render: h =&gt; h(App),</code>中<code>h</code>是什么，为什么<code>h(APP)</code>这样使用</p>
<p>这里参考<a href="https://css-tricks.com/what-does-the-h-stand-for-in-vues-render-method/">What does the ‘h’ stand for in Vue’s render method?</a>:</p>
<blockquote>
<p>The <code>h</code> stands for <strong>hyperscript</strong>, hyperscript is actually <a href="https://github.com/hyperhype/hyperscript">the name of a library</a> (what isn’t updated these days) and it actually has a <a href="https://github.com/hyperhype/hyperscript#ecosystem">small ecosystem</a>,</p>
<blockquote>
<p><a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx/issues/6#issuecomment-232994673">尤雨溪注</a>：</p>
<p><em>Hyperscript itself stands for “script that generates HTML structures</em>,</p>
</blockquote>
<p>Really, you can think of it as being short for <code>createElement</code>. Here would be the long form:</p>
<pre><code class="language-js">render: function (createElement) {
return createElement(App);
}
</code></pre>
<p>If we replace that with an <code>h</code>, then we first arrive at:</p>
<pre><code class="language-javascript">render: function (h) {
return h(App);
}
</code></pre>
<p>…which can then be shortened with the use of ES6 to:</p>
<pre><code class="language-js">render: h =&gt; h (App)
</code></pre>
<p>The Vue version takes up to three arguments:</p>
<pre><code class="language-js">render(h) {
  return h('div', {}, [...])
}
</code></pre>
<ol>
<li>The first is type of the element (here shown as <code>div</code>).</li>
<li>The second is the data object. We nest some fields here, including: props, attrs, dom props, class and style.</li>
<li>The third is an array of child nodes. We’ll then have nested calls and eventually return a tree of virtual DOM nodes.</li>
</ol>
<p>There’s more in-depth information in the <a href="https://vuejs.org/v2/guide/render-function.html#createElement-Arguments">Vue Guide here</a>.</p>
</blockquote>
<p>这里还提到了JSX，那么JSX是什么，有什么优势，为什么用它？</p>
<blockquote>
<pre><code class="language-js">Vue.component('jsx-example', {
  render (h) {
    return &lt;div id=&quot;foo&quot;&gt;bar&lt;/div&gt;
  }
})
</code></pre>
</blockquote>
<blockquote>
<p>摘<a href="https://blog.logrocket.com/using-jsx-with-vue/">Using JSX with Vue</a></p>
<p>首先，JSX是类似XML文本的语法扩展，用来写js代码，是render function的抽象版本。最开始是Facebook工程师发明，用来写React的。</p>
</blockquote>
<blockquote>
<p>摘官方文档<a href="https://vuejs.org/v2/guide/render-function.html#JSX">JSX</a></p>
<p>If you’re writing a lot of <code>render</code> functions, it might feel painful to write something like this:</p>
<blockquote>
<pre><code class="language-js">createElement(
  'anchored-heading', {
    props: {
      level: 1
    }
  }, [
    createElement('span', 'Hello'),
    ' world!'
  ]
)
</code></pre>
</blockquote>
<p>Especially when the template version is so simple in comparison:</p>
<blockquote>
<pre><code class="language-html">&lt;anchored-heading :level=&quot;1&quot;&gt;
  &lt;span&gt;Hello&lt;/span&gt; world!
&lt;/anchored-heading&gt;
</code></pre>
</blockquote>
<p>That’s why there’s a <a href="https://github.com/vuejs/jsx">Babel plugin</a> to use JSX with Vue, getting us back to a syntax that’s closer to templates:</p>
<blockquote>
<pre><code class="language-vue">import AnchoredHeading from './AnchoredHeading.vue'

new Vue({
  el: '#demo',
  render: function (h) {
    return (
      &lt;AnchoredHeading level={1}&gt;
        &lt;span&gt;Hello&lt;/span&gt; world!
      &lt;/AnchoredHeading&gt;
    )
  }
})
</code></pre>
<p>注意，Vue中通常都是用<code>h</code>来简写代表<code>createElement</code>，<strong>在JSX中是必须用<code>h</code>的，但是babel3.4版本之后的，已经自动注入了<code>const h = this.$createElement</code>到方法和设置器中，所以(h)参数可以省略，之前的版本没有<code>h</code>参数会抛<code>h</code> not available异常</strong></p>
</blockquote>
<p>参考[JSX Implementation](https://blog.logrocket.com/using-jsx-with-vue/Using JSX with Vue)还可以这样：</p>
<p>原先的：</p>
<blockquote>
<pre><code class="language-js">&lt;template&gt;
   &lt;div v-if=&quot;user.age &gt; 18&quot;&gt;
      Welcome, {{user.name}}
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
</blockquote>
<p>可以改为：</p>
<blockquote>
<pre><code class="language-js">export default {
....
  methods: {
      checkStatement(){
        if (this.user.age &gt; 18) {
           return &lt;div&gt; Welcome, { this.user.name }&lt;/div&gt;;
        }
      }
    },
    render(){
      return(
        {this.checkStatement()}
      )
    }
}
</code></pre>
</blockquote>
<p>render会调用这个checkStatement方法。</p>
<p>[Using JSX with Vue]([https://blog.logrocket.com/using-jsx-with-vue/Using%20JSX%20with%20Vue](https://blog.logrocket.com/using-jsx-with-vue/Using JSX with Vue))还有Loops (v-for),Events(v-on),Interpolation (v-html),Importing components几个的具体修改方法，就不摘抄了。</p>
<p>还有几个要注意的</p>
<h5 id="vues-jsx-syntax-gotchas"><a href="https://scotch.io/tutorials/using-jsx-with-vue-and-why-you-should-care#toc-vue-s-jsx-syntax-gotchas">Vue's JSX syntax gotchas</a></h5>
<blockquote>
<p>First, you can no longer use the <code>:</code> and <code>@</code> shortcuts for binding and listening to events. They are invalid JSX syntax and your code won't compile.</p>
<p>To listen for events in JSX, we need the &quot;<em>on</em>&quot; prefix. For example, use <code>onClick</code> for click events.</p>
<pre><code class="language-js">render (createElement) {
     return (
         &lt;button onClick={this.handleClick}&gt;&lt;/button&gt;
     )
 }
</code></pre>
<p>To modify events, use:</p>
<pre><code class="language-js"> render (createElement) {
     return (
         &lt;button onClick:prevent={this.handleClick}&gt;&lt;/button&gt;
     )
 }
</code></pre>
<p>To bind a variable, instead of <code>:</code> use: 以前就是<code>:content=&quot;generatedText&quot;</code></p>
<pre><code class="language-js"> render (createElement) {
     return (
         &lt;button content={this.generatedText}&gt;&lt;/button&gt;
     )
 }
</code></pre>
<p>To set HTML string as the content of an element, instead of <code>v-html</code> use:</p>
<pre><code class="language-js"> render (createElement) {
     return (
         &lt;button domPropsInnerHTML={htmlContent}&gt;&lt;/button&gt;
     )
 }
</code></pre>
<p>We can also spread a large object.</p>
<pre><code class="language-js"> render (createElement) {
     return (
         &lt;button {...this.largeProps}&gt;&lt;/button&gt;
     )
 }
</code></pre>
<h6 id="how-to-make-jsx-work-with-typescript"><a href="https://scotch.io/tutorials/using-jsx-with-vue-and-why-you-should-care#toc-how-to-make-jsx-work-with-typescript">How to make JSX work with TypeScript</a></h6>
</blockquote>
<h5 id="using-jsx-in-render"><a href="https://scotch.io/tutorials/using-jsx-with-vue-and-why-you-should-care#toc-using-jsx-in-render">Using JSX in render</a></h5>
<p>最后建议：template适合在模板比较复杂的情况下使用，JSX适合重复造轮，代码却不复杂的情况下使用。</p>
<blockquote>
<p>I’m working on a project that has quite an amount of low-level components. They contain lots of scripting with small amounts of templating. JSX feels like a breath of fresh air in this scenario.</p>
<p>On the other hand, when building large views that consist of large chunks of html with some custom components and directives, Vue templates are a better fit.</p>
<p>Luckily, we don’t need to pick one, we can use both! I’ll be my low-level components with JSX, and the “views”, which will be written by other developers, will be writting with familiar Vue templates.</p>
<p>I suppose I’ll see how this all goes, only one way to find out! If I encounter a bunch tradeoffs in the coming months, expect a follow-up post about why I reverted back to <code>.vue</code> files.</p>
</blockquote>
</blockquote>
<p>这里再介绍一个vue选项里的</p>
<h4 id="rendererror"><a href="https://cn.vuejs.org/v2/api/index.html#renderError">renderError</a></h4>
<blockquote>
<blockquote>
<p>2.2.0 新增</p>
</blockquote>
<ul>
<li>
<p><strong>类型</strong>：<code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></p>
</li>
<li>
<p><strong>详细</strong>：</p>
<p><strong>只在开发者环境下工作。</strong></p>
<p>当 <code>render</code> 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 <code>renderError</code>。这个功能配合 hot-reload 非常实用。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="language-js">new Vue({
  render (h) {
    throw new Error('oops')
  },
  renderError (h, err) {
    return h('pre', { style: { color: 'red' }}, err.stack)
  }
}).$mount('#app')
</code></pre>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[几个SEO的百科站]]></title>
        <id>https://dzkjz.github.io/post/ji-ge-seo-de-bai-ke-zhan/</id>
        <link href="https://dzkjz.github.io/post/ji-ge-seo-de-bai-ke-zhan/">
        </link>
        <updated>2020-08-07T15:55:20.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.matthewwoodward.co.uk/seo/ 建议</p>
<p>https://backlinko.com/hub/seo 建议</p>
<p>https://moz.com/learn/seo 初学者建议看这个先。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Surfer SEO]]></title>
        <id>https://dzkjz.github.io/post/surfer-seo/</id>
        <link href="https://dzkjz.github.io/post/surfer-seo/">
        </link>
        <updated>2020-08-07T15:52:56.000Z</updated>
        <content type="html"><![CDATA[<p>就是文章检测，帮你优化文章SEO效果的。有几个技术性指标，这个软件会检测，然后提供建议，建议直接按这个技术指标写一个app，就懒得付费了。<br>
https://www.matthewwoodward.co.uk/seo/reviews/surfer-seo/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[guest post 或者 买外链 结论]]></title>
        <id>https://dzkjz.github.io/post/guest-post-huo-zhe-mai-wai-lian-jie-lun/</id>
        <link href="https://dzkjz.github.io/post/guest-post-huo-zhe-mai-wai-lian-jie-lun/">
        </link>
        <updated>2020-08-07T15:47:09.000Z</updated>
        <content type="html"><![CDATA[<p>source https://ahrefs.com/blog/buy-backlinks/</p>
<blockquote>
<p>谷歌搜buy guest posts 可以看到很多结果</p>
<blockquote>
<p>​	All of these services fall into one of three categories:</p>
<ol>
<li><strong>Genuine guest posting services:</strong> They conduct <em>real</em> outreach to <em>real</em> blogs and secure guest post placements on your behalf.</li>
<li><strong>Disguised PBNs:</strong> They sell their service as real outreach, but they actually use PBNs. You can usually tell these services a mile off, as they’re <em>very</em> cheap (&lt;$100 per post). We don’t recommend using them unless you’re aware of, and accept, the risks associated with PBNs.</li>
<li><strong>Intermediary link buyers/sellers:</strong> They pay sites for inclusion on behalf of their clients, markup the price, then pocket the difference. Essentially, they’re middlemen (or women) in the link buying/selling process.</li>
</ol>
<p>I’d say #3 is the most common.</p>
</blockquote>
<p>博主测试给blogger直接发邮件</p>
<ol>
<li>直接说我要买guest post 价格平均361.44刀，</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/outreach-email-1.jpg" alt="" loading="lazy"></figure>
<ol start="2">
<li>说能不能发一篇guestpost不说给钱，要价均价77.8刀</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/guest-post-outreach-email.png" alt="" loading="lazy"></figure>
<p>DA越高，要价越高</p>
<p>结论</p>
<h3 id="paid-links-can-be-very-low-quality">Paid Links Can Be Very Low-quality</h3>
</blockquote>
<p>source https://www.authorityhacker.com/link-building-services/</p>
<p>测试了几个</p>
<blockquote>
<p>Fiverr<br>
Love to Link<br>
SERP Logic<br>
The Hoth<br>
FatJoe</p>
</blockquote>
<p><strong>都是垃圾，不值钱；</strong></p>
<p>fiverr几刀的就不说了，100刀的就是很普通的站点的外链。而且出站链接超多的站。</p>
<p>最低起价都是100+刀</p>
<blockquote>
<p>So should you buy them?</p>
<p>Nope, those services deliver low quality links that most of the time break Google’s terms of service, you are better off building a team that does the real thing.</p>
</blockquote>
<p>具体每一个商家的购买记录和评价看原文。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SEO 系列摘要【backlinko.com】]]></title>
        <id>https://dzkjz.github.io/post/seo-xi-lie-zhai-yao-backlinkocom/</id>
        <link href="https://dzkjz.github.io/post/seo-xi-lie-zhai-yao-backlinkocom/">
        </link>
        <updated>2020-08-07T14:49:18.000Z</updated>
        <content type="html"><![CDATA[<p>这个博主的文章观点很流行，但是文章太长。以后建议看这个博主文章的时候，直接看结论，除非特别想知道原理。</p>
<h2 id="ahrefs">Ahrefs</h2>
<p>source: https://backlinko.com/ahrefs-guide</p>
<blockquote>
<h4 id="backlink-profile">Backlink Profile</h4>
<p>If a site has a ton of backlinks, I recommend going to “Link type” → “Dofollow”.</p>
<p>I usually also hit the “One link per domain” or “Group similar links” button here.</p>
<h4 id="重点关注如何使用外链报告数据">重点关注：如何使用外链报告数据？</h4>
<ol>
<li>你看同行的外链，你如果有和同行文章差不多的，甚至介绍不同领域或者质量更好的，可以联系外链站点的站长，“两步法”问那个站长要外链。</li>
<li>去给外链的站点看，那边文章是写的啥，然后就能分析出为啥会链接你的同行；这就是起底！然后你可以积累越来越多的数据，什么样的文章可能有助于获得外链。</li>
</ol>
<h4 id="交叉外链分析">交叉外链分析</h4>
<p>In the top navigation hit “More” → “Link Intersect”.</p>
<p>Then, put two or more competing sites into the fields:</p>
<p>And voila! You get a list of sites that are linking to all of the sites you put in.</p>
<p>就是用这个功能，看你多个同行都从哪些相同的站获取到了外链。如果你的同行都是从【比如】A站点获得了外链，那么你和这个A站点的主题肯定也会有交集，或者有这种趋势，你可以看看可以一起打交道。比如A站是你以前不知道的广告主站点，那你可以申请成为他的affiliate。或者简单的就是给外链之类的。</p>
<h4 id="best-by-links-pages-on-a-site-that-have-the-most-backlinks">“Best by links” = pages on a site that have the most backlinks.</h4>
<p>博主以前分析Moz.com的时候，按这个排序，然后看到Moz所有最多外链的页面都是教程，另外Moz站权威度第二高的页面就是<a href="https://moz.com/beginners-guide-to-seo">Beginner’s Guide to SEO</a>。这个页面有114k条外链，然后博主几个月后就也搞了一个教程<a href="https://backlinko.com/keyword-research">The Definitive Guide to Keyword Research</a>.</p>
<p>效果就是现在这个页面有4.45k条外链了，同样用交叉外链，可以看到以前链接到Moz站的外链，同时也添加了链接到这个页面的链接。接下来博主继续创建了一个系列的文章，8个月增加了20%自然流量。</p>
<h4 id="new-backlinks">“New” Backlinks</h4>
<p>同行那边数据里面出现的新链接，也可能有机会给你带来新链接，老外链出链站点那边的文章有的都不再更新，文章内容可能过时了。</p>
<h4 id="lost-backlinks">“Lost” Backlinks</h4>
<p>可以前往查看掉了哪些外链，有助于分析为啥你会丢外链。</p>
<h4 id="content-gap">Content Gap</h4>
<p>分析同行在做而你没有做的关键词。</p>
</blockquote>
<h2 id="摩天大楼法">摩天大楼法</h2>
<p>source https://backlinko.com/skyscraper-technique</p>
<blockquote>
<p><strong>Step 1:</strong> Find Proven Linkable Assets</p>
<p>用SEO工具查看关键词，同行里社交分享最高的文章</p>
<p><strong>Step 2:</strong> Make something even better</p>
<p>写一篇更好的</p>
<p><strong>Step 3:</strong> Reach out to the right people</p>
<p>发给受众</p>
</blockquote>
<p>SEMrush</p>
<p>source https://backlinko.com/hub/seo/semrush</p>
<blockquote>
<p><strong>SEO Content Template</strong></p>
<p><strong>Link Building</strong></p>
<p>What’s unique about SEMrush is that they’ve built an interesting <a href="https://backlinko.com/link-building-tools">link building tool</a>:</p>
<ol>
<li>First, you enter keywords that you want to rank for:</li>
<li>Then, SEMrush will then find sites that link to the sites that are ranking for those keywords:</li>
<li>You can even create a prospect list and reach out to people inside of the platform (similar to <a href="https://backlinko.com/buzzstream-outreach">BuzzStream</a>):</li>
</ol>
</blockquote>
<p>OffPage-Seo</p>
<p>source https://backlinko.com/off-page-seo-guide</p>
<blockquote>
<h4 id="case-study-3-how-ash-got-dozens-of-media-features-with-zero-marketing-budget">Case Study #3 How Ash Got Dozens of Media Features With Zero Marketing Budget</h4>
<hr>
<p>Ash Turner runs a mobile device trade-in site called <a href="https://www.bankmycell.com/">BankMyCell</a>.</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/bankmycell-homepage-640x461.png" alt="" loading="lazy"></figure>
<p>Because Ash was bootstrapping his new site, he had essentially zero marketing budget.</p>
<p>But he DID have experience getting press for small businesses using surveys.</p>
<p>So the first thing Ash did was look for surveys in the mobile phone space that already got press coverage.</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/mobile-space-surveys-with-press-coverage-640x870.png" alt="" loading="lazy"></figure>
<p>Then, once he found a successful survey, he popped it into Ahrefs to see which data points journalists cited most often in their coverage.</p>
<p>(Very clever)</p>
<p>Next, Ash basically used The Skyscraper Technique on an existing survey… and pushed out a bigger and better version of his own.</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/bankmycell-mobile-phones-survey-640x601.png" alt="" loading="lazy"></figure>
<p>To get the word out, he creates a press release with the key findings and sends it to journalists that covered the initial study.</p>
<p>And because he’s promoting super valuable content to people that WANT to cover it, Ash has racked up tons of authority links from sites like The Guardian, Wired, CNET, Forbes and more.</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/bankmycell-backlinks-480x986.png" alt="" loading="lazy"></figure>
<p>Pretty cool.</p>
</blockquote>
<p>Source https://backlinko.com/how-to-rank-number-one-in-google</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/opp-formula-overview-960x706.png" alt="" loading="lazy"></figure>
<p>全文先抛出观点，结果：我的页面做到了关键词&quot;list building&quot;第一名</p>
<p>然后给出他的研究 OPP Formula</p>
<p>摘抄</p>
<blockquote>
<p>Here’s how it works:</p>
<p><strong>First, you have the Outcome.</strong></p>
<p>Start your intro off with the OUTCOME that your reader wants.</p>
<p>For example, what does someone searching for “list building” want?</p>
<p>MORE email subscribers!</p>
<p>So I start my intro off with that outcome front-and-center.</p>
<p><strong>Now that you’ve hooked them with the Outcome, it’s time for the Proof.</strong></p>
<p>Here’s where you prove that you know what you’re talking about.</p>
<p>For example, my intro shows people how I have 90k+ email subscribers.</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/90k-email-subscribers-768x242.png" alt="" loading="lazy"></figure>
<p><strong>Finally, cap you intro off with the Preview.</strong></p>
<p>This is easy:</p>
<p>All you need to do is preview what your content has in store for them</p>
<p>For example, my preview gives my reader a sneak peak into my post… which makes them want to keep reading.</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/preview-section-768x733.png" alt="" loading="lazy"></figure>
</blockquote>
<blockquote>
<p>You don’t need to go crazy and use a million images in every post.</p>
<p>Our search engine ranking factors study found that content with ONE image outranked pages that didn’t use a single image.</p>
<p>So using one image is WAY better than not using any at all.</p>
</blockquote>
<blockquote>
<p><strong>First</strong>, I used the phrase “How to” in my title.</p>
<p><strong>Next</strong>, I made sure to use a number in my title.</p>
</blockquote>
<blockquote>
<p>These related words and phrases help Google understand your content’s topic.</p>
<p>You’d just search for that keyword — and related keywords — in Google.</p>
<p>Finally, add those terms to your content.</p>
<p>You can also use Google Suggest.</p>
<p>Again, add a handful of these to your article and you’ll help Google better understand what your content is all about.</p>
</blockquote>
<blockquote>
<p><strong>First</strong>, find people that are legitimately interested in your post’s topic.</p>
<p>You can find these people by searching in Google……or using a tool like Buzzsumo.</p>
<p><strong>Next</strong>, you want to email these people to see if they’re interested in reading your content.</p>
<p>This is KEY. 邮件不要做舔狗。</p>
<p>Instead, I recommend using a two-step approach.</p>
<p>Your first email gauges someone’s interest in your content. That way you’re not shoving a link in someone’s face.</p>
<blockquote>
<p>Hi [Name],</p>
<p>I noticed that you recently shared one of my favorite articles about [topic].</p>
<p>I actually have a [topic] post coming out this week that I think you might enjoy.</p>
<p>Want me to let you know when it goes live?</p>
</blockquote>
<p>Here’s a real life example.</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/brian-outreach-step-one-960x471.png" alt="" loading="lazy"></figure>
<p>And when someone gets back to you saying they’d like to check out your content….</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/brian-outreach-step-one-response-960x506.png" alt="" loading="lazy"></figure>
<p>…THEN send them a link.</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/brian-outreach-step-two-640x555.png" alt="" loading="lazy"></figure>
<p>Note that I DON’T ask for a share.</p>
<p>Again, the point of the Content Roadshow isn’t to be a pushy jerkface.</p>
<p>Nobody likes a pushy jerkface 🙂</p>
<p>Instead, your goal is to <strong>get your content in front of people.</strong></p>
<p>Specifically, people that have the power to share it.</p>
<p>And these people aren’t dumb. If they like your content, they’ll share it. There’s no need to even ask.</p>
</blockquote>
<blockquote>
<h4 id="bonus-step-regularly-update-your-content">Bonus Step: Regularly Update Your Content</h4>
</blockquote>
<p>通篇看下来，这个博主爱写的文章就是step by step</p>
<p>然后每一段标题是观点，开头是论据【哪里有新的文章说什么什么了，研究发现了什么，我最近有一篇新文章讲到了什么什么】，然后用自己语言加图片复述一遍那个文章的观点，废话多加点，大道理也多加点，然后就是介绍自己怎么做的。照着做或者优化后的方法，然后就是配图，然后就是结果results，然后就是延伸讲或者承上启下一个小句子。</p>
<p>不过确实有的观点很新颖，对于其他的，对于需要直接了解怎么操作的，那可是真的太费时间了。对于那种新人【他这里新人不少】，那可能确实大道理说得新人很感触感动甚至悟透了。</p>
<p>缩水版还是要好得多。不过缩水版就最多几分钟看完，不会像他文章，字间距行间距段落间距都超级大。看着简直可以用鼠标滚轮发电了。</p>
<p>下面这个文章也是如此；</p>
<p>source https://backlinko.com/hub/seo/original-research</p>
<p>前面的就不摘抄了</p>
<blockquote>
<p>​	就是让你做数据分析调研，出来的结论可以被其他人引用，那就自然获得了链接了。</p>
<h3 id="best-practices">Best Practices</h3>
<p><strong>Find a Trending Topic</strong></p>
<p>How do you find a trending topic?</p>
<p><a href="https://trends.google.com/trends/">Google Trends</a>: Just pop a potential topic into Google Trends and see whether it’s growing or shrinking in popularity. If the line is moving up and to the right, you’re golden.</p>
<p><a href="https://backlinko.com/buzzsumo-guide">BuzzSumo</a>: This time, type a broad keyword into BuzzSumo. For example, if you’re in the content marketing niche, you’d put “content marketing” into the tool. Then, identify subtopics that are getting lots of shares. These are hot topics that can work really well as a research study.</p>
<p>Twitter: This isn’t as precise as BuzzSumo or Google Trends. But you can sometimes find white hot topics with <a href="https://twitter.com/search-home?lang=en">Twitter search</a>. Just be sure to confirm that the topic has long-term interest using Google Trends and BuzzSumo.</p>
<p><strong>Publish as a Blog Post</strong></p>
<p><strong>don’t</strong> publish the results as a PDF whitepaper.[If your #1 goal with your study is to <a href="https://backlinko.com/list-building">build your email list</a>, this approach might make sense. ]</p>
<p><strong>Pro Tip:</strong> Optimize post around keywords that bloggers and journalists search for (like “SEO statistics” or “YouTube Ranking factors”). That way, whenever someone needs a statistic for an article, they’ll find your study.</p>
<p>Use the biggest sample size you possibly can.</p>
<p>First, large sample size=stronger statistical significance. In other words, it makes your data more reliable.</p>
<p>Second, large numbers attract more attention.</p>
</blockquote>
<p>source https://backlinko.com/hub/seo/resource-pages</p>
<blockquote>
<p>​	观点就是，找这种页面，啥50个推荐的什么，或者100个什么，98个什么推荐的资源地址教程之类的。</p>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/resource-links-1280x1251.png" alt="" loading="lazy"></figure>
<p>主要是这种页面，如果你的文章也可以成为里面被收集的一部分，那就发【两步】邮件给站长，有的站点甚至直接就有 “Suggest a resource” link；</p>
<p>这样就又有一条外链了。</p>
<h3 id="best-practices-2">Best Practices</h3>
<p><strong>Find Resource Pages With Search Strings</strong></p>
<p>Your first step is to find resource pages in your industry.</p>
<p>Fortunately, most resource pages use the same terms… which makes them easy to find using search strings.</p>
<p>With that, here are a handful of search strings you can use to find resource pages:</p>
<ul>
<li>Keyword inurl:resources</li>
<li>Keyword “best resources”</li>
<li>Keyword” useful resources”</li>
<li>Keyword intitle:links</li>
<li>Keyword “helpful links”</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/resource-page-search-strings-1280x844.png" alt="" loading="lazy"></figure>
<p>So to increase your link opportunities, use these search strings to find non-obvious resource pages:</p>
<ul>
<li>Keyword “best sites”</li>
<li>Keyword “best blogs”</li>
<li>Keyword “blog awards”</li>
<li>Keyword “places to learn”</li>
</ul>
<p><strong>Reverse Engineer Your Competitor’s Resource Page Links</strong></p>
<p>First, pop a competing website into <a href="https://backlinko.com/hub/seo/ahrefs">Ahrefs</a>.</p>
<p>And look at their <a href="https://backlinko.com/backlinks-guide">backlinks</a>:</p>
<p>Then, search for terms that resource pages use (like “resources”).</p>
<p>And Ahrefs will show you their links that came from pages that used that term somewhere on the page,</p>
<p>And because they link to your competitor there’s GREAT chance they’ll link to you too.</p>
<p><strong>Look for Broken Links</strong> 这种resource页面也可以做死链请替换</p>
<p><strong>Don’t Forget “Mini Resource Pages”</strong></p>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/helpful-resources-1280x586.png" alt="" loading="lazy"></figure>
<p>That said, you can sometimes uncover a few of Mini Resource pages with this search strings:</p>
<ul>
<li>Keyword “learn more”</li>
<li>Keyword “other resources”</li>
<li>Keyword “learn online”</li>
</ul>
<p><strong>Focus On Realistic Targets</strong></p>
<p>那种只链接gov edu站点的，那种只链接自己内部站点的，就直接pass掉。</p>
<p><strong>Email The Person That Manages The Page</strong></p>
<p>大站点有专人负责专栏或者某一页内容，发邮件要找对人。</p>
<p><strong>Make It Easy to Add Your Link</strong></p>
<p>有的文章很长，你直接给出建议，你的文章链接适合加到哪。</p>
<p><strong>Personalize Your Outreach Emails</strong></p>
<p>个性化你的邮件，不要太模板化。</p>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/outreach-email-1-1280x1014.png" alt="" loading="lazy"></figure>
<p>不过最好是每种邮件都整理一套模板，发的时候修改一下。</p>
<p>博主给的模板</p>
<blockquote>
<p>​	Template #1: Standard Resource Page</p>
<p>Subject: Quick question</p>
<p>Hi [First Name],</p>
<p>I was looking for some information on [Topic] today, when I came across your excellent [Name of Page].</p>
<p>It was super helpful! Thank you.</p>
<p>I especially liked [Personalized Sentence or two].</p>
<p>Anyway, I realized that I recently published a page about [Related Topic]: [URL].</p>
<p>It’s [Brief Description].</p>
<p>It might make a nice addition under the [Section Name] of your page.</p>
<p>Anyway, thanks again for all of the excellent resources. And have an awesome week!</p>
<p>Talk Soon,<br>
[Your Name]</p>
<p>Template #2: Resource Page With Broken Link</p>
<p>Subject: Found a broken link</p>
<p>Hi [First Name],</p>
<p>I wanted to let you know that I found a few broken links on your [Resource Page Title].</p>
<p>[URL #1]<br>
[URL #2]<br>
[URL #3]</p>
<p>Your page was super helpful for me when I was recently learning about [Topic], so I wanted to return the favor.</p>
<p>Also, I wanted to let you know that I published a piece of content that might make a nice replacement for [URL].</p>
<p>Here’s the link: [URL]</p>
<p>Either way, I hope this helps and keep up the awesome work!</p>
<p>Talk Soon,<br>
[Your Name]</p>
</blockquote>
</blockquote>
]]></content>
    </entry>
</feed>