<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dzkjz.github.io/</id>
    <title>JojoLegend</title>
    <updated>2020-09-04T05:58:10.360Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dzkjz.github.io/"/>
    <link rel="self" href="https://dzkjz.github.io/atom.xml"/>
    <subtitle>Something for age</subtitle>
    <logo>https://dzkjz.github.io/images/avatar.png</logo>
    <icon>https://dzkjz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JojoLegend</rights>
    <entry>
        <title type="html"><![CDATA[Laravel Eloquent: Relationships学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-eloquent-relationships-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-eloquent-relationships-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-04T05:57:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<h3 id="存取器和更改器"><a href="https://laravel.com/docs/7.x/eloquent-mutators#accessors-and-mutators">存取器和更改器</a></h3>
<p>如果需要在返回的模型实例数据【返回的array和json api都自动添加上】后追加自定义的存取器值，先定义一个存取器【类似于计算属性】，</p>
<pre><code class="language-php">   public function getIsAdminAttribute()
    {
        return $this-&gt;attributes['admin'] === 'yes';
    }
</code></pre>
<p>然后再在模型类的appends属性array中，添加存储器的snake属性字符串</p>
<pre><code class="language-php">class User extends Model
{
    /**
     * The accessors to append to the model's array form.
     *
     * @var array
     */
    protected $appends = ['is_admin'];
}
</code></pre>
<h3 id="属性转换"><a href="https://laravel.com/docs/7.x/eloquent-mutators#attribute-casting">属性转换</a></h3>
<blockquote>
<p>$casts属性</p>
<p>自定义Cast类</p>
<h4 id="array-json-casting"><a href="https://laravel.com/docs/7.x/eloquent-mutators#array-and-json-casting">Array &amp; JSON Casting</a></h4>
<h4 id="date-casting"><a href="https://laravel.com/docs/7.x/eloquent-mutators#date-casting">Date Casting</a></h4>
<h4 id="query-time-casting"><a href="https://laravel.com/docs/7.x/eloquent-mutators#query-time-casting">Query Time Casting</a></h4>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Eloquent: Getting Started学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-eloquent-getting-started-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-eloquent-getting-started-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-04T03:00:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>如果需要对指定模型的查询请求添加全局作用域，可以参考<a href="https://laravel.com/docs/7.x/eloquent#global-scopes">Global Scopes</a></p>
<blockquote>
<p>其内部的apply方法会对今后作用于此模型的查询都起限定作用。</p>
</blockquote>
<p>Eloquent的操作会触发一系列的事件，请查看<a href="https://laravel.com/docs/7.x/eloquent#events">Events</a></p>
<blockquote>
<p>​	Eloquent models fire several events, allowing you to hook into the following points in a model's lifecycle: <code>retrieved</code>, <code>creating</code>, <code>created</code>, <code>updating</code>, <code>updated</code>, <code>saving</code>, <code>saved</code>, <code>deleting</code>, <code>deleted</code>, <code>restoring</code>, <code>restored</code>. Events allow you to easily execute code each time a specific model class is saved or updated in the database. Each event receives the instance of the model through its constructor.</p>
<p>The <code>retrieved</code> event will fire when an existing model is retrieved from the database. When a new model is saved for the first time, the <code>creating</code> and <code>created</code> events will fire. The <code>updating</code> / <code>updated</code> events will fire when an existing model is modified and the <code>save</code> method is called. The <code>saving</code> / <code>saved</code> events will fire when a model is created or updated.</p>
<blockquote>
<p>When issuing a mass update or delete via Eloquent, the <code>saved</code>, <code>updated</code>, <code>deleting</code>, and <code>deleted</code> model events will not be fired for the affected models. This is because the models are never actually retrieved when issuing a mass update or delete.</p>
</blockquote>
</blockquote>
<p>如果需要监听模型上多个事件，建议代码重新组织，Laravel提供了一个Observer方式，查看<a href="https://laravel.com/docs/7.x/eloquent#observers">Observers</a></p>
<blockquote>
<p><code>php artisan make:observer UserObserver --model=User</code></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Redis学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-redis-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-redis-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-03T16:26:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>Redis 键值存储</p>
<p>配置Redis 需安装扩展包，以及在database.php中配置<code>redis</code>选项。</p>
<p><code>database.php</code>中的默认配置一般足够应付开发需要。但是也可以自己修改。</p>
<blockquote>
<p>可以参考 <a href="https://laravel.com/docs/7.x/redis#configuration">Configuration</a></p>
</blockquote>
<p>注意 <a href="https://laravel.com/docs/7.x/redis#predis">Predis</a> 以及 <a href="https://laravel.com/docs/7.x/redis#phpredis">PhpRedis</a></p>
<blockquote>
<p>If you plan to use PhpRedis extension along with the <code>Redis</code> Facade alias, you should rename it to something else, like <code>RedisManager</code>, to avoid a collision with the Redis class. You can do that in the aliases section of your <code>app.php</code> config file.</p>
<pre><code class="language-php">'RedisManager' =&gt; Illuminate\Support\Facades\Redis::class,
</code></pre>
</blockquote>
<h3 id="interacting-with-redis"><a href="https://laravel.com/docs/7.x/redis#interacting-with-redis">Interacting With Redis</a></h3>
<pre><code class="language-php">// Laravel uses magic methods to pass the commands to the Redis server,
// so pass the arguments the Redis command expects:
Redis::set('name', 'Taylor');

$values = Redis::lrange('names', 5, 10);

// Alternatively, you may also pass commands to the server using the command method,
// which accepts the name of the command as its first argument,
// and an array of values as its second argument:

$values = Redis::command('lrange', ['name', 5, 10]);

// You may get a Redis instance by calling the Redis::connection method:
// This will give you an instance of the default Redis server
$redis = Redis::connection();


// You may also pass the connection or cluster name to the connection method to
// get a specific server or cluster as defined in your Redis configuration:
$redis = Redis::connection('my-connection');


// 一次要向redis服务器发送多个命令，建议使用管道
Redis::pipeline(
// 管道方法接受一个闭包作为参数，这个闭包参数是redis实例
    function ($pipe) {
        //把你要执行的命令通过闭包一次发送到redis服务器，提供了更好的性能
    for ($i = 0; $i &lt; 1000; $i++) {
        $pipe-&gt;set(&quot;key:$i&quot;, $i);
    }
});
</code></pre>
<h3 id="pub-sub"><a href="https://laravel.com/docs/7.x/redis#pubsub">Pub / Sub</a></h3>
<pre><code>// pub sub 命令 可以于一个指定信道监听获取消息
// 可以从其他应用发消息，甚至使用其他的编程语言 可以在进程、应用之间通信
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Database Seeding学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-database-seeding-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-database-seeding-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-03T14:52:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<blockquote>
<p><a href="https://laravel.com/docs/7.x/eloquent#mass-assignment">Mass assignment protection</a> is automatically disabled during database seeding.</p>
</blockquote>
<blockquote>
<p>Once you have written your seeder, you may need to regenerate Composer's autoloader using the <code>dump-autoload</code> command:</p>
<pre><code class="language-php">composer dump-autoload
</code></pre>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Database Migrations学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-database-migrations-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-database-migrations-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-03T14:12:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>Migrations就类似于数据包的版本控制。</p>
<h4 id="creating-columns"><a href="https://laravel.com/docs/7.x/migrations#creating-columns">Creating Columns</a> 创建列</h4>
<h4 id="column-modifiers"><a href="https://laravel.com/docs/7.x/migrations#column-modifiers">Column Modifiers</a> 修饰列</h4>
<h4 id="modifying-columns"><a href="https://laravel.com/docs/7.x/migrations#modifying-columns">Modifying Columns</a> 修改列</h4>
<h4 id="dropping-columns"><a href="https://laravel.com/docs/7.x/migrations#dropping-columns">Dropping Columns</a>删除列</h4>
<h3 id="indexes"><a href="https://laravel.com/docs/7.x/migrations#indexes">Indexes</a></h3>
<pre><code class="language-php">$table-&gt;id()-&gt;unique();
$table-&gt;primary('id');
$table-&gt;spatialIndex('location');//除了sqlite以外的都支持
$table-&gt;primary(['id', 'parent_id']);
$table-&gt;unique('email');
$table-&gt;index(['account_id', 'created_at']);
$table-&gt;unique('email',
    'unique_email'// specify the index name yourself
);
$table-&gt;renameIndex('from', 'to');

</code></pre>
<h4 id="foreign-key-constraints"><a href="https://laravel.com/docs/7.x/migrations#foreign-key-constraints">Foreign Key Constraints</a></h4>
<pre><code class="language-php">//外键【一个表[users表]上的键[id]出现在别的表[orders表]上，就是外键[user_id]】添加
$table-&gt;foreign('user_id')-&gt;references('id')-&gt;on('users');


//作用同上
$table-&gt;foreignId('user_id')//unsignedBigInteger别名
-&gt;constrained();


$table-&gt;foreignId('user_id')//unsignedBigInteger别名
-&gt;constrained('users')//可以指定表名
-&gt;onDelete('cascade')//预期行为
;


$table-&gt;foreignId('user_id')//unsignedBigInteger别名
-&gt;nullable()//可在constrained前调用
-&gt;constrained();


$table-&gt;dropForeign('posts_user_id_foreign');//删除外键[存放在posts表中的user_id外键]

//也可以
$table-&gt;dropForeign(['user_id']);


//启动外键约束
// SQLite disables foreign key constraints by default.
// When using SQLite, make sure to enable foreign key support in your
// database configuration before attempting to create them in your migrations.
// In addition, SQLite only supports foreign keys upon creation of the table and not when tables are altered.
Schema::enableForeignKeyConstraints();

//取消外键约束
Schema::disableForeignKeyConstraints();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Database Pagination学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-database-pagination-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-database-pagination-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-03T12:30:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>默认情况下，分页的当前页码是在http的请求字符串page里的，后端会自动检测到，当然也会由分页器自动给插入到前端。</p>
<pre><code class="language-php">$users = DB::table('users')-&gt;paginate(15);
if ($users) {
    return view('user.index', ['users' =&gt; $users]);
}
//分页数据对于groupBy方法结果不太支持【目前】，如果确有需要，请自己实现

$users = DB::table('users')-&gt;simplePaginate(15);//前端只需要后一页，前一页的链接数据，而不是分页结果里每一页的链接地址数据


$users = \App\Models\User::paginate(15);

$users = \App\Models\User::where('votes', '&gt;', 100)-&gt;paginate(15);

$users = \App\Models\User::where('votes', '&gt;', 100)-&gt;simplePaginate(15);


//自定义分页器
// Illuminate\Pagination\Paginator[对应simplePaginate方法]
// or
// Illuminate\Pagination\LengthAwarePaginator【对应有paginate方法】
</code></pre>
<blockquote>
<p>View部分，如果使用laravel的前端，可以查看<a href="https://laravel.com/docs/7.x/pagination#customizing-the-pagination-view">Customizing The Pagination View</a>详细了解。以及前端的blade模板自定义，blade中paginator方法的调用<a href="https://laravel.com/docs/7.x/pagination#paginator-instance-methods">Paginator Instance Methods</a>。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Database Query Builder学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-database-query-builder-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-database-query-builder-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-03T11:38:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>*<em>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</em></p>
</blockquote>
<blockquote>
<p>The Laravel query builder uses PDO parameter binding to protect your application against SQL injection attacks. There is no need to clean strings being passed as bindings.</p>
</blockquote>
<pre><code class="language-php">//Retrieve single Row
$user = DB::table('users')-&gt;where('name', 'John')-&gt;first();
echo $user-&gt;name;

//Retrieve single row data's column value
$email = DB::table('users')-&gt;where('name', 'John')-&gt;value('email');

//Retrieve By ID
$user = DB::table('users')-&gt;find(3);


//Retrieve a list of column values
$titles = DB::table('roles')-&gt;pluck('title');
foreach ($titles as $title) {
    echo $title;
}

//
$roles = DB::table('roles')-&gt;pluck('title', 'name');
foreach ($roles as $name =&gt; $title) {
    echo $title;
}

//一次取一部分数据，分块获取，每一小块还可放进闭包里处理
DB::table('users')-&gt;orderBy('id')-&gt;chunk(100, function ($users) {
    foreach ($users as $user) {
        //
    }
});

DB::table('users')-&gt;orderBy('id')-&gt;chunk(100, function ($users) {
    //处理数据

    return false;//返回false表示停止处理然后退出返回
});


//如果你需要在闭包里处理及更新数据，一遍更新，一边取，如果是按修改时间取，那你修改了的就一直是最新，就一直在修改这一段，
//这个时候，建议使用chunkById方法，会依据数据的primary key排序
DB::table('users')-&gt;where('active', false)
    -&gt;chunkById(100, function ($users) {
        foreach ($users as $user) {
            DB::table('users')-&gt;where('id', $user-&gt;id)-&gt;update(['active' =&gt; true]);
        }
    });

//不过还需要注意，如果你的操作是增加或者删除数据，任何对primary key或者外键的修改，会影响chunk query结果。

/** Aggregates */
// count, max, min, avg, sum

$users = DB::table('users')-&gt;count();

$price = DB::table('orders')-&gt;max('price');

$price = DB::table('orders')
    -&gt;where('finalized', 1)
    -&gt;avg('price');

$exists = DB::table('orders')-&gt;where('finalized', 1)-&gt;exists();
$notExists = DB::table('orders')-&gt;where('finalized', 1)-&gt;doesntExist();

/** Selects */
$users = DB::table('users')-&gt;select('name', 'email as user_email')-&gt;get();

//唯一值
$users = DB::table('users')-&gt;distinct()-&gt;get();

//追加select限定
$query = DB::table('users')-&gt;select('name');
$users = $query-&gt;addSelect('age')-&gt;get();

//原生 表达式
$users = DB::table('users')
    -&gt;select(DB::raw('count(*) as user_count,status'))//原生语句会以字符串的形式注入到sql query种，一定要避免sql注入
    -&gt;where('status', '&lt;&gt;', 1)
    -&gt;groupBy('status')
    -&gt;get();

//selectRaw
$orders = DB::table('orders')
    -&gt;selectRaw('price * ? as price_with_tax', [1.0825])//接受第二个参数作为第一语句中'?'的绑定值
    -&gt;get();

DB::table('orders')
    -&gt;whereRaw('price &gt; IF(state = &quot;TX&quot;,?,100)', [200])
    -&gt;get();

DB::table('orders')-&gt;select('department', DB::raw('SUM(price) as total_sales'))
    -&gt;groupBy('department')
    -&gt;havingRaw('SUM(price)&gt;?', [2500]) //haveRaw和orHavingRaw方法可用于将原始字符串设置为having子句的值
    -&gt;get();


//orderByRaw方法可用于将原始字符串设置为order by子句的值：
DB::table('orders')-&gt;orderByRaw('updated_at - created_at DESC')-&gt;get();

//groupByRaw方法可用于将原始字符串设置为group by子句的值：
DB::table('orders')-&gt;select('city', 'state')-&gt;groupByRaw('city,state')-&gt;get();


//Joins
//Unions
//Where Clauses
//Ordering, Grouping, Limit &amp; Offset
//Conditional Clauses
$role = $request-&gt;input('role');
DB::table('users')
    -&gt;when($role, function ($query, $role) {
        $query-&gt;where('role_id', $role);
    })-&gt;get();
//Inserts
//Updates
//Deletes
//Pessimistic Locking
//Debugging
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Database学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-database-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-database-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-02T16:27:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>*<em>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</em></p>
</blockquote>
<p>Laravel支持多种SQL数据库，如果需要查看每个数据库怎么配置，请查看官方文档<a href="https://laravel.com/docs/7.x/database#configuration">Configuration</a></p>
<p>使用了多个数据库链接的情况下，如果要指定选其中一个链接来处理，可以参考<a href="https://laravel.com/docs/7.x/database#using-multiple-database-connections">Using Multiple Database Connections</a></p>
<blockquote>
<p>DB facade支持的增删改查方法，详细的请看官方文档<a href="https://laravel.com/docs/7.x/database#running-queries">Running Raw SQL Queries</a></p>
</blockquote>
<h3 id="listening-for-query-events"><a href="https://laravel.com/docs/7.x/database#listening-for-query-events">Listening For Query Events</a></h3>
<p>每个SQL请求都会触发事件，如果需要log这些query或者debug，可以使用<code>DB::listen</code>方法。</p>
<blockquote>
<p>详细请看<a href="https://laravel.com/docs/7.x/database#listening-for-query-events">Listening For Query Events</a></p>
</blockquote>
<h3 id="数据库事务database-transactions">数据库事务<a href="https://laravel.com/docs/7.x/database#database-transactions">Database Transactions</a></h3>
<pre><code class="language-php">$users = DB::connection('mysql')-&gt;select('');

//获取底层的pdo实例
$pdo = DB::connection()-&gt;getPdo();

// The select method will always return an array of results.
// Each result within the array will be a PHP stdClass object,
// allowing you to access the values of the results:
$users = DB::select('select * from users where active = ?', [1]);
if ($users) {
    return view('user.index', ['users' =&gt; $users]);
}

foreach ($users as $user) {
    echo $user-&gt;name;
}

//Naming bindings

$results = DB::select('select * from users where id =:id', ['id' =&gt; 1]);


//insert
DB::insert('insert into users(id,name) values(?,?)', [1, 'Dayle']);

//update
$affected = DB::update('update users set votes = 100 where name= ? ', ['John']);


//delete
$deleted = DB::delete('delete from users'); // the number of rows affected will be returned:


//statement
// Some database statements do not return any value.
// For these types of operations, you may use the statement method on the DB facade:
DB::statement('drop table users');


//Database Transactions 数据库事务，闭包内事务如果执行异常，会自动回滚处理，如果成功，事务就会自动完成执行
DB::transaction(function () {
    DB::table('users')-&gt;update(['votes' =&gt; 1]);
    DB::table('posts')-&gt;delete();
});


DB::transaction(function () {
    DB::table('users')-&gt;update(['votes' =&gt; 1]);
    DB::table('posts')-&gt;delete();
}, 5);//第二个参数作用，如果出现死锁，会最大尝试5次，超次就会抛异常

//手动启动事务执行
DB::beginTransaction();
//手动回滚
DB::rollBack();
//手动提交事务
DB::commit();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Task Scheduling学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-task-scheduling-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-task-scheduling-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-02T07:28:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>Schedule就是用来简化Cron操作的。</p>
<blockquote>
<p>初始配置查看 <a href="https://laravel.com/docs/7.x/scheduling#introduction">Introduction</a></p>
</blockquote>
<blockquote>
<p>执行Artisan command，queue job，shell命令，闭包方法，以及执行时间间隔，频率，执行所处的时间段等详细资料查看官方文档<a href="https://laravel.com/docs/7.x/scheduling#defining-schedules">Defining Schedules</a>。</p>
</blockquote>
<p>如果你的应用放置在三个服务器上，你的计划调度就会三个服务器同时启动，只需要一个调度完成的任务，三个都在调度，这样明显不好，应该限制只在一个机器上运行就可以了。使用onOneServer方法。</p>
<blockquote>
<p>详细参考<a href="https://laravel.com/docs/7.x/scheduling#running-tasks-on-one-server">Running Tasks On One Server</a></p>
</blockquote>
<p>如果有多个命令依序执行，有几个超耗时的命令排在前面，那后面的命令可能就一直卡很久，都不能按计划时间执行，这时候应该把这些命令改成后台执行，这样它们就能同步执行了。</p>
<blockquote>
<p>详细参考<a href="https://laravel.com/docs/7.x/scheduling#background-tasks">Background Tasks</a></p>
</blockquote>
<p>如果你的应用进入维护模式，这个时候Scheduled任务是不会运行的，但是如果你不想某些任务受到维护模式影响而不能运行，使用 <code>evenInMaintenanceMode</code>方法；</p>
<blockquote>
<p>详细参考：<a href="https://laravel.com/docs/7.x/scheduling#maintenance-mode">Maintenance Mode</a></p>
</blockquote>
<h3 id="task-output"><a href="https://laravel.com/docs/7.x/scheduling#task-output">Task Output</a></h3>
<pre><code class="language-php">//输出到文件
$filePath = '';
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;sendOutputTo($filePath);

//追加到文件
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;appendOutputTo($filePath);

//如果配置好了email发送服务
//可以把输出发送到指定邮箱
$schedule-&gt;command('foo')
    -&gt;daily()
    -&gt;sendOutputTo($filePath)
    -&gt;emailOutputTo('foo@example.com');

//只把错误信息发到指定邮箱
$schedule-&gt;command('foo')
    -&gt;daily()
    -&gt;emailOutputOnFailure('foo@example.com');
</code></pre>
<blockquote>
<p>独有的方法：</p>
<p>The <code>emailOutputTo</code>, <code>emailOutputOnFailure</code>, <code>sendOutputTo</code>, and <code>appendOutputTo</code> methods are exclusive to the <code>command</code> and <code>exec</code> methods.</p>
</blockquote>
<h3 id="task-hooks"><a href="https://laravel.com/docs/7.x/scheduling#task-hooks">Task Hooks</a></h3>
<pre><code class="language-php">//可以在任务执行前后安插逻辑
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;before(function () {
        // Task is about to start...
    })-&gt;after(function () {
        // Task is complete...
    });

//可以在任务成功和失败后安插逻辑
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;onSuccess(function () {
        // The task succeeded...
    })-&gt;onFailure(function () {
        // The task is failed...
    });


$url = '';
//可以在任务执行前或完成后ping一个URL
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;pingBefore($url)
    -&gt;thenPing($url);

//条件为真才ping
$condition = true;
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;pingBeforeIf($condition, $url)
    -&gt;thenPingIf($condition, $url);


//任务执行成功或失败后ping url
$schedule-&gt;command('emails:send')
    -&gt;daily()
    -&gt;pingOnSuccess($url)
    -&gt;pingOnFailure($url);
</code></pre>
<blockquote>
<p>上面所有的ping 方法需要安装Guzzle Http包;</p>
<p>执行 <code>composer require guzzlehttp/guzzle</code>安装</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel Queues学习提纲]]></title>
        <id>https://dzkjz.github.io/post/laravel-queues-xue-xi-ti-gang/</id>
        <link href="https://dzkjz.github.io/post/laravel-queues-xue-xi-ti-gang/">
        </link>
        <updated>2020-09-02T03:40:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>带着问题学，文档里介绍的功能在什么情况下使用？这些功能有什么用？具体使用方法直接查看官方文档！</strong></p>
</blockquote>
<p>如果你有特别消耗时间的任务的时候，比如发送邮件，这时候用queue延迟一下发送操作，对于你的应用来说，可以急剧的提升请求速度。【用户点发送按钮，然后加入queue，整个应用不会因为卡在发送email过程而长时间等待，而是直接返回给用户，这样用户体验比较好】</p>
<p>如果你的应用在使用queue的时候，需要指定多个queue处理任务，比如一个queue用来存，一个用来发sms，一个用来做点其他的，那么可以给每个queue设置权重，权重越高的越先处理。<em>参考 <a href="https://laravel.com/docs/7.x/queues#connections-vs-queues">Connections Vs. Queues</a>最后一段文本。</em></p>
<h4 id="queuephp中的驱动配置可以参考driver-notes-prerequisites">queue.php中的驱动配置可以参考<a href="https://laravel.com/docs/7.x/queues#driver-prerequisites">Driver Notes &amp; Prerequisites</a></h4>
<h3 id="creating-jobs"><a href="https://laravel.com/docs/7.x/queues#creating-jobs">Creating Jobs</a></h3>
<p>Job用来被queue延迟执行的，主要是handle方法。</p>
<p>job一般是这样dispatch触发：dispatch就是加入到queue中；</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902093716.png" alt="" loading="lazy"></figure>
<p>传入job的model会被序列化，</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902093751.png" alt="" loading="lazy"></figure>
<p>而queue最后管理调用job的handle方法，执行处理。</p>
<blockquote>
<p>详细查看 <a href="https://laravel.com/docs/7.x/queues#class-structure">Class Structure</a> 以及 <a href="https://laravel.com/docs/7.x/queues#job-middleware">Job Middleware</a></p>
</blockquote>
<h3 id="dispatching-jobs"><a href="https://laravel.com/docs/7.x/queues#dispatching-jobs">Dispatching Jobs</a></h3>
<p>触发job查看官方文档。</p>
<p>如果要处理一个比如，发送邮件完毕且响应传回后才执行的job，可以使用</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902095041.png" alt="" loading="lazy"></figure>
<p>这两个方法；</p>
<p>如果不需要加入到queue而是需要立即处理掉job：</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902095315.png" alt="" loading="lazy"></figure>
<p>如果需要执行一列跟随任务：</p>
<p>参考<a href="https://laravel.com/docs/7.x/queues#job-chaining">Job Chaining</a>，比如</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/dzkjz/images-repo/master/20200902100238.png" alt="" loading="lazy"></figure>
<p>当然也可以在chain里加入闭包执行。</p>
<blockquote>
<p>job即使使用$this-&gt;delete()删除，也不会阻止chained的job被执行，除非job chain里面有fail。</p>
</blockquote>
<p>chain的jobs也可以指定connection和queue驱动执行，当然，如果chain里面的job显式指定过queue或者connection，那么该job会使用其指定的queue或connection。</p>
<blockquote>
<p>如果需要对job做等待超时，执行超时，超次限制，频率限制，请查看 <a href="https://laravel.com/docs/7.x/queues#max-job-attempts-and-timeout">Specifying Max Job Attempts / Timeout Values</a></p>
</blockquote>
<p>如果一个queued的job正在修改一个资源，但是这个资源同时只能有一个job去修改编辑，那么需要限制最大的工作job进程。</p>
<blockquote>
<p>请使用funnel做限制 ，参考<a href="https://laravel.com/docs/7.x/queues#rate-limiting">Rate Limiting</a></p>
</blockquote>
<p>需要注意的是，做了这么多限制之后，执行成功到底需要多少次尝试就很难判断了，因此，结合一个延时设置【 <a href="https://laravel.com/docs/7.x/queues#time-based-attempts">time based attempts</a>】会比较有用。</p>
<h3 id="queueing-closures"><a href="https://laravel.com/docs/7.x/queues#queueing-closures">Queueing Closures</a></h3>
<p>不想写job，或者job比较简单，可以直接queue一个闭包，逻辑写闭包里面就行。</p>
<h3 id="running-the-queue-worker"><a href="https://laravel.com/docs/7.x/queues#running-the-queue-worker">Running The Queue Worker</a></h3>
<pre><code class="language-php">php artisan queue:work
</code></pre>
<p>执行启动了<code>queue</code>之后，会一直在后台执行，但是代码的任何修改，<code>work</code>不会有反应，所以部署后，记得重启一下。</p>
<p>不过<code>php artisan queue:listen</code>可以侦听代码变化，不用重启<code>queue</code>，但是<code>listen</code>没有<code>work</code>高效。</p>
<pre><code class="language-php">php artisan queue:work redis --queue=emails
</code></pre>
<p><code>redis</code>就是指定的<code>queue connection</code>，<code>emails</code>就是指定的<code>queue</code>。</p>
<p>更多的queue 命令行操作参数比如权重，单次处理，停止，参考<a href="https://laravel.com/docs/7.x/queues#running-the-queue-worker">Running The Queue Worker</a></p>
<p>请注意：</p>
<blockquote>
<p>The queue uses the <a href="https://laravel.com/docs/7.x/cache">cache</a> to store restart signals, so you should verify a cache driver is properly configured for your application before using this feature.</p>
</blockquote>
<h4 id="job-expirations-timeouts"><a href="https://laravel.com/docs/7.x/queues#job-expirations-and-timeouts">Job Expirations &amp; Timeouts</a></h4>
<p>在您的config / queue.php配置文件中，每个队列连接定义一个retry_after选项。</p>
<p>该选项指定队列连接在重试正在处理的作业之前应等待的秒数。</p>
<p>例如，如果retry_after的值设置为90，则该job如果已处理90秒但未删除，则将其释放回到队列中。</p>
<h3 id="supervisor-configuration"><a href="https://laravel.com/docs/7.x/queues#supervisor-configuration">Supervisor Configuration</a></h3>
<p>如果有需要配置Supervisor，参考这个<a href="https://laravel.com/docs/7.x/queues#supervisor-configuration">Supervisor Configuration</a></p>
<h3 id="dealing-with-failed-jobs"><a href="https://laravel.com/docs/7.x/queues#dealing-with-failed-jobs">Dealing With Failed Jobs</a></h3>
<p>失败job重试，失败job记录到数据表，失败job清理，侦听失败job触发的事件，</p>
<p>如果传入job中的Eloquent模型在job被processing前删除了，job会抛出异常 <code>ModelNotFoundException</code>，默认可以在job类中的处理，参考<a href="https://laravel.com/docs/7.x/queues#ignoring-missing-models">Ignoring Missing Models</a></p>
<h3 id="job-events"><a href="https://laravel.com/docs/7.x/queues#job-events">Job Events</a></h3>
<p>如果需要在queue job执行前后做一些logging或者状态的编辑记录，可以参考<a href="https://laravel.com/docs/7.x/queues#job-events">Job Events</a>，主要是queue facade的before和after方法的调用，以及一个传入JobProcessing或JobProcessed类型事件参数的闭包。</p>
<p>还可以在worker尝试从queue中取一个job之前，执行一些逻辑。每次取之前都会执行。</p>
]]></content>
    </entry>
</feed>